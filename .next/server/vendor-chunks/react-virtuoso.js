"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-virtuoso";
exports.ids = ["vendor-chunks/react-virtuoso"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-virtuoso/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/react-virtuoso/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroupedVirtuoso: () => (/* binding */ GroupedVirtuoso),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   TableVirtuoso: () => (/* binding */ TableVirtuoso),\n/* harmony export */   Virtuoso: () => (/* binding */ Virtuoso),\n/* harmony export */   VirtuosoGrid: () => (/* binding */ VirtuosoGrid),\n/* harmony export */   VirtuosoGridMockContext: () => (/* binding */ VirtuosoGridMockContext),\n/* harmony export */   VirtuosoMockContext: () => (/* binding */ VirtuosoMockContext)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\nconst PUBLISH = 0;\nconst SUBSCRIBE = 1;\nconst RESET = 2;\nconst VALUE = 4;\nfunction compose(a, b) {\n  return (arg) => a(b(arg));\n}\nfunction thrush(arg, proc) {\n  return proc(arg);\n}\nfunction curry2to1(proc, arg1) {\n  return (arg2) => proc(arg1, arg2);\n}\nfunction curry1to0(proc, arg) {\n  return () => proc(arg);\n}\nfunction tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction tup(...args) {\n  return args;\n}\nfunction call(proc) {\n  proc();\n}\nfunction always(value) {\n  return () => value;\n}\nfunction joinProc(...procs) {\n  return () => {\n    procs.map(call);\n  };\n}\nfunction isDefined(arg) {\n  return arg !== void 0;\n}\nfunction noop() {\n}\nfunction subscribe(emitter, subscription) {\n  return emitter(SUBSCRIBE, subscription);\n}\nfunction publish(publisher, value) {\n  publisher(PUBLISH, value);\n}\nfunction reset(emitter) {\n  emitter(RESET);\n}\nfunction getValue(depot) {\n  return depot(VALUE);\n}\nfunction connect(emitter, publisher) {\n  return subscribe(emitter, curry2to1(publisher, PUBLISH));\n}\nfunction handleNext(emitter, subscription) {\n  const unsub = emitter(SUBSCRIBE, (value) => {\n    unsub();\n    subscription(value);\n  });\n  return unsub;\n}\nfunction stream() {\n  const subscriptions = [];\n  return (action, arg) => {\n    switch (action) {\n      case RESET:\n        subscriptions.splice(0, subscriptions.length);\n        return;\n      case SUBSCRIBE:\n        subscriptions.push(arg);\n        return () => {\n          const indexOf = subscriptions.indexOf(arg);\n          if (indexOf > -1) {\n            subscriptions.splice(indexOf, 1);\n          }\n        };\n      case PUBLISH:\n        subscriptions.slice().forEach((subscription) => {\n          subscription(arg);\n        });\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction statefulStream(initial) {\n  let value = initial;\n  const innerSubject = stream();\n  return (action, arg) => {\n    switch (action) {\n      case SUBSCRIBE:\n        const subscription = arg;\n        subscription(value);\n        break;\n      case PUBLISH:\n        value = arg;\n        break;\n      case VALUE:\n        return value;\n    }\n    return innerSubject(action, arg);\n  };\n}\nfunction eventHandler(emitter) {\n  let unsub;\n  let currentSubscription;\n  const cleanup = () => unsub && unsub();\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (subscription) {\n          if (currentSubscription === subscription) {\n            return;\n          }\n          cleanup();\n          currentSubscription = subscription;\n          unsub = subscribe(emitter, subscription);\n          return unsub;\n        } else {\n          cleanup();\n          return noop;\n        }\n      case RESET:\n        cleanup();\n        currentSubscription = null;\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction streamFromEmitter(emitter) {\n  return tap(stream(), (stream2) => connect(emitter, stream2));\n}\nfunction statefulStreamFromEmitter(emitter, initial) {\n  return tap(statefulStream(initial), (stream2) => connect(emitter, stream2));\n}\nfunction combineOperators(...operators) {\n  return (subscriber) => {\n    return operators.reduceRight(thrush, subscriber);\n  };\n}\nfunction pipe(source, ...operators) {\n  const project = combineOperators(...operators);\n  return (action, subscription) => {\n    switch (action) {\n      case SUBSCRIBE:\n        return subscribe(source, project(subscription));\n      case RESET:\n        reset(source);\n        return;\n    }\n  };\n}\nfunction defaultComparator(previous, next) {\n  return previous === next;\n}\nfunction distinctUntilChanged(comparator = defaultComparator) {\n  let current;\n  return (done) => (next) => {\n    if (!comparator(current, next)) {\n      current = next;\n      done(next);\n    }\n  };\n}\nfunction filter(predicate) {\n  return (done) => (value) => {\n    predicate(value) && done(value);\n  };\n}\nfunction map(project) {\n  return (done) => compose(done, project);\n}\nfunction mapTo(value) {\n  return (done) => () => done(value);\n}\nfunction scan(scanner, initial) {\n  return (done) => (value) => done(initial = scanner(initial, value));\n}\nfunction skip(times) {\n  return (done) => (value) => {\n    times > 0 ? times-- : done(value);\n  };\n}\nfunction throttleTime(interval) {\n  let currentValue = null;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      return;\n    }\n    timeout = setTimeout(() => {\n      timeout = void 0;\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction debounceTime(interval) {\n  let currentValue;\n  let timeout;\n  return (done) => (value) => {\n    currentValue = value;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      done(currentValue);\n    }, interval);\n  };\n}\nfunction withLatestFrom(...sources) {\n  const values = new Array(sources.length);\n  let called = 0;\n  let pendingCall = null;\n  const allCalled = Math.pow(2, sources.length) - 1;\n  sources.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      const prevCalled = called;\n      called = called | bit;\n      values[index] = value;\n      if (prevCalled !== allCalled && called === allCalled && pendingCall) {\n        pendingCall();\n        pendingCall = null;\n      }\n    });\n  });\n  return (done) => (value) => {\n    const call2 = () => done([value].concat(values));\n    if (called === allCalled) {\n      call2();\n    } else {\n      pendingCall = call2;\n    }\n  };\n}\nfunction merge(...sources) {\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        return joinProc(...sources.map((source) => subscribe(source, subscription)));\n      case RESET:\n        return;\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction duc(source, comparator = defaultComparator) {\n  return pipe(source, distinctUntilChanged(comparator));\n}\nfunction combineLatest(...emitters) {\n  const innerSubject = stream();\n  const values = new Array(emitters.length);\n  let called = 0;\n  const allCalled = Math.pow(2, emitters.length) - 1;\n  emitters.forEach((source, index) => {\n    const bit = Math.pow(2, index);\n    subscribe(source, (value) => {\n      values[index] = value;\n      called = called | bit;\n      if (called === allCalled) {\n        publish(innerSubject, values);\n      }\n    });\n  });\n  return function(action, subscription) {\n    switch (action) {\n      case SUBSCRIBE:\n        if (called === allCalled) {\n          subscription(values);\n        }\n        return subscribe(innerSubject, subscription);\n      case RESET:\n        return reset(innerSubject);\n      default:\n        throw new Error(`unrecognized action ${action}`);\n    }\n  };\n}\nfunction system(constructor, dependencies = [], { singleton } = { singleton: true }) {\n  return {\n    id: id(),\n    constructor,\n    dependencies,\n    singleton\n  };\n}\nconst id = () => Symbol();\nfunction init(systemSpec) {\n  const singletons = /* @__PURE__ */ new Map();\n  const _init = ({ id: id2, constructor, dependencies, singleton }) => {\n    if (singleton && singletons.has(id2)) {\n      return singletons.get(id2);\n    }\n    const system2 = constructor(dependencies.map((e) => _init(e)));\n    if (singleton) {\n      singletons.set(id2, system2);\n    }\n    return system2;\n  };\n  return _init(systemSpec);\n}\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!index.hasOwnProperty(prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect$1 = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nfunction systemToComponent(systemSpec, map2, Root) {\n  const requiredPropNames = Object.keys(map2.required || {});\n  const optionalPropNames = Object.keys(map2.optional || {});\n  const methodNames = Object.keys(map2.methods || {});\n  const eventNames = Object.keys(map2.events || {});\n  const Context = react__WEBPACK_IMPORTED_MODULE_1__.createContext({});\n  function applyPropsToSystem(system2, props) {\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], false);\n    }\n    for (const requiredPropName of requiredPropNames) {\n      const stream2 = system2[map2.required[requiredPropName]];\n      publish(stream2, props[requiredPropName]);\n    }\n    for (const optionalPropName of optionalPropNames) {\n      if (optionalPropName in props) {\n        const stream2 = system2[map2.optional[optionalPropName]];\n        publish(stream2, props[optionalPropName]);\n      }\n    }\n    if (system2[\"propsReady\"]) {\n      publish(system2[\"propsReady\"], true);\n    }\n  }\n  function buildMethods(system2) {\n    return methodNames.reduce((acc, methodName) => {\n      acc[methodName] = (value) => {\n        const stream2 = system2[map2.methods[methodName]];\n        publish(stream2, value);\n      };\n      return acc;\n    }, {});\n  }\n  function buildEventHandlers(system2) {\n    return eventNames.reduce((handlers, eventName) => {\n      handlers[eventName] = eventHandler(system2[map2.events[eventName]]);\n      return handlers;\n    }, {});\n  }\n  const Component = react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((propsWithChildren, ref) => {\n    const { children, ...props } = propsWithChildren;\n    const [system2] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => {\n      return tap(init(systemSpec), (system22) => applyPropsToSystem(system22, props));\n    });\n    const [handlers] = react__WEBPACK_IMPORTED_MODULE_1__.useState(curry1to0(buildEventHandlers, system2));\n    useIsomorphicLayoutEffect$1(() => {\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          subscribe(handlers[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        Object.values(handlers).map(reset);\n      };\n    }, [props, handlers, system2]);\n    useIsomorphicLayoutEffect$1(() => {\n      applyPropsToSystem(system2, props);\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, always(buildMethods(system2)));\n    const RootComponent = Root;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Context.Provider, { value: system2, children: Root ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RootComponent, { ...omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props), children }) : children });\n  });\n  const usePublisher2 = (key) => {\n    return react__WEBPACK_IMPORTED_MODULE_1__.useCallback(curry2to1(publish, react__WEBPACK_IMPORTED_MODULE_1__.useContext(Context)[key]), [key]);\n  };\n  const useEmitterValue18 = (key) => {\n    const system2 = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Context);\n    const source = system2[key];\n    const cb = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n      (c) => {\n        return subscribe(source, c);\n      },\n      [source]\n    );\n    return react__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore(\n      cb,\n      () => getValue(source),\n      () => getValue(source)\n    );\n  };\n  const useEmitterValueLegacy = (key) => {\n    const system2 = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Context);\n    const source = system2[key];\n    const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_1__.useState(curry1to0(getValue, source));\n    useIsomorphicLayoutEffect$1(\n      () => subscribe(source, (next) => {\n        if (next !== value) {\n          setValue(always(next));\n        }\n      }),\n      [source, value]\n    );\n    return value;\n  };\n  const useEmitterValue2 = react__WEBPACK_IMPORTED_MODULE_1__.version.startsWith(\"18\") ? useEmitterValue18 : useEmitterValueLegacy;\n  const useEmitter2 = (key, callback) => {\n    const context = react__WEBPACK_IMPORTED_MODULE_1__.useContext(Context);\n    const source = context[key];\n    useIsomorphicLayoutEffect$1(() => subscribe(source, callback), [callback, source]);\n  };\n  return {\n    Component,\n    usePublisher: usePublisher2,\n    useEmitterValue: useEmitterValue2,\n    useEmitter: useEmitter2\n  };\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel2[LogLevel2[\"INFO\"] = 1] = \"INFO\";\n  LogLevel2[LogLevel2[\"WARN\"] = 2] = \"WARN\";\n  LogLevel2[LogLevel2[\"ERROR\"] = 3] = \"ERROR\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CONSOLE_METHOD_MAP = {\n  [\n    0\n    /* DEBUG */\n  ]: \"debug\",\n  [\n    1\n    /* INFO */\n  ]: \"log\",\n  [\n    2\n    /* WARN */\n  ]: \"warn\",\n  [\n    3\n    /* ERROR */\n  ]: \"error\"\n};\nconst getGlobalThis = () => typeof globalThis === \"undefined\" ? window : globalThis;\nconst loggerSystem = system(\n  () => {\n    const logLevel = statefulStream(\n      3\n      /* ERROR */\n    );\n    const log = statefulStream((label, message, level = 1) => {\n      var _a;\n      const currentLevel = (_a = getGlobalThis()[\"VIRTUOSO_LOG_LEVEL\"]) != null ? _a : getValue(logLevel);\n      if (level >= currentLevel) {\n        console[CONSOLE_METHOD_MAP[level]](\n          \"%creact-virtuoso: %c%s %o\",\n          \"color: #0253b3; font-weight: bold\",\n          \"color: initial\",\n          label,\n          message\n        );\n      }\n    });\n    return {\n      log,\n      logLevel\n    };\n  },\n  [],\n  { singleton: true }\n);\nfunction useSizeWithElRef(callback, enabled, skipAnimationFrame) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  let callbackRef = (_el) => {\n  };\n  if (typeof ResizeObserver !== \"undefined\") {\n    const observer = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n      return new ResizeObserver((entries) => {\n        const code = () => {\n          const element = entries[0].target;\n          if (element.offsetParent !== null) {\n            callback(element);\n          }\n        };\n        skipAnimationFrame ? code() : requestAnimationFrame(code);\n      });\n    }, [callback]);\n    callbackRef = (elRef) => {\n      if (elRef && enabled) {\n        observer.observe(elRef);\n        ref.current = elRef;\n      } else {\n        if (ref.current) {\n          observer.unobserve(ref.current);\n        }\n        ref.current = null;\n      }\n    };\n  }\n  return { ref, callbackRef };\n}\nfunction useSize(callback, enabled, skipAnimationFrame) {\n  return useSizeWithElRef(callback, enabled, skipAnimationFrame).callbackRef;\n}\nfunction useChangedListContentsSizes(callback, itemSize, enabled, scrollContainerStateCallback, log, gap, customScrollParent, horizontalDirection, skipAnimationFrame) {\n  const memoedCallback = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (el) => {\n      const ranges = getChangedChildSizes(el.children, itemSize, horizontalDirection ? \"offsetWidth\" : \"offsetHeight\", log);\n      let scrollableElement = el.parentElement;\n      while (!scrollableElement.dataset[\"virtuosoScroller\"]) {\n        scrollableElement = scrollableElement.parentElement;\n      }\n      const windowScrolling = scrollableElement.lastElementChild.dataset[\"viewportType\"] === \"window\";\n      const scrollTop = customScrollParent ? horizontalDirection ? customScrollParent.scrollLeft : customScrollParent.scrollTop : windowScrolling ? horizontalDirection ? window.pageXOffset || document.documentElement.scrollLeft : window.pageYOffset || document.documentElement.scrollTop : horizontalDirection ? scrollableElement.scrollLeft : scrollableElement.scrollTop;\n      const scrollHeight = customScrollParent ? horizontalDirection ? customScrollParent.scrollWidth : customScrollParent.scrollHeight : windowScrolling ? horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight : horizontalDirection ? scrollableElement.scrollWidth : scrollableElement.scrollHeight;\n      const viewportHeight = customScrollParent ? horizontalDirection ? customScrollParent.offsetWidth : customScrollParent.offsetHeight : windowScrolling ? horizontalDirection ? window.innerWidth : window.innerHeight : horizontalDirection ? scrollableElement.offsetWidth : scrollableElement.offsetHeight;\n      scrollContainerStateCallback({\n        scrollTop: Math.max(scrollTop, 0),\n        scrollHeight,\n        viewportHeight\n      });\n      gap == null ? void 0 : gap(\n        horizontalDirection ? resolveGapValue$1(\"column-gap\", getComputedStyle(el).columnGap, log) : resolveGapValue$1(\"row-gap\", getComputedStyle(el).rowGap, log)\n      );\n      if (ranges !== null) {\n        callback(ranges);\n      }\n    },\n    [callback, itemSize, log, gap, customScrollParent, scrollContainerStateCallback]\n  );\n  return useSizeWithElRef(memoedCallback, enabled, skipAnimationFrame);\n}\nfunction getChangedChildSizes(children, itemSize, field, log) {\n  const length = children.length;\n  if (length === 0) {\n    return null;\n  }\n  const results = [];\n  for (let i = 0; i < length; i++) {\n    const child = children.item(i);\n    if (!child || child.dataset.index === void 0) {\n      continue;\n    }\n    const index = parseInt(child.dataset.index);\n    const knownSize = parseFloat(child.dataset.knownSize);\n    const size = itemSize(child, field);\n    if (size === 0) {\n      log(\"Zero-sized element, this should not happen\", { child }, LogLevel.ERROR);\n    }\n    if (size === knownSize) {\n      continue;\n    }\n    const lastResult = results[results.length - 1];\n    if (results.length === 0 || lastResult.size !== size || lastResult.endIndex !== index - 1) {\n      results.push({ startIndex: index, endIndex: index, size });\n    } else {\n      results[results.length - 1].endIndex++;\n    }\n  }\n  return results;\n}\nfunction resolveGapValue$1(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nfunction correctItemSize(el, dimension) {\n  return Math.round(el.getBoundingClientRect()[dimension]);\n}\nfunction approximatelyEqual(num1, num2) {\n  return Math.abs(num1 - num2) < 1.01;\n}\nfunction useScrollTop(scrollContainerStateCallback, smoothScrollTargetReached, scrollerElement, scrollerRefCallback = noop, customScrollParent, horizontalDirection) {\n  const scrollerRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const scrollTopTarget = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const handler = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (ev) => {\n      const el = ev.target;\n      const windowScroll = el === window || el === document;\n      const scrollTop = horizontalDirection ? windowScroll ? window.pageXOffset || document.documentElement.scrollLeft : el.scrollLeft : windowScroll ? window.pageYOffset || document.documentElement.scrollTop : el.scrollTop;\n      const scrollHeight = horizontalDirection ? windowScroll ? document.documentElement.scrollWidth : el.scrollWidth : windowScroll ? document.documentElement.scrollHeight : el.scrollHeight;\n      const viewportHeight = horizontalDirection ? windowScroll ? window.innerWidth : el.offsetWidth : windowScroll ? window.innerHeight : el.offsetHeight;\n      const call2 = () => {\n        scrollContainerStateCallback({\n          scrollTop: Math.max(scrollTop, 0),\n          scrollHeight,\n          viewportHeight\n        });\n      };\n      if (ev.suppressFlushSync) {\n        call2();\n      } else {\n        react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(call2);\n      }\n      if (scrollTopTarget.current !== null) {\n        if (scrollTop === scrollTopTarget.current || scrollTop <= 0 || scrollTop === scrollHeight - viewportHeight) {\n          scrollTopTarget.current = null;\n          smoothScrollTargetReached(true);\n          if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n            timeoutRef.current = null;\n          }\n        }\n      }\n    },\n    [scrollContainerStateCallback, smoothScrollTargetReached]\n  );\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    const localRef = customScrollParent ? customScrollParent : scrollerRef.current;\n    scrollerRefCallback(customScrollParent ? customScrollParent : scrollerRef.current);\n    handler({ target: localRef, suppressFlushSync: true });\n    localRef.addEventListener(\"scroll\", handler, { passive: true });\n    return () => {\n      scrollerRefCallback(null);\n      localRef.removeEventListener(\"scroll\", handler);\n    };\n  }, [scrollerRef, handler, scrollerElement, scrollerRefCallback, customScrollParent]);\n  function scrollToCallback(location) {\n    const scrollerElement2 = scrollerRef.current;\n    if (!scrollerElement2 || (horizontalDirection ? \"offsetWidth\" in scrollerElement2 && scrollerElement2.offsetWidth === 0 : \"offsetHeight\" in scrollerElement2 && scrollerElement2.offsetHeight === 0)) {\n      return;\n    }\n    const isSmooth = location.behavior === \"smooth\";\n    let offsetHeight;\n    let scrollHeight;\n    let scrollTop;\n    if (scrollerElement2 === window) {\n      scrollHeight = Math.max(\n        correctItemSize(document.documentElement, horizontalDirection ? \"width\" : \"height\"),\n        horizontalDirection ? document.documentElement.scrollWidth : document.documentElement.scrollHeight\n      );\n      offsetHeight = horizontalDirection ? window.innerWidth : window.innerHeight;\n      scrollTop = horizontalDirection ? document.documentElement.scrollLeft : document.documentElement.scrollTop;\n    } else {\n      scrollHeight = scrollerElement2[horizontalDirection ? \"scrollWidth\" : \"scrollHeight\"];\n      offsetHeight = correctItemSize(scrollerElement2, horizontalDirection ? \"width\" : \"height\");\n      scrollTop = scrollerElement2[horizontalDirection ? \"scrollLeft\" : \"scrollTop\"];\n    }\n    const maxScrollTop = scrollHeight - offsetHeight;\n    location.top = Math.ceil(Math.max(Math.min(maxScrollTop, location.top), 0));\n    if (approximatelyEqual(offsetHeight, scrollHeight) || location.top === scrollTop) {\n      scrollContainerStateCallback({ scrollTop, scrollHeight, viewportHeight: offsetHeight });\n      if (isSmooth) {\n        smoothScrollTargetReached(true);\n      }\n      return;\n    }\n    if (isSmooth) {\n      scrollTopTarget.current = location.top;\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        timeoutRef.current = null;\n        scrollTopTarget.current = null;\n        smoothScrollTargetReached(true);\n      }, 1e3);\n    } else {\n      scrollTopTarget.current = null;\n    }\n    if (horizontalDirection) {\n      location = { left: location.top, behavior: location.behavior };\n    }\n    scrollerElement2.scrollTo(location);\n  }\n  function scrollByCallback(location) {\n    if (horizontalDirection) {\n      location = { left: location.top, behavior: location.behavior };\n    }\n    scrollerRef.current.scrollBy(location);\n  }\n  return { scrollerRef, scrollByCallback, scrollToCallback };\n}\nconst domIOSystem = system(\n  () => {\n    const scrollContainerState = stream();\n    const scrollTop = stream();\n    const deviation = statefulStream(0);\n    const smoothScrollTargetReached = stream();\n    const statefulScrollTop = statefulStream(0);\n    const viewportHeight = stream();\n    const scrollHeight = stream();\n    const headerHeight = statefulStream(0);\n    const fixedHeaderHeight = statefulStream(0);\n    const fixedFooterHeight = statefulStream(0);\n    const footerHeight = statefulStream(0);\n    const scrollTo = stream();\n    const scrollBy = stream();\n    const scrollingInProgress = statefulStream(false);\n    const horizontalDirection = statefulStream(false);\n    const skipAnimationFrameInResizeObserver = statefulStream(false);\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollTop: scrollTop2 }) => scrollTop2)\n      ),\n      scrollTop\n    );\n    connect(\n      pipe(\n        scrollContainerState,\n        map(({ scrollHeight: scrollHeight2 }) => scrollHeight2)\n      ),\n      scrollHeight\n    );\n    connect(scrollTop, statefulScrollTop);\n    return {\n      // input\n      scrollContainerState,\n      scrollTop,\n      viewportHeight,\n      headerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight,\n      footerHeight,\n      scrollHeight,\n      smoothScrollTargetReached,\n      horizontalDirection,\n      skipAnimationFrameInResizeObserver,\n      // signals\n      scrollTo,\n      scrollBy,\n      // state\n      statefulScrollTop,\n      deviation,\n      scrollingInProgress\n    };\n  },\n  [],\n  { singleton: true }\n);\nconst NIL_NODE = { lvl: 0 };\nfunction newAANode(k, v, lvl, l = NIL_NODE, r = NIL_NODE) {\n  return { k, v, lvl, l, r };\n}\nfunction empty(node) {\n  return node === NIL_NODE;\n}\nfunction newTree() {\n  return NIL_NODE;\n}\nfunction remove(node, key) {\n  if (empty(node)) return NIL_NODE;\n  const { k, l, r } = node;\n  if (key === k) {\n    if (empty(l)) {\n      return r;\n    } else if (empty(r)) {\n      return l;\n    } else {\n      const [lastKey, lastValue] = last(l);\n      return adjust(clone(node, { k: lastKey, v: lastValue, l: deleteLast(l) }));\n    }\n  } else if (key < k) {\n    return adjust(clone(node, { l: remove(l, key) }));\n  } else {\n    return adjust(clone(node, { r: remove(r, key) }));\n  }\n}\nfunction find(node, key) {\n  if (empty(node)) {\n    return;\n  }\n  if (key === node.k) {\n    return node.v;\n  } else if (key < node.k) {\n    return find(node.l, key);\n  } else {\n    return find(node.r, key);\n  }\n}\nfunction findMaxKeyValue(node, value, field = \"k\") {\n  if (empty(node)) {\n    return [-Infinity, void 0];\n  }\n  if (Number(node[field]) === value) {\n    return [node.k, node.v];\n  }\n  if (Number(node[field]) < value) {\n    const r = findMaxKeyValue(node.r, value, field);\n    if (r[0] === -Infinity) {\n      return [node.k, node.v];\n    } else {\n      return r;\n    }\n  }\n  return findMaxKeyValue(node.l, value, field);\n}\nfunction insert(node, k, v) {\n  if (empty(node)) {\n    return newAANode(k, v, 1);\n  }\n  if (k === node.k) {\n    return clone(node, { k, v });\n  } else if (k < node.k) {\n    return rebalance(clone(node, { l: insert(node.l, k, v) }));\n  } else {\n    return rebalance(clone(node, { r: insert(node.r, k, v) }));\n  }\n}\nfunction walkWithin(node, start, end) {\n  if (empty(node)) {\n    return [];\n  }\n  const { k, v, l, r } = node;\n  let result = [];\n  if (k > start) {\n    result = result.concat(walkWithin(l, start, end));\n  }\n  if (k >= start && k <= end) {\n    result.push({ k, v });\n  }\n  if (k <= end) {\n    result = result.concat(walkWithin(r, start, end));\n  }\n  return result;\n}\nfunction walk(node) {\n  if (empty(node)) {\n    return [];\n  }\n  return [...walk(node.l), { k: node.k, v: node.v }, ...walk(node.r)];\n}\nfunction last(node) {\n  return empty(node.r) ? [node.k, node.v] : last(node.r);\n}\nfunction deleteLast(node) {\n  return empty(node.r) ? node.l : adjust(clone(node, { r: deleteLast(node.r) }));\n}\nfunction clone(node, args) {\n  return newAANode(\n    args.k !== void 0 ? args.k : node.k,\n    args.v !== void 0 ? args.v : node.v,\n    args.lvl !== void 0 ? args.lvl : node.lvl,\n    args.l !== void 0 ? args.l : node.l,\n    args.r !== void 0 ? args.r : node.r\n  );\n}\nfunction isSingle(node) {\n  return empty(node) || node.lvl > node.r.lvl;\n}\nfunction rebalance(node) {\n  return split(skew(node));\n}\nfunction adjust(node) {\n  const { l, r, lvl } = node;\n  if (r.lvl >= lvl - 1 && l.lvl >= lvl - 1) {\n    return node;\n  } else if (lvl > r.lvl + 1) {\n    if (isSingle(l)) {\n      return skew(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(l) && !empty(l.r)) {\n        return clone(l.r, {\n          l: clone(l, { r: l.r.l }),\n          r: clone(node, {\n            l: l.r.r,\n            lvl: lvl - 1\n          }),\n          lvl\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  } else {\n    if (isSingle(node)) {\n      return split(clone(node, { lvl: lvl - 1 }));\n    } else {\n      if (!empty(r) && !empty(r.l)) {\n        const rl = r.l;\n        const rlvl = isSingle(rl) ? r.lvl - 1 : r.lvl;\n        return clone(rl, {\n          l: clone(node, {\n            r: rl.l,\n            lvl: lvl - 1\n          }),\n          r: split(clone(r, { l: rl.r, lvl: rlvl })),\n          lvl: rl.lvl + 1\n        });\n      } else {\n        throw new Error(\"Unexpected empty nodes\");\n      }\n    }\n  }\n}\nfunction rangesWithin(node, startIndex, endIndex) {\n  if (empty(node)) {\n    return [];\n  }\n  const adjustedStart = findMaxKeyValue(node, startIndex)[0];\n  return toRanges(walkWithin(node, adjustedStart, endIndex));\n}\nfunction arrayToRanges(items, parser) {\n  const length = items.length;\n  if (length === 0) {\n    return [];\n  }\n  let { index: start, value } = parser(items[0]);\n  const result = [];\n  for (let i = 1; i < length; i++) {\n    const { index: nextIndex, value: nextValue } = parser(items[i]);\n    result.push({ start, end: nextIndex - 1, value });\n    start = nextIndex;\n    value = nextValue;\n  }\n  result.push({ start, end: Infinity, value });\n  return result;\n}\nfunction toRanges(nodes) {\n  return arrayToRanges(nodes, ({ k: index, v: value }) => ({ index, value }));\n}\nfunction split(node) {\n  const { r, lvl } = node;\n  return !empty(r) && !empty(r.r) && r.lvl === lvl && r.r.lvl === lvl ? clone(r, { l: clone(node, { r: r.l }), lvl: lvl + 1 }) : node;\n}\nfunction skew(node) {\n  const { l } = node;\n  return !empty(l) && l.lvl === node.lvl ? clone(l, { r: clone(node, { l: l.r }) }) : node;\n}\nfunction findIndexOfClosestSmallerOrEqual(items, value, comparator, start = 0) {\n  let end = items.length - 1;\n  while (start <= end) {\n    const index = Math.floor((start + end) / 2);\n    const item = items[index];\n    const match = comparator(item, value);\n    if (match === 0) {\n      return index;\n    }\n    if (match === -1) {\n      if (end - start < 2) {\n        return index - 1;\n      }\n      end = index - 1;\n    } else {\n      if (end === start) {\n        return index;\n      }\n      start = index + 1;\n    }\n  }\n  throw new Error(`Failed binary finding record in array - ${items.join(\",\")}, searched for ${value}`);\n}\nfunction findClosestSmallerOrEqual(items, value, comparator) {\n  return items[findIndexOfClosestSmallerOrEqual(items, value, comparator)];\n}\nfunction findRange(items, startValue, endValue, comparator) {\n  const startIndex = findIndexOfClosestSmallerOrEqual(items, startValue, comparator);\n  const endIndex = findIndexOfClosestSmallerOrEqual(items, endValue, comparator, startIndex);\n  return items.slice(startIndex, endIndex + 1);\n}\nconst recalcSystem = system(\n  () => {\n    const recalcInProgress = statefulStream(false);\n    return { recalcInProgress };\n  },\n  [],\n  { singleton: true }\n);\nfunction rangeIncludes(refRange) {\n  const { size, startIndex, endIndex } = refRange;\n  return (range) => {\n    return range.start === startIndex && (range.end === endIndex || range.end === Infinity) && range.value === size;\n  };\n}\nfunction affectedGroupCount(offset, groupIndices) {\n  let recognizedOffsetItems = 0;\n  let groupIndex = 0;\n  while (recognizedOffsetItems < offset) {\n    recognizedOffsetItems += groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n    groupIndex++;\n  }\n  const offsetIsExact = recognizedOffsetItems === offset;\n  return groupIndex - (offsetIsExact ? 0 : 1);\n}\nfunction insertRanges(sizeTree, ranges) {\n  let syncStart = empty(sizeTree) ? 0 : Infinity;\n  for (const range of ranges) {\n    const { size, startIndex, endIndex } = range;\n    syncStart = Math.min(syncStart, startIndex);\n    if (empty(sizeTree)) {\n      sizeTree = insert(sizeTree, 0, size);\n      continue;\n    }\n    const overlappingRanges = rangesWithin(sizeTree, startIndex - 1, endIndex + 1);\n    if (overlappingRanges.some(rangeIncludes(range))) {\n      continue;\n    }\n    let firstPassDone = false;\n    let shouldInsert = false;\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlappingRanges) {\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size;\n        firstPassDone = true;\n      } else {\n        if (endIndex >= rangeStart || size === rangeValue) {\n          sizeTree = remove(sizeTree, rangeStart);\n        }\n      }\n      if (rangeEnd > endIndex && endIndex >= rangeStart) {\n        if (rangeValue !== size) {\n          sizeTree = insert(sizeTree, endIndex + 1, rangeValue);\n        }\n      }\n    }\n    if (shouldInsert) {\n      sizeTree = insert(sizeTree, startIndex, size);\n    }\n  }\n  return [sizeTree, syncStart];\n}\nfunction initialSizeState() {\n  return {\n    offsetTree: [],\n    sizeTree: newTree(),\n    groupOffsetTree: newTree(),\n    lastIndex: 0,\n    lastOffset: 0,\n    lastSize: 0,\n    groupIndices: []\n  };\n}\nfunction indexComparator({ index: itemIndex }, index) {\n  return index === itemIndex ? 0 : index < itemIndex ? -1 : 1;\n}\nfunction offsetComparator({ offset: itemOffset }, offset) {\n  return offset === itemOffset ? 0 : offset < itemOffset ? -1 : 1;\n}\nfunction offsetPointParser(point) {\n  return { index: point.index, value: point };\n}\nfunction rangesWithinOffsets(tree, startOffset, endOffset, minStartIndex = 0) {\n  if (minStartIndex > 0) {\n    startOffset = Math.max(startOffset, findClosestSmallerOrEqual(tree, minStartIndex, indexComparator).offset);\n  }\n  return arrayToRanges(findRange(tree, startOffset, endOffset, offsetComparator), offsetPointParser);\n}\nfunction createOffsetTree(prevOffsetTree, syncStart, sizeTree, gap) {\n  let offsetTree = prevOffsetTree;\n  let prevIndex = 0;\n  let prevSize = 0;\n  let prevOffset = 0;\n  let startIndex = 0;\n  if (syncStart !== 0) {\n    startIndex = findIndexOfClosestSmallerOrEqual(offsetTree, syncStart - 1, indexComparator);\n    const offsetInfo = offsetTree[startIndex];\n    prevOffset = offsetInfo.offset;\n    const kv = findMaxKeyValue(sizeTree, syncStart - 1);\n    prevIndex = kv[0];\n    prevSize = kv[1];\n    if (offsetTree.length && offsetTree[startIndex].size === findMaxKeyValue(sizeTree, syncStart)[1]) {\n      startIndex -= 1;\n    }\n    offsetTree = offsetTree.slice(0, startIndex + 1);\n  } else {\n    offsetTree = [];\n  }\n  for (const { start: startIndex2, value } of rangesWithin(sizeTree, syncStart, Infinity)) {\n    const indexOffset = startIndex2 - prevIndex;\n    const aOffset = indexOffset * prevSize + prevOffset + indexOffset * gap;\n    offsetTree.push({\n      offset: aOffset,\n      size: value,\n      index: startIndex2\n    });\n    prevIndex = startIndex2;\n    prevOffset = aOffset;\n    prevSize = value;\n  }\n  return {\n    offsetTree,\n    lastIndex: prevIndex,\n    lastOffset: prevOffset,\n    lastSize: prevSize\n  };\n}\nfunction sizeStateReducer(state, [ranges, groupIndices, log, gap]) {\n  if (ranges.length > 0) {\n    log(\"received item sizes\", ranges, LogLevel.DEBUG);\n  }\n  const sizeTree = state.sizeTree;\n  let newSizeTree = sizeTree;\n  let syncStart = 0;\n  if (groupIndices.length > 0 && empty(sizeTree) && ranges.length === 2) {\n    const groupSize = ranges[0].size;\n    const itemSize = ranges[1].size;\n    newSizeTree = groupIndices.reduce((tree, groupIndex) => {\n      return insert(insert(tree, groupIndex, groupSize), groupIndex + 1, itemSize);\n    }, newSizeTree);\n  } else {\n    [newSizeTree, syncStart] = insertRanges(newSizeTree, ranges);\n  }\n  if (newSizeTree === sizeTree) {\n    return state;\n  }\n  const { offsetTree: newOffsetTree, lastIndex, lastSize, lastOffset } = createOffsetTree(state.offsetTree, syncStart, newSizeTree, gap);\n  return {\n    sizeTree: newSizeTree,\n    offsetTree: newOffsetTree,\n    lastIndex,\n    lastOffset,\n    lastSize,\n    groupOffsetTree: groupIndices.reduce((tree, index) => {\n      return insert(tree, index, offsetOf(index, newOffsetTree, gap));\n    }, newTree()),\n    groupIndices\n  };\n}\nfunction offsetOf(index, tree, gap) {\n  if (tree.length === 0) {\n    return 0;\n  }\n  const { offset, index: startIndex, size } = findClosestSmallerOrEqual(tree, index, indexComparator);\n  const itemCount = index - startIndex;\n  const top = size * itemCount + (itemCount - 1) * gap + offset;\n  return top > 0 ? top + gap : top;\n}\nfunction isGroupLocation(location) {\n  return typeof location.groupIndex !== \"undefined\";\n}\nfunction originalIndexFromLocation(location, sizes, lastIndex) {\n  if (isGroupLocation(location)) {\n    return sizes.groupIndices[location.groupIndex] + 1;\n  } else {\n    const numericIndex = location.index === \"LAST\" ? lastIndex : location.index;\n    let result = originalIndexFromItemIndex(numericIndex, sizes);\n    result = Math.max(0, result, Math.min(lastIndex, result));\n    return result;\n  }\n}\nfunction originalIndexFromItemIndex(itemIndex, sizes) {\n  if (!hasGroups(sizes)) {\n    return itemIndex;\n  }\n  let groupOffset = 0;\n  while (sizes.groupIndices[groupOffset] <= itemIndex + groupOffset) {\n    groupOffset++;\n  }\n  return itemIndex + groupOffset;\n}\nfunction hasGroups(sizes) {\n  return !empty(sizes.groupOffsetTree);\n}\nfunction sizeTreeToRanges(sizeTree) {\n  return walk(sizeTree).map(({ k: startIndex, v: size }, index, sizeArray) => {\n    const nextSize = sizeArray[index + 1];\n    const endIndex = nextSize ? nextSize.k - 1 : Infinity;\n    return { startIndex, endIndex, size };\n  });\n}\nconst SIZE_MAP = {\n  offsetHeight: \"height\",\n  offsetWidth: \"width\"\n};\nconst sizeSystem = system(\n  ([{ log }, { recalcInProgress }]) => {\n    const sizeRanges = stream();\n    const totalCount = stream();\n    const statefulTotalCount = statefulStreamFromEmitter(totalCount, 0);\n    const unshiftWith = stream();\n    const shiftWith = stream();\n    const firstItemIndex = statefulStream(0);\n    const groupIndices = statefulStream([]);\n    const fixedItemSize = statefulStream(void 0);\n    const defaultItemSize = statefulStream(void 0);\n    const itemSize = statefulStream((el, field) => correctItemSize(el, SIZE_MAP[field]));\n    const data = statefulStream(void 0);\n    const gap = statefulStream(0);\n    const initial = initialSizeState();\n    const sizes = statefulStreamFromEmitter(\n      pipe(sizeRanges, withLatestFrom(groupIndices, log, gap), scan(sizeStateReducer, initial), distinctUntilChanged()),\n      initial\n    );\n    const prevGroupIndices = statefulStreamFromEmitter(\n      pipe(\n        groupIndices,\n        distinctUntilChanged(),\n        scan((prev, curr) => ({ prev: prev.current, current: curr }), {\n          prev: [],\n          current: []\n        }),\n        map(({ prev }) => prev)\n      ),\n      []\n    );\n    connect(\n      pipe(\n        groupIndices,\n        filter((indexes) => indexes.length > 0),\n        withLatestFrom(sizes, gap),\n        map(([groupIndices2, sizes2, gap2]) => {\n          const groupOffsetTree = groupIndices2.reduce((tree, index, idx) => {\n            return insert(tree, index, offsetOf(index, sizes2.offsetTree, gap2) || idx);\n          }, newTree());\n          return {\n            ...sizes2,\n            groupIndices: groupIndices2,\n            groupOffsetTree\n          };\n        })\n      ),\n      sizes\n    );\n    connect(\n      pipe(\n        totalCount,\n        withLatestFrom(sizes),\n        filter(([totalCount2, { lastIndex }]) => {\n          return totalCount2 < lastIndex;\n        }),\n        map(([totalCount2, { lastIndex, lastSize }]) => {\n          return [\n            {\n              startIndex: totalCount2,\n              endIndex: lastIndex,\n              size: lastSize\n            }\n          ];\n        })\n      ),\n      sizeRanges\n    );\n    connect(fixedItemSize, defaultItemSize);\n    const trackItemSizes = statefulStreamFromEmitter(\n      pipe(\n        fixedItemSize,\n        map((size) => size === void 0)\n      ),\n      true\n    );\n    connect(\n      pipe(\n        defaultItemSize,\n        filter((value) => {\n          return value !== void 0 && empty(getValue(sizes).sizeTree);\n        }),\n        map((size) => [{ startIndex: 0, endIndex: 0, size }])\n      ),\n      sizeRanges\n    );\n    const listRefresh = streamFromEmitter(\n      pipe(\n        sizeRanges,\n        withLatestFrom(sizes),\n        scan(\n          ({ sizes: oldSizes }, [_, newSizes]) => {\n            return {\n              changed: newSizes !== oldSizes,\n              sizes: newSizes\n            };\n          },\n          { changed: false, sizes: initial }\n        ),\n        map((value) => value.changed)\n      )\n    );\n    subscribe(\n      pipe(\n        firstItemIndex,\n        scan(\n          (prev, next) => {\n            return { diff: prev.prev - next, prev: next };\n          },\n          { diff: 0, prev: 0 }\n        ),\n        map((val) => val.diff)\n      ),\n      (offset) => {\n        const { groupIndices: groupIndices2 } = getValue(sizes);\n        if (offset > 0) {\n          publish(recalcInProgress, true);\n          publish(unshiftWith, offset + affectedGroupCount(offset, groupIndices2));\n        } else if (offset < 0) {\n          const prevGroupIndicesValue = getValue(prevGroupIndices);\n          if (prevGroupIndicesValue.length > 0) {\n            offset -= affectedGroupCount(-offset, prevGroupIndicesValue);\n          }\n          publish(shiftWith, offset);\n        }\n      }\n    );\n    subscribe(pipe(firstItemIndex, withLatestFrom(log)), ([index, log2]) => {\n      if (index < 0) {\n        log2(\n          \"`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value\",\n          { firstItemIndex },\n          LogLevel.ERROR\n        );\n      }\n    });\n    const beforeUnshiftWith = streamFromEmitter(unshiftWith);\n    connect(\n      pipe(\n        unshiftWith,\n        withLatestFrom(sizes),\n        map(([unshiftWith2, sizes2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          const initialRanges = [];\n          const defaultSize = sizes2.lastSize;\n          if (groupedMode) {\n            const firstGroupSize = find(sizes2.sizeTree, 0);\n            let prependedGroupItemsCount = 0;\n            let groupIndex = 0;\n            while (prependedGroupItemsCount < unshiftWith2) {\n              const theGroupIndex = sizes2.groupIndices[groupIndex];\n              const groupItemCount = sizes2.groupIndices.length === groupIndex + 1 ? Infinity : sizes2.groupIndices[groupIndex + 1] - theGroupIndex - 1;\n              initialRanges.push({\n                startIndex: theGroupIndex,\n                endIndex: theGroupIndex,\n                size: firstGroupSize\n              });\n              initialRanges.push({\n                startIndex: theGroupIndex + 1,\n                endIndex: theGroupIndex + 1 + groupItemCount - 1,\n                size: defaultSize\n              });\n              groupIndex++;\n              prependedGroupItemsCount += groupItemCount + 1;\n            }\n            const sizeTreeKV = walk(sizes2.sizeTree);\n            const firstGroupIsExpanded = prependedGroupItemsCount !== unshiftWith2;\n            if (firstGroupIsExpanded) {\n              sizeTreeKV.shift();\n            }\n            return sizeTreeKV.reduce(\n              (acc, { k: index, v: size }) => {\n                let ranges = acc.ranges;\n                if (acc.prevSize !== 0) {\n                  ranges = [\n                    ...acc.ranges,\n                    {\n                      startIndex: acc.prevIndex,\n                      endIndex: index + unshiftWith2 - 1,\n                      size: acc.prevSize\n                    }\n                  ];\n                }\n                return {\n                  ranges,\n                  prevIndex: index + unshiftWith2,\n                  prevSize: size\n                };\n              },\n              {\n                ranges: initialRanges,\n                prevIndex: unshiftWith2,\n                prevSize: 0\n              }\n            ).ranges;\n          }\n          return walk(sizes2.sizeTree).reduce(\n            (acc, { k: index, v: size }) => {\n              return {\n                ranges: [...acc.ranges, { startIndex: acc.prevIndex, endIndex: index + unshiftWith2 - 1, size: acc.prevSize }],\n                prevIndex: index + unshiftWith2,\n                prevSize: size\n              };\n            },\n            {\n              ranges: [],\n              prevIndex: 0,\n              prevSize: defaultSize\n            }\n          ).ranges;\n        })\n      ),\n      sizeRanges\n    );\n    const shiftWithOffset = streamFromEmitter(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, { offsetTree }, gap2]) => {\n          const newFirstItemIndex = -shiftWith2;\n          return offsetOf(newFirstItemIndex, offsetTree, gap2);\n        })\n      )\n    );\n    connect(\n      pipe(\n        shiftWith,\n        withLatestFrom(sizes, gap),\n        map(([shiftWith2, sizes2, gap2]) => {\n          const groupedMode = sizes2.groupIndices.length > 0;\n          if (groupedMode) {\n            if (empty(sizes2.sizeTree)) {\n              return sizes2;\n            }\n            let newSizeTree = newTree();\n            const prevGroupIndicesValue = getValue(prevGroupIndices);\n            let removedItemsCount = 0;\n            let groupIndex = 0;\n            let groupOffset = 0;\n            while (removedItemsCount < -shiftWith2) {\n              groupOffset = prevGroupIndicesValue[groupIndex];\n              const groupItemCount = prevGroupIndicesValue[groupIndex + 1] - groupOffset - 1;\n              groupIndex++;\n              removedItemsCount += groupItemCount + 1;\n            }\n            newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newSizeTree);\n            const aGroupIsShrunk = removedItemsCount !== -shiftWith2;\n            if (aGroupIsShrunk) {\n              const firstGroupSize = find(sizes2.sizeTree, groupOffset);\n              newSizeTree = insert(newSizeTree, 0, firstGroupSize);\n              const nextItemSize = findMaxKeyValue(sizes2.sizeTree, -shiftWith2 + 1)[1];\n              newSizeTree = insert(newSizeTree, 1, nextItemSize);\n            }\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          } else {\n            const newSizeTree = walk(sizes2.sizeTree).reduce((acc, { k, v }) => {\n              return insert(acc, Math.max(0, k + shiftWith2), v);\n            }, newTree());\n            return {\n              ...sizes2,\n              sizeTree: newSizeTree,\n              ...createOffsetTree(sizes2.offsetTree, 0, newSizeTree, gap2)\n            };\n          }\n        })\n      ),\n      sizes\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      sizeRanges,\n      groupIndices,\n      defaultItemSize,\n      fixedItemSize,\n      unshiftWith,\n      shiftWith,\n      shiftWithOffset,\n      beforeUnshiftWith,\n      firstItemIndex,\n      gap,\n      // output\n      sizes,\n      listRefresh,\n      statefulTotalCount,\n      trackItemSizes,\n      itemSize\n    };\n  },\n  tup(loggerSystem, recalcSystem),\n  { singleton: true }\n);\nconst SUPPORTS_SCROLL_TO_OPTIONS = typeof document !== \"undefined\" && \"scrollBehavior\" in document.documentElement.style;\nfunction normalizeIndexLocation(location) {\n  const result = typeof location === \"number\" ? { index: location } : location;\n  if (!result.align) {\n    result.align = \"start\";\n  }\n  if (!result.behavior || !SUPPORTS_SCROLL_TO_OPTIONS) {\n    result.behavior = \"auto\";\n  }\n  if (!result.offset) {\n    result.offset = 0;\n  }\n  return result;\n}\nconst scrollToIndexSystem = system(\n  ([\n    { sizes, totalCount, listRefresh, gap },\n    {\n      scrollingInProgress,\n      viewportHeight,\n      scrollTo,\n      smoothScrollTargetReached,\n      headerHeight,\n      footerHeight,\n      fixedHeaderHeight,\n      fixedFooterHeight\n    },\n    { log }\n  ]) => {\n    const scrollToIndex = stream();\n    const scrollTargetReached = stream();\n    const topListHeight = statefulStream(0);\n    let unsubscribeNextListRefresh = null;\n    let cleartTimeoutRef = null;\n    let unsubscribeListRefresh = null;\n    function cleanup() {\n      if (unsubscribeNextListRefresh) {\n        unsubscribeNextListRefresh();\n        unsubscribeNextListRefresh = null;\n      }\n      if (unsubscribeListRefresh) {\n        unsubscribeListRefresh();\n        unsubscribeListRefresh = null;\n      }\n      if (cleartTimeoutRef) {\n        clearTimeout(cleartTimeoutRef);\n        cleartTimeoutRef = null;\n      }\n      publish(scrollingInProgress, false);\n    }\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(sizes, viewportHeight, totalCount, topListHeight, headerHeight, footerHeight, log),\n        withLatestFrom(gap, fixedHeaderHeight, fixedFooterHeight),\n        map(\n          ([\n            [location, sizes2, viewportHeight2, totalCount2, topListHeight2, headerHeight2, footerHeight2, log2],\n            gap2,\n            fixedHeaderHeight2,\n            fixedFooterHeight2\n          ]) => {\n            const normalLocation = normalizeIndexLocation(location);\n            const { align, behavior, offset } = normalLocation;\n            const lastIndex = totalCount2 - 1;\n            const index = originalIndexFromLocation(normalLocation, sizes2, lastIndex);\n            let top = offsetOf(index, sizes2.offsetTree, gap2) + headerHeight2;\n            if (align === \"end\") {\n              top += fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2;\n              if (index === lastIndex) {\n                top += footerHeight2;\n              }\n            } else if (align === \"center\") {\n              top += (fixedHeaderHeight2 + findMaxKeyValue(sizes2.sizeTree, index)[1] - viewportHeight2 + fixedFooterHeight2) / 2;\n            } else {\n              top -= topListHeight2;\n            }\n            if (offset) {\n              top += offset;\n            }\n            const retry = (listChanged) => {\n              cleanup();\n              if (listChanged) {\n                log2(\"retrying to scroll to\", { location }, LogLevel.DEBUG);\n                publish(scrollToIndex, location);\n              } else {\n                publish(scrollTargetReached, true);\n                log2(\"list did not change, scroll successful\", {}, LogLevel.DEBUG);\n              }\n            };\n            cleanup();\n            if (behavior === \"smooth\") {\n              let listChanged = false;\n              unsubscribeListRefresh = subscribe(listRefresh, (changed) => {\n                listChanged = listChanged || changed;\n              });\n              unsubscribeNextListRefresh = handleNext(smoothScrollTargetReached, () => {\n                retry(listChanged);\n              });\n            } else {\n              unsubscribeNextListRefresh = handleNext(pipe(listRefresh, watchChangesFor(150)), retry);\n            }\n            cleartTimeoutRef = setTimeout(() => {\n              cleanup();\n            }, 1200);\n            publish(scrollingInProgress, true);\n            log2(\"scrolling from index to\", { index, top, behavior }, LogLevel.DEBUG);\n            return { top, behavior };\n          }\n        )\n      ),\n      scrollTo\n    );\n    return {\n      scrollToIndex,\n      scrollTargetReached,\n      topListHeight\n    };\n  },\n  tup(sizeSystem, domIOSystem, loggerSystem),\n  { singleton: true }\n);\nfunction watchChangesFor(limit) {\n  return (done) => {\n    const timeoutRef = setTimeout(() => {\n      done(false);\n    }, limit);\n    return (value) => {\n      if (value) {\n        done(true);\n        clearTimeout(timeoutRef);\n      }\n    };\n  };\n}\nconst UP = \"up\";\nconst DOWN = \"down\";\nconst NONE$1 = \"none\";\nconst INITIAL_BOTTOM_STATE = {\n  atBottom: false,\n  notAtBottomBecause: \"NOT_SHOWING_LAST_ITEM\",\n  state: {\n    offsetBottom: 0,\n    scrollTop: 0,\n    viewportHeight: 0,\n    scrollHeight: 0\n  }\n};\nconst DEFAULT_AT_TOP_THRESHOLD = 0;\nconst stateFlagsSystem = system(([{ scrollContainerState, scrollTop, viewportHeight, headerHeight, footerHeight, scrollBy }]) => {\n  const isAtBottom = statefulStream(false);\n  const isAtTop = statefulStream(true);\n  const atBottomStateChange = stream();\n  const atTopStateChange = stream();\n  const atBottomThreshold = statefulStream(4);\n  const atTopThreshold = statefulStream(DEFAULT_AT_TOP_THRESHOLD);\n  const isScrolling = statefulStreamFromEmitter(\n    pipe(\n      merge(pipe(duc(scrollTop), skip(1), mapTo(true)), pipe(duc(scrollTop), skip(1), mapTo(false), debounceTime(100))),\n      distinctUntilChanged()\n    ),\n    false\n  );\n  const isScrollingBy = statefulStreamFromEmitter(\n    pipe(merge(pipe(scrollBy, mapTo(true)), pipe(scrollBy, mapTo(false), debounceTime(200))), distinctUntilChanged()),\n    false\n  );\n  connect(\n    pipe(\n      combineLatest(duc(scrollTop), duc(atTopThreshold)),\n      map(([top, atTopThreshold2]) => top <= atTopThreshold2),\n      distinctUntilChanged()\n    ),\n    isAtTop\n  );\n  connect(pipe(isAtTop, throttleTime(50)), atTopStateChange);\n  const atBottomState = streamFromEmitter(\n    pipe(\n      combineLatest(scrollContainerState, duc(viewportHeight), duc(headerHeight), duc(footerHeight), duc(atBottomThreshold)),\n      scan((current, [{ scrollTop: scrollTop2, scrollHeight }, viewportHeight2, _headerHeight, _footerHeight, atBottomThreshold2]) => {\n        const isAtBottom2 = scrollTop2 + viewportHeight2 - scrollHeight > -atBottomThreshold2;\n        const state = {\n          viewportHeight: viewportHeight2,\n          scrollTop: scrollTop2,\n          scrollHeight\n        };\n        if (isAtBottom2) {\n          let atBottomBecause;\n          let scrollTopDelta;\n          if (scrollTop2 > current.state.scrollTop) {\n            atBottomBecause = \"SCROLLED_DOWN\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2;\n          } else {\n            atBottomBecause = \"SIZE_DECREASED\";\n            scrollTopDelta = current.state.scrollTop - scrollTop2 || current.scrollTopDelta;\n          }\n          return {\n            atBottom: true,\n            state,\n            atBottomBecause,\n            scrollTopDelta\n          };\n        }\n        let notAtBottomBecause;\n        if (state.scrollHeight > current.state.scrollHeight) {\n          notAtBottomBecause = \"SIZE_INCREASED\";\n        } else if (viewportHeight2 < current.state.viewportHeight) {\n          notAtBottomBecause = \"VIEWPORT_HEIGHT_DECREASING\";\n        } else if (scrollTop2 < current.state.scrollTop) {\n          notAtBottomBecause = \"SCROLLING_UPWARDS\";\n        } else {\n          notAtBottomBecause = \"NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM\";\n        }\n        return {\n          atBottom: false,\n          notAtBottomBecause,\n          state\n        };\n      }, INITIAL_BOTTOM_STATE),\n      distinctUntilChanged((prev, next) => {\n        return prev && prev.atBottom === next.atBottom;\n      })\n    )\n  );\n  const lastJumpDueToItemResize = statefulStreamFromEmitter(\n    pipe(\n      scrollContainerState,\n      scan(\n        (current, { scrollTop: scrollTop2, scrollHeight, viewportHeight: viewportHeight2 }) => {\n          if (!approximatelyEqual(current.scrollHeight, scrollHeight)) {\n            const atBottom = scrollHeight - (scrollTop2 + viewportHeight2) < 1;\n            if (current.scrollTop !== scrollTop2 && atBottom) {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: current.scrollTop - scrollTop2,\n                changed: true\n              };\n            } else {\n              return {\n                scrollHeight,\n                scrollTop: scrollTop2,\n                jump: 0,\n                changed: true\n              };\n            }\n          } else {\n            return {\n              scrollTop: scrollTop2,\n              scrollHeight,\n              jump: 0,\n              changed: false\n            };\n          }\n        },\n        { scrollHeight: 0, jump: 0, scrollTop: 0, changed: false }\n      ),\n      filter((value) => value.changed),\n      map((value) => value.jump)\n    ),\n    0\n  );\n  connect(\n    pipe(\n      atBottomState,\n      map((state) => state.atBottom)\n    ),\n    isAtBottom\n  );\n  connect(pipe(isAtBottom, throttleTime(50)), atBottomStateChange);\n  const scrollDirection = statefulStream(DOWN);\n  connect(\n    pipe(\n      scrollContainerState,\n      map(({ scrollTop: scrollTop2 }) => scrollTop2),\n      distinctUntilChanged(),\n      scan(\n        (acc, scrollTop2) => {\n          if (getValue(isScrollingBy)) {\n            return { direction: acc.direction, prevScrollTop: scrollTop2 };\n          }\n          return { direction: scrollTop2 < acc.prevScrollTop ? UP : DOWN, prevScrollTop: scrollTop2 };\n        },\n        { direction: DOWN, prevScrollTop: 0 }\n      ),\n      map((value) => value.direction)\n    ),\n    scrollDirection\n  );\n  connect(pipe(scrollContainerState, throttleTime(50), mapTo(NONE$1)), scrollDirection);\n  const scrollVelocity = statefulStream(0);\n  connect(\n    pipe(\n      isScrolling,\n      filter((value) => !value),\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      mapTo(0)\n    ),\n    scrollVelocity\n  );\n  connect(\n    pipe(\n      scrollTop,\n      throttleTime(100),\n      withLatestFrom(isScrolling),\n      filter(([_, isScrolling2]) => !!isScrolling2),\n      scan(([_, prev], [next]) => [prev, next], [0, 0]),\n      map(([prev, next]) => next - prev)\n    ),\n    scrollVelocity\n  );\n  return {\n    isScrolling,\n    isAtTop,\n    isAtBottom,\n    atBottomState,\n    atTopStateChange,\n    atBottomStateChange,\n    scrollDirection,\n    atBottomThreshold,\n    atTopThreshold,\n    scrollVelocity,\n    lastJumpDueToItemResize\n  };\n}, tup(domIOSystem));\nconst propsReadySystem = system(\n  ([{ log }]) => {\n    const propsReady = statefulStream(false);\n    const didMount = streamFromEmitter(\n      pipe(\n        propsReady,\n        filter((ready) => ready),\n        distinctUntilChanged()\n      )\n    );\n    subscribe(propsReady, (value) => {\n      value && getValue(log)(\"props updated\", {}, LogLevel.DEBUG);\n    });\n    return { propsReady, didMount };\n  },\n  tup(loggerSystem),\n  { singleton: true }\n);\nfunction skipFrames(frameCount, callback) {\n  if (frameCount == 0) {\n    callback();\n  } else {\n    requestAnimationFrame(() => skipFrames(frameCount - 1, callback));\n  }\n}\nfunction getInitialTopMostItemIndexNumber(location, totalCount) {\n  const lastIndex = totalCount - 1;\n  const index = typeof location === \"number\" ? location : location.index === \"LAST\" ? lastIndex : location.index;\n  return index;\n}\nconst initialTopMostItemIndexSystem = system(\n  ([{ sizes, listRefresh, defaultItemSize }, { scrollTop }, { scrollToIndex, scrollTargetReached }, { didMount }]) => {\n    const scrolledToInitialItem = statefulStream(true);\n    const initialTopMostItemIndex = statefulStream(0);\n    const initialItemFinalLocationReached = statefulStream(true);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location),\n        mapTo(false)\n      ),\n      scrolledToInitialItem\n    );\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location),\n        mapTo(false)\n      ),\n      initialItemFinalLocationReached\n    );\n    subscribe(\n      pipe(\n        combineLatest(listRefresh, didMount),\n        withLatestFrom(scrolledToInitialItem, sizes, defaultItemSize, initialItemFinalLocationReached),\n        filter(([[, didMount2], scrolledToInitialItem2, { sizeTree }, defaultItemSize2, scrollScheduled]) => {\n          return didMount2 && (!empty(sizeTree) || isDefined(defaultItemSize2)) && !scrolledToInitialItem2 && !scrollScheduled;\n        }),\n        withLatestFrom(initialTopMostItemIndex)\n      ),\n      ([, initialTopMostItemIndex2]) => {\n        handleNext(scrollTargetReached, () => {\n          publish(initialItemFinalLocationReached, true);\n        });\n        skipFrames(4, () => {\n          handleNext(scrollTop, () => {\n            publish(scrolledToInitialItem, true);\n          });\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n      }\n    );\n    return {\n      scrolledToInitialItem,\n      initialTopMostItemIndex,\n      initialItemFinalLocationReached\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, propsReadySystem),\n  { singleton: true }\n);\nfunction normalizeFollowOutput(follow) {\n  if (!follow) {\n    return false;\n  }\n  return follow === \"smooth\" ? \"smooth\" : \"auto\";\n}\nconst behaviorFromFollowOutput = (follow, isAtBottom) => {\n  if (typeof follow === \"function\") {\n    return normalizeFollowOutput(follow(isAtBottom));\n  }\n  return isAtBottom && normalizeFollowOutput(follow);\n};\nconst followOutputSystem = system(\n  ([\n    { totalCount, listRefresh },\n    { isAtBottom, atBottomState },\n    { scrollToIndex },\n    { scrolledToInitialItem },\n    { propsReady, didMount },\n    { log },\n    { scrollingInProgress }\n  ]) => {\n    const followOutput = statefulStream(false);\n    const autoscrollToBottom = stream();\n    let pendingScrollHandle = null;\n    function scrollToBottom(followOutputBehavior) {\n      publish(scrollToIndex, {\n        index: \"LAST\",\n        align: \"end\",\n        behavior: followOutputBehavior\n      });\n    }\n    subscribe(\n      pipe(\n        combineLatest(pipe(duc(totalCount), skip(1)), didMount),\n        withLatestFrom(duc(followOutput), isAtBottom, scrolledToInitialItem, scrollingInProgress),\n        map(([[totalCount2, didMount2], followOutput2, isAtBottom2, scrolledToInitialItem2, scrollingInProgress2]) => {\n          let shouldFollow = didMount2 && scrolledToInitialItem2;\n          let followOutputBehavior = \"auto\";\n          if (shouldFollow) {\n            followOutputBehavior = behaviorFromFollowOutput(followOutput2, isAtBottom2 || scrollingInProgress2);\n            shouldFollow = shouldFollow && !!followOutputBehavior;\n          }\n          return { totalCount: totalCount2, shouldFollow, followOutputBehavior };\n        }),\n        filter(({ shouldFollow }) => shouldFollow)\n      ),\n      ({ totalCount: totalCount2, followOutputBehavior }) => {\n        if (pendingScrollHandle) {\n          pendingScrollHandle();\n          pendingScrollHandle = null;\n        }\n        pendingScrollHandle = handleNext(listRefresh, () => {\n          getValue(log)(\"following output to \", { totalCount: totalCount2 }, LogLevel.DEBUG);\n          scrollToBottom(followOutputBehavior);\n          pendingScrollHandle = null;\n        });\n      }\n    );\n    function trapNextSizeIncrease(followOutput2) {\n      const cancel = handleNext(atBottomState, (state) => {\n        if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"SIZE_INCREASED\" && !pendingScrollHandle) {\n          getValue(log)(\"scrolling to bottom due to increased size\", {}, LogLevel.DEBUG);\n          scrollToBottom(\"auto\");\n        }\n      });\n      setTimeout(cancel, 100);\n    }\n    subscribe(\n      pipe(\n        combineLatest(duc(followOutput), totalCount, propsReady),\n        filter(([follow, , ready]) => follow && ready),\n        scan(\n          ({ value }, [, next]) => {\n            return { refreshed: value === next, value: next };\n          },\n          { refreshed: false, value: 0 }\n        ),\n        filter(({ refreshed }) => refreshed),\n        withLatestFrom(followOutput, totalCount)\n      ),\n      ([, followOutput2]) => {\n        if (getValue(scrolledToInitialItem)) {\n          trapNextSizeIncrease(followOutput2 !== false);\n        }\n      }\n    );\n    subscribe(autoscrollToBottom, () => {\n      trapNextSizeIncrease(getValue(followOutput) !== false);\n    });\n    subscribe(combineLatest(duc(followOutput), atBottomState), ([followOutput2, state]) => {\n      if (followOutput2 && !state.atBottom && state.notAtBottomBecause === \"VIEWPORT_HEIGHT_DECREASING\") {\n        scrollToBottom(\"auto\");\n      }\n    });\n    return { followOutput, autoscrollToBottom };\n  },\n  tup(sizeSystem, stateFlagsSystem, scrollToIndexSystem, initialTopMostItemIndexSystem, propsReadySystem, loggerSystem, domIOSystem)\n);\nfunction groupCountsToIndicesAndCount(counts) {\n  return counts.reduce(\n    (acc, groupCount) => {\n      acc.groupIndices.push(acc.totalCount);\n      acc.totalCount += groupCount + 1;\n      return acc;\n    },\n    {\n      totalCount: 0,\n      groupIndices: []\n    }\n  );\n}\nconst groupedListSystem = system(([{ totalCount, groupIndices, sizes }, { scrollTop, headerHeight }]) => {\n  const groupCounts = stream();\n  const topItemsIndexes = stream();\n  const groupIndicesAndCount = streamFromEmitter(pipe(groupCounts, map(groupCountsToIndicesAndCount)));\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.totalCount)\n    ),\n    totalCount\n  );\n  connect(\n    pipe(\n      groupIndicesAndCount,\n      map((value) => value.groupIndices)\n    ),\n    groupIndices\n  );\n  connect(\n    pipe(\n      combineLatest(scrollTop, sizes, headerHeight),\n      filter(([_, sizes2]) => hasGroups(sizes2)),\n      map(([scrollTop2, state, headerHeight2]) => findMaxKeyValue(state.groupOffsetTree, Math.max(scrollTop2 - headerHeight2, 0), \"v\")[0]),\n      distinctUntilChanged(),\n      map((index) => [index])\n    ),\n    topItemsIndexes\n  );\n  return { groupCounts, topItemsIndexes };\n}, tup(sizeSystem, domIOSystem));\nfunction tupleComparator(prev, current) {\n  return !!(prev && prev[0] === current[0] && prev[1] === current[1]);\n}\nfunction rangeComparator(prev, next) {\n  return !!(prev && prev.startIndex === next.startIndex && prev.endIndex === next.endIndex);\n}\nconst TOP = \"top\";\nconst BOTTOM = \"bottom\";\nconst NONE = \"none\";\nfunction getOverscan(overscan, end, direction) {\n  if (typeof overscan === \"number\") {\n    return direction === UP && end === TOP || direction === DOWN && end === BOTTOM ? overscan : 0;\n  } else {\n    if (direction === UP) {\n      return end === TOP ? overscan.main : overscan.reverse;\n    } else {\n      return end === BOTTOM ? overscan.main : overscan.reverse;\n    }\n  }\n}\nfunction getViewportIncrease(value, end) {\n  return typeof value === \"number\" ? value : value[end] || 0;\n}\nconst sizeRangeSystem = system(\n  ([{ scrollTop, viewportHeight, deviation, headerHeight, fixedHeaderHeight }]) => {\n    const listBoundary = stream();\n    const topListHeight = statefulStream(0);\n    const increaseViewportBy = statefulStream(0);\n    const overscan = statefulStream(0);\n    const visibleRange = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          duc(scrollTop),\n          duc(viewportHeight),\n          duc(headerHeight),\n          duc(listBoundary, tupleComparator),\n          duc(overscan),\n          duc(topListHeight),\n          duc(fixedHeaderHeight),\n          duc(deviation),\n          duc(increaseViewportBy)\n        ),\n        map(\n          ([\n            scrollTop2,\n            viewportHeight2,\n            headerHeight2,\n            [listTop, listBottom],\n            overscan2,\n            topListHeight2,\n            fixedHeaderHeight2,\n            deviation2,\n            increaseViewportBy2\n          ]) => {\n            const top = scrollTop2 - deviation2;\n            const stickyHeaderHeight = topListHeight2 + fixedHeaderHeight2;\n            const headerVisible = Math.max(headerHeight2 - top, 0);\n            let direction = NONE;\n            const topViewportAddition = getViewportIncrease(increaseViewportBy2, TOP);\n            const bottomViewportAddition = getViewportIncrease(increaseViewportBy2, BOTTOM);\n            listTop -= deviation2;\n            listTop += headerHeight2 + fixedHeaderHeight2;\n            listBottom += headerHeight2 + fixedHeaderHeight2;\n            listBottom -= deviation2;\n            if (listTop > scrollTop2 + stickyHeaderHeight - topViewportAddition) {\n              direction = UP;\n            }\n            if (listBottom < scrollTop2 - headerVisible + viewportHeight2 + bottomViewportAddition) {\n              direction = DOWN;\n            }\n            if (direction !== NONE) {\n              return [\n                Math.max(top - headerHeight2 - getOverscan(overscan2, TOP, direction) - topViewportAddition, 0),\n                top - headerVisible - fixedHeaderHeight2 + viewportHeight2 + getOverscan(overscan2, BOTTOM, direction) + bottomViewportAddition\n              ];\n            }\n            return null;\n          }\n        ),\n        filter((value) => value != null),\n        distinctUntilChanged(tupleComparator)\n      ),\n      [0, 0]\n    );\n    return {\n      // input\n      listBoundary,\n      overscan,\n      topListHeight,\n      increaseViewportBy,\n      // output\n      visibleRange\n    };\n  },\n  tup(domIOSystem),\n  { singleton: true }\n);\nfunction probeItemSet(index, sizes, data) {\n  if (hasGroups(sizes)) {\n    const itemIndex = originalIndexFromItemIndex(index, sizes);\n    const groupIndex = findMaxKeyValue(sizes.groupOffsetTree, itemIndex)[0];\n    return [\n      { index: groupIndex, size: 0, offset: 0 },\n      { index: itemIndex, size: 0, offset: 0, data: data && data[0] }\n    ];\n  }\n  return [{ index, size: 0, offset: 0, data: data && data[0] }];\n}\nconst EMPTY_LIST_STATE = {\n  items: [],\n  topItems: [],\n  offsetTop: 0,\n  offsetBottom: 0,\n  top: 0,\n  bottom: 0,\n  topListHeight: 0,\n  totalCount: 0,\n  firstItemIndex: 0\n};\nfunction transposeItems(items, sizes, firstItemIndex) {\n  if (items.length === 0) {\n    return [];\n  }\n  if (!hasGroups(sizes)) {\n    return items.map((item) => ({ ...item, index: item.index + firstItemIndex, originalIndex: item.index }));\n  }\n  const startIndex = items[0].index;\n  const endIndex = items[items.length - 1].index;\n  const transposedItems = [];\n  const groupRanges = rangesWithin(sizes.groupOffsetTree, startIndex, endIndex);\n  let currentRange = void 0;\n  let currentGroupIndex = 0;\n  for (const item of items) {\n    if (!currentRange || currentRange.end < item.index) {\n      currentRange = groupRanges.shift();\n      currentGroupIndex = sizes.groupIndices.indexOf(currentRange.start);\n    }\n    let transposedItem;\n    if (item.index === currentRange.start) {\n      transposedItem = {\n        type: \"group\",\n        index: currentGroupIndex\n      };\n    } else {\n      transposedItem = {\n        index: item.index - (currentGroupIndex + 1) + firstItemIndex,\n        groupIndex: currentGroupIndex\n      };\n    }\n    transposedItems.push({\n      ...transposedItem,\n      size: item.size,\n      offset: item.offset,\n      originalIndex: item.index,\n      data: item.data\n    });\n  }\n  return transposedItems;\n}\nfunction buildListState(items, topItems, totalCount, gap, sizes, firstItemIndex) {\n  const { lastSize, lastOffset, lastIndex } = sizes;\n  let offsetTop = 0;\n  let bottom = 0;\n  if (items.length > 0) {\n    offsetTop = items[0].offset;\n    const lastItem = items[items.length - 1];\n    bottom = lastItem.offset + lastItem.size;\n  }\n  const itemCount = totalCount - lastIndex;\n  const total = lastOffset + itemCount * lastSize + (itemCount - 1) * gap;\n  const top = offsetTop;\n  const offsetBottom = total - bottom;\n  return {\n    items: transposeItems(items, sizes, firstItemIndex),\n    topItems: transposeItems(topItems, sizes, firstItemIndex),\n    topListHeight: topItems.reduce((height, item) => item.size + height, 0),\n    offsetTop,\n    offsetBottom,\n    top,\n    bottom,\n    totalCount,\n    firstItemIndex\n  };\n}\nfunction buildListStateFromItemCount(itemCount, initialTopMostItemIndex, sizes, firstItemIndex, gap, data) {\n  let includedGroupsCount = 0;\n  if (sizes.groupIndices.length > 0) {\n    for (const index of sizes.groupIndices) {\n      if (index - includedGroupsCount >= itemCount) {\n        break;\n      }\n      includedGroupsCount++;\n    }\n  }\n  const adjustedCount = itemCount + includedGroupsCount;\n  const initialTopMostItemIndexNumber = getInitialTopMostItemIndexNumber(initialTopMostItemIndex, adjustedCount);\n  const items = Array.from({ length: adjustedCount }).map((_, index) => ({\n    index: index + initialTopMostItemIndexNumber,\n    size: 0,\n    offset: 0,\n    data: data[index + initialTopMostItemIndexNumber]\n  }));\n  return buildListState(items, [], adjustedCount, gap, sizes, firstItemIndex);\n}\nconst listStateSystem = system(\n  ([\n    { sizes, totalCount, data, firstItemIndex, gap },\n    groupedListSystem2,\n    { visibleRange, listBoundary, topListHeight: rangeTopListHeight },\n    { scrolledToInitialItem, initialTopMostItemIndex },\n    { topListHeight },\n    stateFlags,\n    { didMount },\n    { recalcInProgress }\n  ]) => {\n    const topItemsIndexes = statefulStream([]);\n    const initialItemCount = statefulStream(0);\n    const itemsRendered = stream();\n    connect(groupedListSystem2.topItemsIndexes, topItemsIndexes);\n    const listState = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(\n          didMount,\n          recalcInProgress,\n          duc(visibleRange, tupleComparator),\n          duc(totalCount),\n          duc(sizes),\n          duc(initialTopMostItemIndex),\n          scrolledToInitialItem,\n          duc(topItemsIndexes),\n          duc(firstItemIndex),\n          duc(gap),\n          data\n        ),\n        filter(([mount, recalcInProgress2, , totalCount2, , , , , , , data2]) => {\n          const dataChangeInProgress = data2 && data2.length !== totalCount2;\n          return mount && !recalcInProgress2 && !dataChangeInProgress;\n        }),\n        map(\n          ([\n            ,\n            ,\n            [startOffset, endOffset],\n            totalCount2,\n            sizes2,\n            initialTopMostItemIndex2,\n            scrolledToInitialItem2,\n            topItemsIndexes2,\n            firstItemIndex2,\n            gap2,\n            data2\n          ]) => {\n            const sizesValue = sizes2;\n            const { sizeTree, offsetTree } = sizesValue;\n            const initialItemCountValue = getValue(initialItemCount);\n            if (totalCount2 === 0) {\n              return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };\n            }\n            if (startOffset === 0 && endOffset === 0) {\n              if (initialItemCountValue === 0) {\n                return { ...EMPTY_LIST_STATE, totalCount: totalCount2 };\n              } else {\n                return buildListStateFromItemCount(initialItemCountValue, initialTopMostItemIndex2, sizes2, firstItemIndex2, gap2, data2 || []);\n              }\n            }\n            if (empty(sizeTree)) {\n              if (initialItemCountValue > 0) {\n                return null;\n              }\n              const state = buildListState(\n                probeItemSet(getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2), sizesValue, data2),\n                [],\n                totalCount2,\n                gap2,\n                sizesValue,\n                firstItemIndex2\n              );\n              return state;\n            }\n            const topItems = [];\n            if (topItemsIndexes2.length > 0) {\n              const startIndex = topItemsIndexes2[0];\n              const endIndex = topItemsIndexes2[topItemsIndexes2.length - 1];\n              let offset = 0;\n              for (const range of rangesWithin(sizeTree, startIndex, endIndex)) {\n                const size = range.value;\n                const rangeStartIndex = Math.max(range.start, startIndex);\n                const rangeEndIndex = Math.min(range.end, endIndex);\n                for (let i = rangeStartIndex; i <= rangeEndIndex; i++) {\n                  topItems.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size;\n                }\n              }\n            }\n            if (!scrolledToInitialItem2) {\n              return buildListState([], topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n            }\n            const minStartIndex = topItemsIndexes2.length > 0 ? topItemsIndexes2[topItemsIndexes2.length - 1] + 1 : 0;\n            const offsetPointRanges = rangesWithinOffsets(offsetTree, startOffset, endOffset, minStartIndex);\n            if (offsetPointRanges.length === 0) {\n              return null;\n            }\n            const maxIndex = totalCount2 - 1;\n            const items = tap([], (result) => {\n              for (const range of offsetPointRanges) {\n                const point = range.value;\n                let offset = point.offset;\n                let rangeStartIndex = range.start;\n                const size = point.size;\n                if (point.offset < startOffset) {\n                  rangeStartIndex += Math.floor((startOffset - point.offset + gap2) / (size + gap2));\n                  const itemCount = rangeStartIndex - range.start;\n                  offset += itemCount * size + itemCount * gap2;\n                }\n                if (rangeStartIndex < minStartIndex) {\n                  offset += (minStartIndex - rangeStartIndex) * size;\n                  rangeStartIndex = minStartIndex;\n                }\n                const endIndex = Math.min(range.end, maxIndex);\n                for (let i = rangeStartIndex; i <= endIndex; i++) {\n                  if (offset >= endOffset) {\n                    break;\n                  }\n                  result.push({ index: i, size, offset, data: data2 && data2[i] });\n                  offset += size + gap2;\n                }\n              }\n            });\n            return buildListState(items, topItems, totalCount2, gap2, sizesValue, firstItemIndex2);\n          }\n        ),\n        //@ts-expect-error filter needs to be fixed\n        filter((value) => value !== null),\n        distinctUntilChanged()\n      ),\n      EMPTY_LIST_STATE\n    );\n    connect(\n      pipe(\n        data,\n        filter(isDefined),\n        map((data2) => data2 == null ? void 0 : data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        listState,\n        map((value) => value.topListHeight)\n      ),\n      topListHeight\n    );\n    connect(topListHeight, rangeTopListHeight);\n    connect(\n      pipe(\n        listState,\n        map((state) => [state.top, state.bottom])\n      ),\n      listBoundary\n    );\n    connect(\n      pipe(\n        listState,\n        map((state) => state.items)\n      ),\n      itemsRendered\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, data),\n        filter(([{ items }, totalCount2]) => items[items.length - 1].originalIndex === totalCount2 - 1),\n        map(([, totalCount2, data2]) => [totalCount2 - 1, data2]),\n        distinctUntilChanged(tupleComparator),\n        map(([count]) => count)\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        listState,\n        throttleTime(200),\n        filter(({ items, topItems }) => {\n          return items.length > 0 && items[0].originalIndex === topItems.length;\n        }),\n        map(({ items }) => items[0].index),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        listState,\n        filter(({ items }) => items.length > 0),\n        map(({ items }) => {\n          let startIndex = 0;\n          let endIndex = items.length - 1;\n          while (items[startIndex].type === \"group\" && startIndex < endIndex) {\n            startIndex++;\n          }\n          while (items[endIndex].type === \"group\" && endIndex > startIndex) {\n            endIndex--;\n          }\n          return {\n            startIndex: items[startIndex].index,\n            endIndex: items[endIndex].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator)\n      )\n    );\n    return { listState, topItemsIndexes, endReached, startReached, rangeChanged, itemsRendered, initialItemCount, ...stateFlags };\n  },\n  tup(\n    sizeSystem,\n    groupedListSystem,\n    sizeRangeSystem,\n    initialTopMostItemIndexSystem,\n    scrollToIndexSystem,\n    stateFlagsSystem,\n    propsReadySystem,\n    recalcSystem\n  ),\n  { singleton: true }\n);\nconst initialItemCountSystem = system(\n  ([{ sizes, firstItemIndex, data, gap }, { initialTopMostItemIndex }, { initialItemCount, listState }, { didMount }]) => {\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(initialItemCount),\n        filter(([, count]) => count !== 0),\n        withLatestFrom(initialTopMostItemIndex, sizes, firstItemIndex, gap, data),\n        map(([[, count], initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2 = []]) => {\n          return buildListStateFromItemCount(count, initialTopMostItemIndexValue, sizes2, firstItemIndex2, gap2, data2);\n        })\n      ),\n      listState\n    );\n    return {};\n  },\n  tup(sizeSystem, initialTopMostItemIndexSystem, listStateSystem, propsReadySystem),\n  { singleton: true }\n);\nconst scrollSeekSystem = system(\n  ([{ scrollVelocity }]) => {\n    const isSeeking = statefulStream(false);\n    const rangeChanged = stream();\n    const scrollSeekConfiguration = statefulStream(false);\n    connect(\n      pipe(\n        scrollVelocity,\n        withLatestFrom(scrollSeekConfiguration, isSeeking, rangeChanged),\n        filter(([_, config]) => !!config),\n        map(([speed, config, isSeeking2, range]) => {\n          const { exit, enter } = config;\n          if (isSeeking2) {\n            if (exit(speed, range)) {\n              return false;\n            }\n          } else {\n            if (enter(speed, range)) {\n              return true;\n            }\n          }\n          return isSeeking2;\n        }),\n        distinctUntilChanged()\n      ),\n      isSeeking\n    );\n    subscribe(\n      pipe(combineLatest(isSeeking, scrollVelocity, rangeChanged), withLatestFrom(scrollSeekConfiguration)),\n      ([[isSeeking2, velocity, range], config]) => isSeeking2 && config && config.change && config.change(velocity, range)\n    );\n    return { isSeeking, scrollSeekConfiguration, scrollVelocity, scrollSeekRangeChanged: rangeChanged };\n  },\n  tup(stateFlagsSystem),\n  { singleton: true }\n);\nconst topItemCountSystem = system(([{ topItemsIndexes }]) => {\n  const topItemCount = statefulStream(0);\n  connect(\n    pipe(\n      topItemCount,\n      filter((length) => length >= 0),\n      map((length) => Array.from({ length }).map((_, index) => index))\n    ),\n    topItemsIndexes\n  );\n  return { topItemCount };\n}, tup(listStateSystem));\nconst totalListHeightSystem = system(\n  ([{ footerHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight }, { listState }]) => {\n    const totalListHeightChanged = stream();\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(footerHeight, fixedFooterHeight, headerHeight, fixedHeaderHeight, listState),\n        map(([footerHeight2, fixedFooterHeight2, headerHeight2, fixedHeaderHeight2, listState2]) => {\n          return footerHeight2 + fixedFooterHeight2 + headerHeight2 + fixedHeaderHeight2 + listState2.offsetBottom + listState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(duc(totalListHeight), totalListHeightChanged);\n    return { totalListHeight, totalListHeightChanged };\n  },\n  tup(domIOSystem, listStateSystem),\n  { singleton: true }\n);\nfunction simpleMemoize(func) {\n  let called = false;\n  let result;\n  return () => {\n    if (!called) {\n      called = true;\n      result = func();\n    }\n    return result;\n  };\n}\nconst isMobileSafari = simpleMemoize(() => {\n  return /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent);\n});\nconst upwardScrollFixSystem = system(\n  ([\n    { scrollBy, scrollTop, deviation, scrollingInProgress },\n    { isScrolling, isAtBottom, scrollDirection, lastJumpDueToItemResize },\n    { listState },\n    { beforeUnshiftWith, shiftWithOffset, sizes, gap },\n    { log },\n    { recalcInProgress }\n  ]) => {\n    const deviationOffset = streamFromEmitter(\n      pipe(\n        listState,\n        withLatestFrom(lastJumpDueToItemResize),\n        scan(\n          ([, prevItems, prevTotalCount, prevTotalHeight], [{ items, totalCount, bottom, offsetBottom }, lastJumpDueToItemResize2]) => {\n            const totalHeight = bottom + offsetBottom;\n            let newDev = 0;\n            if (prevTotalCount === totalCount) {\n              if (prevItems.length > 0 && items.length > 0) {\n                const atStart = items[0].originalIndex === 0 && prevItems[0].originalIndex === 0;\n                if (!atStart) {\n                  newDev = totalHeight - prevTotalHeight;\n                  if (newDev !== 0) {\n                    newDev += lastJumpDueToItemResize2;\n                  }\n                }\n              }\n            }\n            return [newDev, items, totalCount, totalHeight];\n          },\n          [0, [], 0, 0]\n        ),\n        filter(([amount]) => amount !== 0),\n        withLatestFrom(scrollTop, scrollDirection, scrollingInProgress, isAtBottom, log, recalcInProgress),\n        filter(([, scrollTop2, scrollDirection2, scrollingInProgress2, , , recalcInProgress2]) => {\n          return !recalcInProgress2 && !scrollingInProgress2 && scrollTop2 !== 0 && scrollDirection2 === UP;\n        }),\n        map(([[amount], , , , , log2]) => {\n          log2(\"Upward scrolling compensation\", { amount }, LogLevel.DEBUG);\n          return amount;\n        })\n      )\n    );\n    function scrollByWith(offset) {\n      if (offset > 0) {\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n        publish(deviation, 0);\n      } else {\n        publish(deviation, 0);\n        publish(scrollBy, { top: -offset, behavior: \"auto\" });\n      }\n    }\n    subscribe(pipe(deviationOffset, withLatestFrom(deviation, isScrolling)), ([offset, deviationAmount, isScrolling2]) => {\n      if (isScrolling2 && isMobileSafari()) {\n        publish(deviation, deviationAmount - offset);\n      } else {\n        scrollByWith(-offset);\n      }\n    });\n    subscribe(\n      pipe(\n        combineLatest(statefulStreamFromEmitter(isScrolling, false), deviation, recalcInProgress),\n        filter(([is, deviation2, recalc]) => !is && !recalc && deviation2 !== 0),\n        map(([_, deviation2]) => deviation2),\n        throttleTime(1)\n      ),\n      scrollByWith\n    );\n    connect(\n      pipe(\n        shiftWithOffset,\n        map((offset) => {\n          return { top: -offset };\n        })\n      ),\n      scrollBy\n    );\n    subscribe(\n      pipe(\n        beforeUnshiftWith,\n        withLatestFrom(sizes, gap),\n        map(([offset, { lastSize: defaultItemSize, groupIndices, sizeTree }, gap2]) => {\n          function getItemOffset(itemCount) {\n            return itemCount * (defaultItemSize + gap2);\n          }\n          if (groupIndices.length === 0) {\n            return getItemOffset(offset);\n          } else {\n            let amount = 0;\n            const defaultGroupSize = find(sizeTree, 0);\n            let recognizedOffsetItems = 0;\n            let groupIndex = 0;\n            while (recognizedOffsetItems < offset) {\n              recognizedOffsetItems++;\n              amount += defaultGroupSize;\n              let groupItemCount = groupIndices.length === groupIndex + 1 ? Infinity : groupIndices[groupIndex + 1] - groupIndices[groupIndex] - 1;\n              if (recognizedOffsetItems + groupItemCount > offset) {\n                amount -= defaultGroupSize;\n                groupItemCount = offset - recognizedOffsetItems + 1;\n              }\n              recognizedOffsetItems += groupItemCount;\n              amount += getItemOffset(groupItemCount);\n              groupIndex++;\n            }\n            return amount;\n          }\n        })\n      ),\n      (offset) => {\n        publish(deviation, offset);\n        requestAnimationFrame(() => {\n          publish(scrollBy, { top: offset });\n          requestAnimationFrame(() => {\n            publish(deviation, 0);\n            publish(recalcInProgress, false);\n          });\n        });\n      }\n    );\n    return { deviation };\n  },\n  tup(domIOSystem, stateFlagsSystem, listStateSystem, sizeSystem, loggerSystem, recalcSystem)\n);\nconst initialScrollTopSystem = system(\n  ([{ didMount }, { scrollTo }, { listState }]) => {\n    const initialScrollTop = statefulStream(0);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialScrollTop),\n        filter(([, offset]) => offset !== 0),\n        map(([, offset]) => ({ top: offset }))\n      ),\n      (location) => {\n        handleNext(\n          pipe(\n            listState,\n            skip(1),\n            filter((state) => state.items.length > 1)\n          ),\n          () => {\n            requestAnimationFrame(() => {\n              publish(scrollTo, location);\n            });\n          }\n        );\n      }\n    );\n    return {\n      initialScrollTop\n    };\n  },\n  tup(propsReadySystem, domIOSystem, listStateSystem),\n  { singleton: true }\n);\nconst alignToBottomSystem = system(\n  ([{ viewportHeight }, { totalListHeight }]) => {\n    const alignToBottom = statefulStream(false);\n    const paddingTopAddition = statefulStreamFromEmitter(\n      pipe(\n        combineLatest(alignToBottom, viewportHeight, totalListHeight),\n        filter(([enabled]) => enabled),\n        map(([, viewportHeight2, totalListHeight2]) => {\n          return Math.max(0, viewportHeight2 - totalListHeight2);\n        }),\n        throttleTime(0),\n        distinctUntilChanged()\n      ),\n      0\n    );\n    return { alignToBottom, paddingTopAddition };\n  },\n  tup(domIOSystem, totalListHeightSystem),\n  { singleton: true }\n);\nconst windowScrollerSystem = system(([{ scrollTo, scrollContainerState }]) => {\n  const windowScrollContainerState = stream();\n  const windowViewportRect = stream();\n  const windowScrollTo = stream();\n  const useWindowScroll = statefulStream(false);\n  const customScrollParent = statefulStream(void 0);\n  connect(\n    pipe(\n      combineLatest(windowScrollContainerState, windowViewportRect),\n      map(([{ viewportHeight, scrollTop: windowScrollTop, scrollHeight }, { offsetTop }]) => {\n        return {\n          scrollTop: Math.max(0, windowScrollTop - offsetTop),\n          scrollHeight,\n          viewportHeight\n        };\n      })\n    ),\n    scrollContainerState\n  );\n  connect(\n    pipe(\n      scrollTo,\n      withLatestFrom(windowViewportRect),\n      map(([scrollTo2, { offsetTop }]) => {\n        return {\n          ...scrollTo2,\n          top: scrollTo2.top + offsetTop\n        };\n      })\n    ),\n    windowScrollTo\n  );\n  return {\n    // config\n    useWindowScroll,\n    customScrollParent,\n    // input\n    windowScrollContainerState,\n    windowViewportRect,\n    // signals\n    windowScrollTo\n  };\n}, tup(domIOSystem));\nconst defaultCalculateViewLocation = ({\n  itemTop: itemTop2,\n  itemBottom,\n  viewportTop,\n  viewportBottom,\n  locationParams: { behavior, align, ...rest }\n}) => {\n  if (itemTop2 < viewportTop) {\n    return { ...rest, behavior, align: align != null ? align : \"start\" };\n  }\n  if (itemBottom > viewportBottom) {\n    return { ...rest, behavior, align: align != null ? align : \"end\" };\n  }\n  return null;\n};\nconst scrollIntoViewSystem = system(\n  ([\n    { sizes, totalCount, gap },\n    { scrollTop, viewportHeight, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollingInProgress },\n    { scrollToIndex }\n  ]) => {\n    const scrollIntoView = stream();\n    connect(\n      pipe(\n        scrollIntoView,\n        withLatestFrom(sizes, viewportHeight, totalCount, headerHeight, fixedHeaderHeight, fixedFooterHeight, scrollTop),\n        withLatestFrom(gap),\n        map(([[viewLocation, sizes2, viewportHeight2, totalCount2, headerHeight2, fixedHeaderHeight2, fixedFooterHeight2, scrollTop2], gap2]) => {\n          const { done, behavior, align, calculateViewLocation = defaultCalculateViewLocation, ...rest } = viewLocation;\n          const actualIndex = originalIndexFromLocation(viewLocation, sizes2, totalCount2 - 1);\n          const itemTop2 = offsetOf(actualIndex, sizes2.offsetTree, gap2) + headerHeight2 + fixedHeaderHeight2;\n          const itemBottom = itemTop2 + findMaxKeyValue(sizes2.sizeTree, actualIndex)[1];\n          const viewportTop = scrollTop2 + fixedHeaderHeight2;\n          const viewportBottom = scrollTop2 + viewportHeight2 - fixedFooterHeight2;\n          const location = calculateViewLocation({\n            itemTop: itemTop2,\n            itemBottom,\n            viewportTop,\n            viewportBottom,\n            locationParams: { behavior, align, ...rest }\n          });\n          if (location) {\n            done && handleNext(\n              pipe(\n                scrollingInProgress,\n                filter((value) => value === false),\n                // skips the initial publish of false, and the cleanup call.\n                // but if scrollingInProgress is true, we skip the initial publish.\n                skip(getValue(scrollingInProgress) ? 1 : 2)\n              ),\n              done\n            );\n          } else {\n            done && done();\n          }\n          return location;\n        }),\n        filter((value) => value !== null)\n      ),\n      scrollToIndex\n    );\n    return {\n      scrollIntoView\n    };\n  },\n  tup(sizeSystem, domIOSystem, scrollToIndexSystem, listStateSystem, loggerSystem),\n  { singleton: true }\n);\nconst stateLoadSystem = system(\n  ([\n    { sizes, sizeRanges },\n    { scrollTop, headerHeight },\n    { initialTopMostItemIndex },\n    { didMount },\n    { useWindowScroll, windowScrollContainerState, windowViewportRect }\n  ]) => {\n    const getState = stream();\n    const restoreStateFrom = statefulStream(void 0);\n    const statefulWindowScrollContainerState = statefulStream(null);\n    const statefulWindowViewportRect = statefulStream(null);\n    connect(windowScrollContainerState, statefulWindowScrollContainerState);\n    connect(windowViewportRect, statefulWindowViewportRect);\n    subscribe(\n      pipe(\n        getState,\n        withLatestFrom(sizes, scrollTop, useWindowScroll, statefulWindowScrollContainerState, statefulWindowViewportRect, headerHeight)\n      ),\n      ([callback, sizes2, scrollTop2, useWindowScroll2, windowScrollContainerState2, windowViewportRect2, headerHeight2]) => {\n        const ranges = sizeTreeToRanges(sizes2.sizeTree);\n        if (useWindowScroll2 && windowScrollContainerState2 !== null && windowViewportRect2 !== null) {\n          scrollTop2 = windowScrollContainerState2.scrollTop - windowViewportRect2.offsetTop;\n        }\n        scrollTop2 -= headerHeight2;\n        callback({ ranges, scrollTop: scrollTop2 });\n      }\n    );\n    connect(pipe(restoreStateFrom, filter(isDefined), map(locationFromSnapshot)), initialTopMostItemIndex);\n    connect(\n      pipe(\n        didMount,\n        withLatestFrom(restoreStateFrom),\n        filter(([, state]) => state !== void 0),\n        distinctUntilChanged(),\n        map(([, snapshot]) => {\n          return snapshot.ranges;\n        })\n      ),\n      sizeRanges\n    );\n    return {\n      getState,\n      restoreStateFrom\n    };\n  },\n  tup(sizeSystem, domIOSystem, initialTopMostItemIndexSystem, propsReadySystem, windowScrollerSystem)\n);\nfunction locationFromSnapshot(snapshot) {\n  return { offset: snapshot.scrollTop, index: 0, align: \"start\" };\n}\nconst featureGroup1System = system(\n  ([\n    sizeRange,\n    initialItemCount,\n    propsReady,\n    scrollSeek,\n    totalListHeight,\n    initialScrollTopSystem2,\n    alignToBottom,\n    windowScroller,\n    scrollIntoView,\n    logger\n  ]) => {\n    return {\n      ...sizeRange,\n      ...initialItemCount,\n      ...propsReady,\n      ...scrollSeek,\n      ...totalListHeight,\n      ...initialScrollTopSystem2,\n      ...alignToBottom,\n      ...windowScroller,\n      ...scrollIntoView,\n      ...logger\n    };\n  },\n  tup(\n    sizeRangeSystem,\n    initialItemCountSystem,\n    propsReadySystem,\n    scrollSeekSystem,\n    totalListHeightSystem,\n    initialScrollTopSystem,\n    alignToBottomSystem,\n    windowScrollerSystem,\n    scrollIntoViewSystem,\n    loggerSystem\n  )\n);\nconst listSystem = system(\n  ([\n    {\n      totalCount,\n      sizeRanges,\n      fixedItemSize,\n      defaultItemSize,\n      trackItemSizes,\n      itemSize,\n      data,\n      firstItemIndex,\n      groupIndices,\n      statefulTotalCount,\n      gap,\n      sizes\n    },\n    { initialTopMostItemIndex, scrolledToInitialItem, initialItemFinalLocationReached },\n    domIO,\n    stateLoad,\n    followOutput,\n    { listState, topItemsIndexes, ...flags },\n    { scrollToIndex },\n    _,\n    { topItemCount },\n    { groupCounts },\n    featureGroup1\n  ]) => {\n    connect(flags.rangeChanged, featureGroup1.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        featureGroup1.windowViewportRect,\n        map((value) => value.visibleHeight)\n      ),\n      domIO.viewportHeight\n    );\n    return {\n      // input\n      totalCount,\n      data,\n      firstItemIndex,\n      sizeRanges,\n      initialTopMostItemIndex,\n      scrolledToInitialItem,\n      initialItemFinalLocationReached,\n      topItemsIndexes,\n      topItemCount,\n      groupCounts,\n      fixedItemHeight: fixedItemSize,\n      defaultItemHeight: defaultItemSize,\n      gap,\n      ...followOutput,\n      // output\n      statefulTotalCount,\n      listState,\n      scrollToIndex,\n      trackItemSizes,\n      itemSize,\n      groupIndices,\n      // exported from stateFlagsSystem\n      ...flags,\n      // the bag of IO from featureGroup1System\n      ...featureGroup1,\n      ...domIO,\n      sizes,\n      ...stateLoad\n    };\n  },\n  tup(\n    sizeSystem,\n    initialTopMostItemIndexSystem,\n    domIOSystem,\n    stateLoadSystem,\n    followOutputSystem,\n    listStateSystem,\n    scrollToIndexSystem,\n    upwardScrollFixSystem,\n    topItemCountSystem,\n    groupedListSystem,\n    featureGroup1System\n  )\n);\nconst WEBKIT_STICKY = \"-webkit-sticky\";\nconst STICKY = \"sticky\";\nconst positionStickyCssValue = simpleMemoize(() => {\n  if (typeof document === \"undefined\") {\n    return STICKY;\n  }\n  const node = document.createElement(\"div\");\n  node.style.position = WEBKIT_STICKY;\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY;\n});\nfunction useWindowViewportRectRef(callback, customScrollParent, skipAnimationFrame) {\n  const viewportInfo = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const calculateInfo = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(\n    (element) => {\n      if (element === null || !element.offsetParent) {\n        return;\n      }\n      const rect = element.getBoundingClientRect();\n      const visibleWidth = rect.width;\n      let visibleHeight, offsetTop;\n      if (customScrollParent) {\n        const customScrollParentRect = customScrollParent.getBoundingClientRect();\n        const deltaTop = rect.top - customScrollParentRect.top;\n        visibleHeight = customScrollParentRect.height - Math.max(0, deltaTop);\n        offsetTop = deltaTop + customScrollParent.scrollTop;\n      } else {\n        visibleHeight = window.innerHeight - Math.max(0, rect.top);\n        offsetTop = rect.top + window.pageYOffset;\n      }\n      viewportInfo.current = {\n        offsetTop,\n        visibleHeight,\n        visibleWidth\n      };\n      callback(viewportInfo.current);\n    },\n    [callback, customScrollParent]\n  );\n  const { callbackRef, ref } = useSizeWithElRef(calculateInfo, true, skipAnimationFrame);\n  const scrollAndResizeEventHandler = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(() => {\n    calculateInfo(ref.current);\n  }, [calculateInfo, ref]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (customScrollParent) {\n      customScrollParent.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      const observer = new ResizeObserver(() => {\n        requestAnimationFrame(scrollAndResizeEventHandler);\n      });\n      observer.observe(customScrollParent);\n      return () => {\n        customScrollParent.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        observer.unobserve(customScrollParent);\n      };\n    } else {\n      window.addEventListener(\"scroll\", scrollAndResizeEventHandler);\n      window.addEventListener(\"resize\", scrollAndResizeEventHandler);\n      return () => {\n        window.removeEventListener(\"scroll\", scrollAndResizeEventHandler);\n        window.removeEventListener(\"resize\", scrollAndResizeEventHandler);\n      };\n    }\n  }, [scrollAndResizeEventHandler, customScrollParent]);\n  return callbackRef;\n}\nconst VirtuosoMockContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nconst VirtuosoGridMockContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext(void 0);\nfunction identity(value) {\n  return value;\n}\nconst listComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const context = statefulStream(null);\n  const groupContent = statefulStream((index) => `Group ${index}`);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const HeaderFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    groupContent,\n    components,\n    computeItemKey,\n    HeaderFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    TopItemListComponent: distinctProp(\"TopItemList\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    GroupComponent: distinctProp(\"Group\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\")\n  };\n});\nconst combinedSystem$2 = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, listComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder$1 = ({ height }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: { height } });\nconst GROUP_STYLE = { position: positionStickyCssValue(), zIndex: 1, overflowAnchor: \"none\" };\nconst ITEM_STYLE$1 = { overflowAnchor: \"none\" };\nconst HORIZONTAL_ITEM_STYLE = { ...ITEM_STYLE$1, display: \"inline-block\", height: \"100%\" };\nconst Items$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoItems({ showTopList = false }) {\n  const listState = useEmitterValue$2(\"listState\");\n  const sizeRanges = usePublisher$2(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher$2(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher$2(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const itemContent = useEmitterValue$2(\"itemContent\");\n  const context = useEmitterValue$2(\"context\");\n  const groupContent = useEmitterValue$2(\"groupContent\");\n  const trackItemSizes = useEmitterValue$2(\"trackItemSizes\");\n  const itemSize = useEmitterValue$2(\"itemSize\");\n  const log = useEmitterValue$2(\"log\");\n  const listGap = usePublisher$2(\"gap\");\n  const horizontalDirection = useEmitterValue$2(\"horizontalDirection\");\n  const { callbackRef } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    showTopList ? noop : scrollContainerStateCallback,\n    log,\n    listGap,\n    customScrollParent,\n    horizontalDirection,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const [deviation, setDeviation] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n  useEmitter$2(\"deviation\", (value) => {\n    if (deviation !== value) {\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue$2(\"EmptyPlaceholder\");\n  const ScrollSeekPlaceholder = useEmitterValue$2(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder$1;\n  const ListComponent = useEmitterValue$2(\"ListComponent\");\n  const ItemComponent = useEmitterValue$2(\"ItemComponent\");\n  const GroupComponent = useEmitterValue$2(\"GroupComponent\");\n  const computeItemKey = useEmitterValue$2(\"computeItemKey\");\n  const isSeeking = useEmitterValue$2(\"isSeeking\");\n  const hasGroups2 = useEmitterValue$2(\"groupIndices\").length > 0;\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  const initialItemFinalLocationReached = useEmitterValue$2(\"initialItemFinalLocationReached\");\n  const containerStyle = showTopList ? {} : {\n    boxSizing: \"border-box\",\n    ...horizontalDirection ? {\n      whiteSpace: \"nowrap\",\n      display: \"inline-block\",\n      height: \"100%\",\n      paddingLeft: listState.offsetTop,\n      paddingRight: listState.offsetBottom,\n      marginLeft: deviation !== 0 ? deviation : alignToBottom ? \"auto\" : 0\n    } : {\n      marginTop: deviation !== 0 ? deviation : alignToBottom ? \"auto\" : 0,\n      paddingTop: listState.offsetTop,\n      paddingBottom: listState.offsetBottom\n    },\n    ...initialItemFinalLocationReached ? {} : { visibility: \"hidden\" }\n  };\n  if (!showTopList && listState.totalCount === 0 && EmptyPlaceholder) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EmptyPlaceholder, { ...contextPropIfNotDomElement(EmptyPlaceholder, context) });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    ListComponent,\n    {\n      ...contextPropIfNotDomElement(ListComponent, context),\n      ref: callbackRef,\n      style: containerStyle,\n      \"data-testid\": showTopList ? \"virtuoso-top-item-list\" : \"virtuoso-item-list\",\n      children: (showTopList ? listState.topItems : listState.items).map((item) => {\n        const index = item.originalIndex;\n        const key = computeItemKey(index + listState.firstItemIndex, item.data, context);\n        if (isSeeking) {\n          return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n            ScrollSeekPlaceholder,\n            {\n              ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n              key,\n              index: item.index,\n              height: item.size,\n              type: item.type || \"item\",\n              ...item.type === \"group\" ? {} : { groupIndex: item.groupIndex }\n            }\n          );\n        }\n        if (item.type === \"group\") {\n          return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n            GroupComponent,\n            {\n              ...contextPropIfNotDomElement(GroupComponent, context),\n              key,\n              \"data-index\": index,\n              \"data-known-size\": item.size,\n              \"data-item-index\": item.index,\n              style: GROUP_STYLE\n            },\n            groupContent(item.index, context)\n          );\n        } else {\n          return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n            ItemComponent,\n            {\n              ...contextPropIfNotDomElement(ItemComponent, context),\n              ...itemPropIfNotDomElement(ItemComponent, item.data),\n              key,\n              \"data-index\": index,\n              \"data-known-size\": item.size,\n              \"data-item-index\": item.index,\n              \"data-item-group-index\": item.groupIndex,\n              style: horizontalDirection ? HORIZONTAL_ITEM_STYLE : ITEM_STYLE$1\n            },\n            hasGroups2 ? itemContent(item.index, item.groupIndex, item.data, context) : itemContent(item.index, item.data, context)\n          );\n        }\n      })\n    }\n  );\n});\nconst scrollerStyle = {\n  height: \"100%\",\n  outline: \"none\",\n  overflowY: \"auto\",\n  position: \"relative\",\n  WebkitOverflowScrolling: \"touch\"\n};\nconst horizontalScrollerStyle = {\n  outline: \"none\",\n  overflowX: \"auto\",\n  position: \"relative\"\n};\nconst viewportStyle = (alignToBottom) => ({\n  width: \"100%\",\n  height: \"100%\",\n  position: \"absolute\",\n  top: 0,\n  ...alignToBottom ? { display: \"flex\", flexDirection: \"column\" } : {}\n});\nconst topItemListStyle = {\n  width: \"100%\",\n  position: positionStickyCssValue(),\n  top: 0,\n  zIndex: 1\n};\nfunction contextPropIfNotDomElement(element, context) {\n  if (typeof element === \"string\") {\n    return void 0;\n  }\n  return { context };\n}\nfunction itemPropIfNotDomElement(element, item) {\n  return { item: typeof element === \"string\" ? void 0 : item };\n}\nconst Header$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoHeader() {\n  const Header2 = useEmitterValue$2(\"HeaderComponent\");\n  const headerHeight = usePublisher$2(\"headerHeight\");\n  const HeaderFooterTag = useEmitterValue$2(\"HeaderFooterTag\");\n  const ref = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (el) => headerHeight(correctItemSize(el, \"height\")), [headerHeight]),\n    true,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const context = useEmitterValue$2(\"context\");\n  return Header2 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HeaderFooterTag, { ref, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Header2, { ...contextPropIfNotDomElement(Header2, context) }) }) : null;\n});\nconst Footer$1 = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoFooter() {\n  const Footer2 = useEmitterValue$2(\"FooterComponent\");\n  const footerHeight = usePublisher$2(\"footerHeight\");\n  const HeaderFooterTag = useEmitterValue$2(\"HeaderFooterTag\");\n  const ref = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (el) => footerHeight(correctItemSize(el, \"height\")), [footerHeight]),\n    true,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const context = useEmitterValue$2(\"context\");\n  return Footer2 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HeaderFooterTag, { ref, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Footer2, { ...contextPropIfNotDomElement(Footer2, context) }) }) : null;\n});\nfunction buildScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"scrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const scrollerRefCallback = useEmitterValue2(\"scrollerRef\");\n    const context = useEmitterValue2(\"context\");\n    const horizontalDirection = useEmitterValue2(\"horizontalDirection\") || false;\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      scrollerRefCallback,\n      void 0,\n      horizontalDirection\n    );\n    useEmitter2(\"scrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    const defaultStyle = horizontalDirection ? horizontalScrollerStyle : scrollerStyle;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      ScrollerComponent,\n      {\n        ref: scrollerRef,\n        style: { ...defaultStyle, ...style },\n        \"data-testid\": \"virtuoso-scroller\",\n        \"data-virtuoso-scroller\": true,\n        tabIndex: 0,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context),\n        children\n      }\n    );\n  });\n  return Scroller2;\n}\nfunction buildWindowScroller({ usePublisher: usePublisher2, useEmitter: useEmitter2, useEmitterValue: useEmitterValue2 }) {\n  const Scroller2 = react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoWindowScroller({ style, children, ...props }) {\n    const scrollContainerStateCallback = usePublisher2(\"windowScrollContainerState\");\n    const ScrollerComponent = useEmitterValue2(\"ScrollerComponent\");\n    const smoothScrollTargetReached = usePublisher2(\"smoothScrollTargetReached\");\n    const totalListHeight = useEmitterValue2(\"totalListHeight\");\n    const deviation = useEmitterValue2(\"deviation\");\n    const customScrollParent = useEmitterValue2(\"customScrollParent\");\n    const context = useEmitterValue2(\"context\");\n    const { scrollerRef, scrollByCallback, scrollToCallback } = useScrollTop(\n      scrollContainerStateCallback,\n      smoothScrollTargetReached,\n      ScrollerComponent,\n      noop,\n      customScrollParent\n    );\n    useIsomorphicLayoutEffect(() => {\n      scrollerRef.current = customScrollParent ? customScrollParent : window;\n      return () => {\n        scrollerRef.current = null;\n      };\n    }, [scrollerRef, customScrollParent]);\n    useEmitter2(\"windowScrollTo\", scrollToCallback);\n    useEmitter2(\"scrollBy\", scrollByCallback);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n      ScrollerComponent,\n      {\n        style: { position: \"relative\", ...style, ...totalListHeight !== 0 ? { height: totalListHeight + deviation } : {} },\n        \"data-virtuoso-scroller\": true,\n        ...props,\n        ...contextPropIfNotDomElement(ScrollerComponent, context),\n        children\n      }\n    );\n  });\n  return Scroller2;\n}\nconst Viewport$2 = ({ children }) => {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher$2(\"viewportHeight\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  const horizontalDirection = useEmitterValue$2(\"horizontalDirection\");\n  const viewportSizeCallbackMemo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n    () => compose(viewportHeight, (el) => correctItemSize(el, horizontalDirection ? \"width\" : \"height\")),\n    [viewportHeight, horizontalDirection]\n  );\n  const viewportRef = useSize(viewportSizeCallbackMemo, true, useEmitterValue$2(\"skipAnimationFrameInResizeObserver\"));\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: viewportStyle(alignToBottom), ref: viewportRef, \"data-viewport-type\": \"element\", children });\n};\nconst WindowViewport$2 = ({ children }) => {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher$2(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher$2(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(\n    windowViewportRect,\n    customScrollParent,\n    useEmitterValue$2(\"skipAnimationFrameInResizeObserver\")\n  );\n  const alignToBottom = useEmitterValue$2(\"alignToBottom\");\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: viewportRef, style: viewportStyle(alignToBottom), \"data-viewport-type\": \"window\", children });\n};\nconst TopItemListContainer = ({ children }) => {\n  const TopItemList = useEmitterValue$2(\"TopItemListComponent\") || \"div\";\n  const headerHeight = useEmitterValue$2(\"headerHeight\");\n  const style = { ...topItemListStyle, marginTop: `${headerHeight}px` };\n  const context = useEmitterValue$2(\"context\");\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TopItemList, { style, ...contextPropIfNotDomElement(TopItemList, context), children });\n};\nconst ListRoot = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue$2(\"useWindowScroll\");\n  const showTopList = useEmitterValue$2(\"topItemsIndexes\").length > 0;\n  const customScrollParent = useEmitterValue$2(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$2 : Scroller$2;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$2 : Viewport$2;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TheScroller, { ...props, children: [\n    showTopList && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TopItemListContainer, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Items$1, { showTopList: true }) }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TheViewport, { children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Header$1, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Items$1, {}),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Footer$1, {})\n    ] })\n  ] });\n});\nconst {\n  Component: List,\n  usePublisher: usePublisher$2,\n  useEmitterValue: useEmitterValue$2,\n  useEmitter: useEmitter$2\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$2,\n  {\n    required: {},\n    optional: {\n      restoreStateFrom: \"restoreStateFrom\",\n      context: \"context\",\n      followOutput: \"followOutput\",\n      itemContent: \"itemContent\",\n      groupContent: \"groupContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      groupCounts: \"groupCounts\",\n      topItemCount: \"topItemCount\",\n      firstItemIndex: \"firstItemIndex\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"HeaderFooterTag\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\",\n      horizontalDirection: \"horizontalDirection\",\n      skipAnimationFrameInResizeObserver: \"skipAnimationFrameInResizeObserver\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      autoscrollToBottom: \"autoscrollToBottom\",\n      getState: \"getState\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  ListRoot\n);\nconst Scroller$2 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst WindowScroller$2 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$2, useEmitterValue: useEmitterValue$2, useEmitter: useEmitter$2 });\nconst Virtuoso = List;\nconst GroupedVirtuoso = List;\nconst INITIAL_GRID_STATE = {\n  items: [],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst PROBE_GRID_STATE = {\n  items: [{ index: 0 }],\n  offsetBottom: 0,\n  offsetTop: 0,\n  top: 0,\n  bottom: 0,\n  itemHeight: 0,\n  itemWidth: 0\n};\nconst { round, ceil, floor, min, max } = Math;\nfunction buildProbeGridState(items) {\n  return {\n    ...PROBE_GRID_STATE,\n    items\n  };\n}\nfunction buildItems(startIndex, endIndex, data) {\n  return Array.from({ length: endIndex - startIndex + 1 }).map((_, i) => {\n    const dataItem = data === null ? null : data[i + startIndex];\n    return { index: i + startIndex, data: dataItem };\n  });\n}\nfunction gapComparator(prev, next) {\n  return prev && prev.column === next.column && prev.row === next.row;\n}\nfunction dimensionComparator(prev, next) {\n  return prev && prev.width === next.width && prev.height === next.height;\n}\nconst gridSystem = /* @__PURE__ */ system(\n  ([\n    { overscan, visibleRange, listBoundary, increaseViewportBy },\n    { scrollTop, viewportHeight, scrollBy, scrollTo, smoothScrollTargetReached, scrollContainerState, footerHeight, headerHeight },\n    stateFlags,\n    scrollSeek,\n    { propsReady, didMount },\n    { windowViewportRect, useWindowScroll, customScrollParent, windowScrollContainerState, windowScrollTo },\n    log\n  ]) => {\n    const totalCount = statefulStream(0);\n    const initialItemCount = statefulStream(0);\n    const gridState = statefulStream(INITIAL_GRID_STATE);\n    const viewportDimensions = statefulStream({ height: 0, width: 0 });\n    const itemDimensions = statefulStream({ height: 0, width: 0 });\n    const scrollToIndex = stream();\n    const scrollHeight = stream();\n    const deviation = statefulStream(0);\n    const data = statefulStream(null);\n    const gap = statefulStream({ row: 0, column: 0 });\n    const stateChanged = stream();\n    const restoreStateFrom = stream();\n    const stateRestoreInProgress = statefulStream(false);\n    const initialTopMostItemIndex = statefulStream(0);\n    const scrolledToInitialItem = statefulStream(true);\n    const scrollScheduled = statefulStream(false);\n    const horizontalDirection = statefulStream(false);\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(initialTopMostItemIndex),\n        filter(([_, location]) => !!location)\n      ),\n      () => {\n        publish(scrolledToInitialItem, false);\n      }\n    );\n    subscribe(\n      pipe(\n        combineLatest(didMount, scrolledToInitialItem, itemDimensions, viewportDimensions, initialTopMostItemIndex, scrollScheduled),\n        filter(([didMount2, scrolledToInitialItem2, itemDimensions2, viewportDimensions2, , scrollScheduled2]) => {\n          return didMount2 && !scrolledToInitialItem2 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0 && !scrollScheduled2;\n        })\n      ),\n      ([, , , , initialTopMostItemIndex2]) => {\n        publish(scrollScheduled, true);\n        skipFrames(1, () => {\n          publish(scrollToIndex, initialTopMostItemIndex2);\n        });\n        handleNext(pipe(scrollTop), () => {\n          publish(listBoundary, [0, 0]);\n          publish(scrolledToInitialItem, true);\n        });\n      }\n    );\n    connect(\n      pipe(\n        restoreStateFrom,\n        filter((value) => value !== void 0 && value !== null && value.scrollTop > 0),\n        mapTo(0)\n      ),\n      initialItemCount\n    );\n    subscribe(\n      pipe(\n        didMount,\n        withLatestFrom(restoreStateFrom),\n        filter(([, snapshot]) => snapshot !== void 0 && snapshot !== null)\n      ),\n      ([, snapshot]) => {\n        if (!snapshot) {\n          return;\n        }\n        publish(viewportDimensions, snapshot.viewport), publish(itemDimensions, snapshot == null ? void 0 : snapshot.item);\n        publish(gap, snapshot.gap);\n        if (snapshot.scrollTop > 0) {\n          publish(stateRestoreInProgress, true);\n          handleNext(pipe(scrollTop, skip(1)), (_value) => {\n            publish(stateRestoreInProgress, false);\n          });\n          publish(scrollTo, { top: snapshot.scrollTop });\n        }\n      }\n    );\n    connect(\n      pipe(\n        viewportDimensions,\n        map(({ height }) => height)\n      ),\n      viewportHeight\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(viewportDimensions, dimensionComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(gap, (prev, next) => prev && prev.column === next.column && prev.row === next.row),\n          duc(scrollTop)\n        ),\n        map(([viewport, item, gap2, scrollTop2]) => ({\n          viewport,\n          item,\n          gap: gap2,\n          scrollTop: scrollTop2\n        }))\n      ),\n      stateChanged\n    );\n    connect(\n      pipe(\n        combineLatest(\n          duc(totalCount),\n          visibleRange,\n          duc(gap, gapComparator),\n          duc(itemDimensions, dimensionComparator),\n          duc(viewportDimensions, dimensionComparator),\n          duc(data),\n          duc(initialItemCount),\n          duc(stateRestoreInProgress),\n          duc(scrolledToInitialItem),\n          duc(initialTopMostItemIndex)\n        ),\n        filter(([, , , , , , , stateRestoreInProgress2]) => {\n          return !stateRestoreInProgress2;\n        }),\n        map(\n          ([\n            totalCount2,\n            [startOffset, endOffset],\n            gap2,\n            item,\n            viewport,\n            data2,\n            initialItemCount2,\n            ,\n            scrolledToInitialItem2,\n            initialTopMostItemIndex2\n          ]) => {\n            const { row: rowGap, column: columnGap } = gap2;\n            const { height: itemHeight, width: itemWidth } = item;\n            const { width: viewportWidth } = viewport;\n            if (initialItemCount2 === 0 && (totalCount2 === 0 || viewportWidth === 0)) {\n              return INITIAL_GRID_STATE;\n            }\n            if (itemWidth === 0) {\n              const startIndex2 = getInitialTopMostItemIndexNumber(initialTopMostItemIndex2, totalCount2);\n              const endIndex2 = startIndex2 + Math.max(initialItemCount2 - 1, 0);\n              return buildProbeGridState(buildItems(startIndex2, endIndex2, data2));\n            }\n            const perRow = itemsPerRow(viewportWidth, itemWidth, columnGap);\n            let startIndex;\n            let endIndex;\n            if (!scrolledToInitialItem2) {\n              startIndex = 0;\n              endIndex = -1;\n            } else if (startOffset === 0 && endOffset === 0 && initialItemCount2 > 0) {\n              startIndex = 0;\n              endIndex = initialItemCount2 - 1;\n            } else {\n              startIndex = perRow * floor((startOffset + rowGap) / (itemHeight + rowGap));\n              endIndex = perRow * ceil((endOffset + rowGap) / (itemHeight + rowGap)) - 1;\n              endIndex = min(totalCount2 - 1, max(endIndex, perRow - 1));\n              startIndex = min(endIndex, max(0, startIndex));\n            }\n            const items = buildItems(startIndex, endIndex, data2);\n            const { top, bottom } = gridLayout(viewport, gap2, item, items);\n            const rowCount = ceil(totalCount2 / perRow);\n            const totalHeight = rowCount * itemHeight + (rowCount - 1) * rowGap;\n            const offsetBottom = totalHeight - bottom;\n            return { items, offsetTop: top, offsetBottom, top, bottom, itemHeight, itemWidth };\n          }\n        )\n      ),\n      gridState\n    );\n    connect(\n      pipe(\n        data,\n        filter((data2) => data2 !== null),\n        map((data2) => data2.length)\n      ),\n      totalCount\n    );\n    connect(\n      pipe(\n        combineLatest(viewportDimensions, itemDimensions, gridState, gap),\n        filter(([viewportDimensions2, itemDimensions2, { items }]) => {\n          return items.length > 0 && itemDimensions2.height !== 0 && viewportDimensions2.height !== 0;\n        }),\n        map(([viewportDimensions2, itemDimensions2, { items }, gap2]) => {\n          const { top, bottom } = gridLayout(viewportDimensions2, gap2, itemDimensions2, items);\n          return [top, bottom];\n        }),\n        distinctUntilChanged(tupleComparator)\n      ),\n      listBoundary\n    );\n    const hasScrolled = statefulStream(false);\n    connect(\n      pipe(\n        scrollTop,\n        withLatestFrom(hasScrolled),\n        map(([scrollTop2, hasScrolled2]) => {\n          return hasScrolled2 || scrollTop2 !== 0;\n        })\n      ),\n      hasScrolled\n    );\n    const endReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => items.length > 0),\n        withLatestFrom(totalCount, hasScrolled),\n        filter(([{ items }, totalCount2, hasScrolled2]) => hasScrolled2 && items[items.length - 1].index === totalCount2 - 1),\n        map(([, totalCount2]) => totalCount2 - 1),\n        distinctUntilChanged()\n      )\n    );\n    const startReached = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        filter(({ items }) => {\n          return items.length > 0 && items[0].index === 0;\n        }),\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        mapTo(0),\n        distinctUntilChanged()\n      )\n    );\n    const rangeChanged = streamFromEmitter(\n      pipe(\n        duc(gridState),\n        withLatestFrom(stateRestoreInProgress),\n        filter(([{ items }, stateRestoreInProgress2]) => items.length > 0 && !stateRestoreInProgress2),\n        map(([{ items }]) => {\n          return {\n            startIndex: items[0].index,\n            endIndex: items[items.length - 1].index\n          };\n        }),\n        distinctUntilChanged(rangeComparator),\n        throttleTime(0)\n      )\n    );\n    connect(rangeChanged, scrollSeek.scrollSeekRangeChanged);\n    connect(\n      pipe(\n        scrollToIndex,\n        withLatestFrom(viewportDimensions, itemDimensions, totalCount, gap),\n        map(([location, viewportDimensions2, itemDimensions2, totalCount2, gap2]) => {\n          const normalLocation = normalizeIndexLocation(location);\n          const { align, behavior, offset } = normalLocation;\n          let index = normalLocation.index;\n          if (index === \"LAST\") {\n            index = totalCount2 - 1;\n          }\n          index = max(0, index, min(totalCount2 - 1, index));\n          let top = itemTop(viewportDimensions2, gap2, itemDimensions2, index);\n          if (align === \"end\") {\n            top = round(top - viewportDimensions2.height + itemDimensions2.height);\n          } else if (align === \"center\") {\n            top = round(top - viewportDimensions2.height / 2 + itemDimensions2.height / 2);\n          }\n          if (offset) {\n            top += offset;\n          }\n          return { top, behavior };\n        })\n      ),\n      scrollTo\n    );\n    const totalListHeight = statefulStreamFromEmitter(\n      pipe(\n        gridState,\n        map((gridState2) => {\n          return gridState2.offsetBottom + gridState2.bottom;\n        })\n      ),\n      0\n    );\n    connect(\n      pipe(\n        windowViewportRect,\n        map((viewportInfo) => ({ width: viewportInfo.visibleWidth, height: viewportInfo.visibleHeight }))\n      ),\n      viewportDimensions\n    );\n    return {\n      // input\n      data,\n      totalCount,\n      viewportDimensions,\n      itemDimensions,\n      scrollTop,\n      scrollHeight,\n      overscan,\n      increaseViewportBy,\n      scrollBy,\n      scrollTo,\n      scrollToIndex,\n      smoothScrollTargetReached,\n      windowViewportRect,\n      windowScrollTo,\n      useWindowScroll,\n      customScrollParent,\n      windowScrollContainerState,\n      deviation,\n      scrollContainerState,\n      footerHeight,\n      headerHeight,\n      initialItemCount,\n      gap,\n      restoreStateFrom,\n      ...scrollSeek,\n      initialTopMostItemIndex,\n      horizontalDirection,\n      // output\n      gridState,\n      totalListHeight,\n      ...stateFlags,\n      startReached,\n      endReached,\n      rangeChanged,\n      stateChanged,\n      propsReady,\n      stateRestoreInProgress,\n      ...log\n    };\n  },\n  tup(sizeRangeSystem, domIOSystem, stateFlagsSystem, scrollSeekSystem, propsReadySystem, windowScrollerSystem, loggerSystem)\n);\nfunction gridLayout(viewport, gap, item, items) {\n  const { height: itemHeight } = item;\n  if (itemHeight === void 0 || items.length === 0) {\n    return { top: 0, bottom: 0 };\n  }\n  const top = itemTop(viewport, gap, item, items[0].index);\n  const bottom = itemTop(viewport, gap, item, items[items.length - 1].index) + itemHeight;\n  return { top, bottom };\n}\nfunction itemTop(viewport, gap, item, index) {\n  const perRow = itemsPerRow(viewport.width, item.width, gap.column);\n  const rowCount = floor(index / perRow);\n  const top = rowCount * item.height + max(0, rowCount - 1) * gap.row;\n  return top > 0 ? top + gap.row : top;\n}\nfunction itemsPerRow(viewportWidth, itemWidth, gap) {\n  return max(1, floor((viewportWidth + gap) / (floor(itemWidth) + gap)));\n}\nconst gridComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => `Item ${index}`);\n  const components = statefulStream({});\n  const context = statefulStream(null);\n  const itemClassName = statefulStream(\"virtuoso-grid-item\");\n  const listClassName = statefulStream(\"virtuoso-grid-list\");\n  const computeItemKey = statefulStream(identity);\n  const headerFooterTag = statefulStream(\"div\");\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  const readyStateChanged = statefulStream(false);\n  const reportReadyState = statefulStream(false);\n  connect(duc(reportReadyState), readyStateChanged);\n  return {\n    readyStateChanged,\n    reportReadyState,\n    context,\n    itemContent,\n    components,\n    computeItemKey,\n    itemClassName,\n    listClassName,\n    headerFooterTag,\n    scrollerRef,\n    FooterComponent: distinctProp(\"Footer\"),\n    HeaderComponent: distinctProp(\"Header\"),\n    ListComponent: distinctProp(\"List\", \"div\"),\n    ItemComponent: distinctProp(\"Item\", \"div\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\", \"div\")\n  };\n});\nconst combinedSystem$1 = /* @__PURE__ */ system(([gridSystem2, gridComponentPropsSystem2]) => {\n  return { ...gridSystem2, ...gridComponentPropsSystem2 };\n}, tup(gridSystem, gridComponentPropsSystem));\nconst GridItems = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function GridItems2() {\n  const gridState = useEmitterValue$1(\"gridState\");\n  const listClassName = useEmitterValue$1(\"listClassName\");\n  const itemClassName = useEmitterValue$1(\"itemClassName\");\n  const itemContent = useEmitterValue$1(\"itemContent\");\n  const computeItemKey = useEmitterValue$1(\"computeItemKey\");\n  const isSeeking = useEmitterValue$1(\"isSeeking\");\n  const scrollHeightCallback = usePublisher$1(\"scrollHeight\");\n  const ItemComponent = useEmitterValue$1(\"ItemComponent\");\n  const ListComponent = useEmitterValue$1(\"ListComponent\");\n  const ScrollSeekPlaceholder = useEmitterValue$1(\"ScrollSeekPlaceholder\");\n  const context = useEmitterValue$1(\"context\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const gridGap = usePublisher$1(\"gap\");\n  const log = useEmitterValue$1(\"log\");\n  const stateRestoreInProgress = useEmitterValue$1(\"stateRestoreInProgress\");\n  const reportReadyState = usePublisher$1(\"reportReadyState\");\n  const listRef = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (el) => {\n        const scrollHeight = el.parentElement.parentElement.scrollHeight;\n        scrollHeightCallback(scrollHeight);\n        const firstItem = el.firstChild;\n        if (firstItem) {\n          const { width, height } = firstItem.getBoundingClientRect();\n          itemDimensions({ width, height });\n        }\n        gridGap({\n          row: resolveGapValue(\"row-gap\", getComputedStyle(el).rowGap, log),\n          column: resolveGapValue(\"column-gap\", getComputedStyle(el).columnGap, log)\n        });\n      },\n      [scrollHeightCallback, itemDimensions, gridGap, log]\n    ),\n    true,\n    false\n  );\n  useIsomorphicLayoutEffect(() => {\n    if (gridState.itemHeight > 0 && gridState.itemWidth > 0) {\n      reportReadyState(true);\n    }\n  }, [gridState]);\n  if (stateRestoreInProgress) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    ListComponent,\n    {\n      ref: listRef,\n      className: listClassName,\n      ...contextPropIfNotDomElement(ListComponent, context),\n      style: { paddingTop: gridState.offsetTop, paddingBottom: gridState.offsetBottom },\n      \"data-testid\": \"virtuoso-item-list\",\n      children: gridState.items.map((item) => {\n        const key = computeItemKey(item.index, item.data, context);\n        return isSeeking ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n          ScrollSeekPlaceholder,\n          {\n            ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n            index: item.index,\n            height: gridState.itemHeight,\n            width: gridState.itemWidth\n          },\n          key\n        ) : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n          ItemComponent,\n          {\n            ...contextPropIfNotDomElement(ItemComponent, context),\n            className: itemClassName,\n            \"data-index\": item.index,\n            key\n          },\n          itemContent(item.index, item.data, context)\n        );\n      })\n    }\n  );\n});\nconst Header = react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoHeader2() {\n  const Header2 = useEmitterValue$1(\"HeaderComponent\");\n  const headerHeight = usePublisher$1(\"headerHeight\");\n  const HeaderFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (el) => headerHeight(correctItemSize(el, \"height\")), [headerHeight]),\n    true,\n    false\n  );\n  const context = useEmitterValue$1(\"context\");\n  return Header2 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HeaderFooterTag, { ref, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Header2, { ...contextPropIfNotDomElement(Header2, context) }) }) : null;\n});\nconst Footer = react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoGridFooter() {\n  const Footer2 = useEmitterValue$1(\"FooterComponent\");\n  const footerHeight = usePublisher$1(\"footerHeight\");\n  const HeaderFooterTag = useEmitterValue$1(\"headerFooterTag\");\n  const ref = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (el) => footerHeight(correctItemSize(el, \"height\")), [footerHeight]),\n    true,\n    false\n  );\n  const context = useEmitterValue$1(\"context\");\n  return Footer2 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(HeaderFooterTag, { ref, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Footer2, { ...contextPropIfNotDomElement(Footer2, context) }) }) : null;\n});\nconst Viewport$1 = ({ children }) => {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(VirtuosoGridMockContext);\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const viewportDimensions = usePublisher$1(\"viewportDimensions\");\n  const viewportRef = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(\n      () => (el) => {\n        viewportDimensions(el.getBoundingClientRect());\n      },\n      [viewportDimensions]\n    ),\n    true,\n    false\n  );\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (ctx) {\n      viewportDimensions({ height: ctx.viewportHeight, width: ctx.viewportWidth });\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n    }\n  }, [ctx, viewportDimensions, itemDimensions]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: viewportStyle(false), ref: viewportRef, children });\n};\nconst WindowViewport$1 = ({ children }) => {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(VirtuosoGridMockContext);\n  const windowViewportRect = usePublisher$1(\"windowViewportRect\");\n  const itemDimensions = usePublisher$1(\"itemDimensions\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(windowViewportRect, customScrollParent, false);\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (ctx) {\n      itemDimensions({ height: ctx.itemHeight, width: ctx.itemWidth });\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: ctx.viewportWidth });\n    }\n  }, [ctx, windowViewportRect, itemDimensions]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: viewportRef, style: viewportStyle(false), children });\n};\nconst GridRoot = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function GridRoot2({ ...props }) {\n  const useWindowScroll = useEmitterValue$1(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue$1(\"customScrollParent\");\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller$1 : Scroller$1;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport$1 : Viewport$1;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TheScroller, { ...props, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TheViewport, { children: [\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Header, {}),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GridItems, {}),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Footer, {})\n  ] }) });\n});\nconst {\n  Component: Grid,\n  usePublisher: usePublisher$1,\n  useEmitterValue: useEmitterValue$1,\n  useEmitter: useEmitter$1\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem$1,\n  {\n    optional: {\n      context: \"context\",\n      totalCount: \"totalCount\",\n      overscan: \"overscan\",\n      itemContent: \"itemContent\",\n      components: \"components\",\n      computeItemKey: \"computeItemKey\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      headerFooterTag: \"headerFooterTag\",\n      listClassName: \"listClassName\",\n      itemClassName: \"itemClassName\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\",\n      restoreStateFrom: \"restoreStateFrom\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      increaseViewportBy: \"increaseViewportBy\"\n    },\n    methods: {\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      scrollToIndex: \"scrollToIndex\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      stateChanged: \"stateChanged\",\n      readyStateChanged: \"readyStateChanged\"\n    }\n  },\n  GridRoot\n);\nconst Scroller$1 = /* @__PURE__ */ buildScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nconst WindowScroller$1 = /* @__PURE__ */ buildWindowScroller({ usePublisher: usePublisher$1, useEmitterValue: useEmitterValue$1, useEmitter: useEmitter$1 });\nfunction resolveGapValue(property, value, log) {\n  if (value !== \"normal\" && !(value == null ? void 0 : value.endsWith(\"px\"))) {\n    log(`${property} was not resolved to pixel value correctly`, value, LogLevel.WARN);\n  }\n  if (value === \"normal\") {\n    return 0;\n  }\n  return parseInt(value != null ? value : \"0\", 10);\n}\nconst VirtuosoGrid = Grid;\nconst tableComponentPropsSystem = /* @__PURE__ */ system(() => {\n  const itemContent = statefulStream((index) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"td\", { children: [\n    \"Item $\",\n    index\n  ] }));\n  const context = statefulStream(null);\n  const fixedHeaderContent = statefulStream(null);\n  const fixedFooterContent = statefulStream(null);\n  const components = statefulStream({});\n  const computeItemKey = statefulStream(identity);\n  const scrollerRef = statefulStream(noop);\n  const distinctProp = (propName, defaultValue = null) => {\n    return statefulStreamFromEmitter(\n      pipe(\n        components,\n        map((components2) => components2[propName]),\n        distinctUntilChanged()\n      ),\n      defaultValue\n    );\n  };\n  return {\n    context,\n    itemContent,\n    fixedHeaderContent,\n    fixedFooterContent,\n    components,\n    computeItemKey,\n    scrollerRef,\n    TableComponent: distinctProp(\"Table\", \"table\"),\n    TableHeadComponent: distinctProp(\"TableHead\", \"thead\"),\n    TableFooterComponent: distinctProp(\"TableFoot\", \"tfoot\"),\n    TableBodyComponent: distinctProp(\"TableBody\", \"tbody\"),\n    TableRowComponent: distinctProp(\"TableRow\", \"tr\"),\n    ScrollerComponent: distinctProp(\"Scroller\", \"div\"),\n    EmptyPlaceholder: distinctProp(\"EmptyPlaceholder\"),\n    ScrollSeekPlaceholder: distinctProp(\"ScrollSeekPlaceholder\"),\n    FillerRow: distinctProp(\"FillerRow\")\n  };\n});\nconst combinedSystem = /* @__PURE__ */ system(([listSystem2, propsSystem]) => {\n  return { ...listSystem2, ...propsSystem };\n}, tup(listSystem, tableComponentPropsSystem));\nconst DefaultScrollSeekPlaceholder = ({ height }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"tr\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"td\", { style: { height } }) });\nconst DefaultFillerRow = ({ height }) => /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"tr\", { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"td\", { style: { height, padding: 0, border: 0 } }) });\nconst ITEM_STYLE = { overflowAnchor: \"none\" };\nconst Items = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function VirtuosoItems2({ showTopList = false }) {\n  const listState = useEmitterValue(\"listState\");\n  const computeItemKey = useEmitterValue(\"computeItemKey\");\n  const firstItemIndex = useEmitterValue(\"firstItemIndex\");\n  const isSeeking = useEmitterValue(\"isSeeking\");\n  const ScrollSeekPlaceholder = useEmitterValue(\"ScrollSeekPlaceholder\") || DefaultScrollSeekPlaceholder;\n  const context = useEmitterValue(\"context\");\n  const TableRowComponent = useEmitterValue(\"TableRowComponent\");\n  const fixedHeaderHeight = useEmitterValue(\"fixedHeaderHeight\");\n  const itemContent = useEmitterValue(\"itemContent\");\n  const topItemOffsets = (showTopList ? listState.topItems : []).reduce((acc, item, index) => {\n    if (index === 0) {\n      acc.push(item.size);\n    } else {\n      acc.push(acc[index - 1] + item.size);\n    }\n    return acc;\n  }, []);\n  const items = (showTopList ? listState.topItems : listState.items).map((item) => {\n    const index = item.originalIndex;\n    const key = computeItemKey(index + firstItemIndex, item.data, context);\n    const offsetTop = showTopList ? index === 0 ? 0 : topItemOffsets[index - 1] : 0;\n    if (isSeeking) {\n      return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n        ScrollSeekPlaceholder,\n        {\n          ...contextPropIfNotDomElement(ScrollSeekPlaceholder, context),\n          key,\n          index: item.index,\n          height: item.size,\n          type: item.type || \"item\"\n        }\n      );\n    }\n    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(\n      TableRowComponent,\n      {\n        ...contextPropIfNotDomElement(TableRowComponent, context),\n        ...itemPropIfNotDomElement(TableRowComponent, item.data),\n        key,\n        \"data-index\": index,\n        \"data-known-size\": item.size,\n        \"data-item-index\": item.index,\n        style: showTopList ? { overflowAnchor: \"none\", position: \"sticky\", zIndex: 2, top: fixedHeaderHeight + offsetTop } : ITEM_STYLE\n      },\n      itemContent(item.index, item.data, context)\n    );\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: items });\n});\nconst TableBody = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function TableVirtuosoBody() {\n  const listState = useEmitterValue(\"listState\");\n  const showTopList = useEmitterValue(\"topItemsIndexes\").length > 0;\n  const sizeRanges = usePublisher(\"sizeRanges\");\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const windowScrollContainerStateCallback = usePublisher(\"windowScrollContainerState\");\n  const _scrollContainerStateCallback = usePublisher(\"scrollContainerState\");\n  const scrollContainerStateCallback = customScrollParent || useWindowScroll ? windowScrollContainerStateCallback : _scrollContainerStateCallback;\n  const trackItemSizes = useEmitterValue(\"trackItemSizes\");\n  const itemSize = useEmitterValue(\"itemSize\");\n  const log = useEmitterValue(\"log\");\n  const { callbackRef, ref } = useChangedListContentsSizes(\n    sizeRanges,\n    itemSize,\n    trackItemSizes,\n    scrollContainerStateCallback,\n    log,\n    void 0,\n    customScrollParent,\n    false,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  const [deviation, setDeviation] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n  useEmitter(\"deviation\", (value) => {\n    if (deviation !== value) {\n      ref.current.style.marginTop = `${value}px`;\n      setDeviation(value);\n    }\n  });\n  const EmptyPlaceholder = useEmitterValue(\"EmptyPlaceholder\");\n  const FillerRow = useEmitterValue(\"FillerRow\") || DefaultFillerRow;\n  const TableBodyComponent = useEmitterValue(\"TableBodyComponent\");\n  const paddingTopAddition = useEmitterValue(\"paddingTopAddition\");\n  const statefulTotalCount = useEmitterValue(\"statefulTotalCount\");\n  const context = useEmitterValue(\"context\");\n  if (statefulTotalCount === 0 && EmptyPlaceholder) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EmptyPlaceholder, { ...contextPropIfNotDomElement(EmptyPlaceholder, context) });\n  }\n  const topItemsSize = (showTopList ? listState.topItems : []).reduce((acc, item) => acc + item.size, 0);\n  const paddingTop = listState.offsetTop + paddingTopAddition + deviation - topItemsSize;\n  const paddingBottom = listState.offsetBottom;\n  const paddingTopEl = paddingTop > 0 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FillerRow, { height: paddingTop, context }, \"padding-top\") : null;\n  const paddingBottomEl = paddingBottom > 0 ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FillerRow, { height: paddingBottom, context }, \"padding-bottom\") : null;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TableBodyComponent, { ref: callbackRef, \"data-testid\": \"virtuoso-item-list\", ...contextPropIfNotDomElement(TableBodyComponent, context), children: [\n    paddingTopEl,\n    showTopList && /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Items, { showTopList: true }),\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Items, {}),\n    paddingBottomEl\n  ] });\n});\nconst Viewport = ({ children }) => {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(VirtuosoMockContext);\n  const viewportHeight = usePublisher(\"viewportHeight\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const viewportRef = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => compose(viewportHeight, (el) => correctItemSize(el, \"height\")), [viewportHeight]),\n    true,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (ctx) {\n      viewportHeight(ctx.viewportHeight);\n      fixedItemHeight(ctx.itemHeight);\n    }\n  }, [ctx, viewportHeight, fixedItemHeight]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { style: viewportStyle(false), ref: viewportRef, \"data-viewport-type\": \"element\", children });\n};\nconst WindowViewport = ({ children }) => {\n  const ctx = react__WEBPACK_IMPORTED_MODULE_1__.useContext(VirtuosoMockContext);\n  const windowViewportRect = usePublisher(\"windowViewportRect\");\n  const fixedItemHeight = usePublisher(\"fixedItemHeight\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const viewportRef = useWindowViewportRectRef(\n    windowViewportRect,\n    customScrollParent,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    if (ctx) {\n      fixedItemHeight(ctx.itemHeight);\n      windowViewportRect({ offsetTop: 0, visibleHeight: ctx.viewportHeight, visibleWidth: 100 });\n    }\n  }, [ctx, windowViewportRect, fixedItemHeight]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: viewportRef, style: viewportStyle(false), \"data-viewport-type\": \"window\", children });\n};\nconst TableRoot = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.memo(function TableVirtuosoRoot(props) {\n  const useWindowScroll = useEmitterValue(\"useWindowScroll\");\n  const customScrollParent = useEmitterValue(\"customScrollParent\");\n  const fixedHeaderHeight = usePublisher(\"fixedHeaderHeight\");\n  const fixedFooterHeight = usePublisher(\"fixedFooterHeight\");\n  const fixedHeaderContent = useEmitterValue(\"fixedHeaderContent\");\n  const fixedFooterContent = useEmitterValue(\"fixedFooterContent\");\n  const context = useEmitterValue(\"context\");\n  const theadRef = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => compose(fixedHeaderHeight, (el) => correctItemSize(el, \"height\")), [fixedHeaderHeight]),\n    true,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  const tfootRef = useSize(\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => compose(fixedFooterHeight, (el) => correctItemSize(el, \"height\")), [fixedFooterHeight]),\n    true,\n    useEmitterValue(\"skipAnimationFrameInResizeObserver\")\n  );\n  const TheScroller = customScrollParent || useWindowScroll ? WindowScroller : Scroller;\n  const TheViewport = customScrollParent || useWindowScroll ? WindowViewport : Viewport;\n  const TheTable = useEmitterValue(\"TableComponent\");\n  const TheTHead = useEmitterValue(\"TableHeadComponent\");\n  const TheTFoot = useEmitterValue(\"TableFooterComponent\");\n  const theHead = fixedHeaderContent ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    TheTHead,\n    {\n      style: { zIndex: 2, position: \"sticky\", top: 0 },\n      ref: theadRef,\n      ...contextPropIfNotDomElement(TheTHead, context),\n      children: fixedHeaderContent()\n    },\n    \"TableHead\"\n  ) : null;\n  const theFoot = fixedFooterContent ? /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\n    TheTFoot,\n    {\n      style: { zIndex: 1, position: \"sticky\", bottom: 0 },\n      ref: tfootRef,\n      ...contextPropIfNotDomElement(TheTFoot, context),\n      children: fixedFooterContent()\n    },\n    \"TableFoot\"\n  ) : null;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TheScroller, { ...props, children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TheViewport, { children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(TheTable, { style: { borderSpacing: 0, overflowAnchor: \"none\" }, ...contextPropIfNotDomElement(TheTable, context), children: [\n    theHead,\n    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TableBody, {}, \"TableBody\"),\n    theFoot\n  ] }) }) });\n});\nconst {\n  Component: Table,\n  usePublisher,\n  useEmitterValue,\n  useEmitter\n} = /* @__PURE__ */ systemToComponent(\n  combinedSystem,\n  {\n    required: {},\n    optional: {\n      restoreStateFrom: \"restoreStateFrom\",\n      context: \"context\",\n      followOutput: \"followOutput\",\n      firstItemIndex: \"firstItemIndex\",\n      itemContent: \"itemContent\",\n      fixedHeaderContent: \"fixedHeaderContent\",\n      fixedFooterContent: \"fixedFooterContent\",\n      overscan: \"overscan\",\n      increaseViewportBy: \"increaseViewportBy\",\n      totalCount: \"totalCount\",\n      topItemCount: \"topItemCount\",\n      initialTopMostItemIndex: \"initialTopMostItemIndex\",\n      components: \"components\",\n      groupCounts: \"groupCounts\",\n      atBottomThreshold: \"atBottomThreshold\",\n      atTopThreshold: \"atTopThreshold\",\n      computeItemKey: \"computeItemKey\",\n      defaultItemHeight: \"defaultItemHeight\",\n      fixedItemHeight: \"fixedItemHeight\",\n      itemSize: \"itemSize\",\n      scrollSeekConfiguration: \"scrollSeekConfiguration\",\n      data: \"data\",\n      initialItemCount: \"initialItemCount\",\n      initialScrollTop: \"initialScrollTop\",\n      alignToBottom: \"alignToBottom\",\n      useWindowScroll: \"useWindowScroll\",\n      customScrollParent: \"customScrollParent\",\n      scrollerRef: \"scrollerRef\",\n      logLevel: \"logLevel\"\n    },\n    methods: {\n      scrollToIndex: \"scrollToIndex\",\n      scrollIntoView: \"scrollIntoView\",\n      scrollTo: \"scrollTo\",\n      scrollBy: \"scrollBy\",\n      getState: \"getState\"\n    },\n    events: {\n      isScrolling: \"isScrolling\",\n      endReached: \"endReached\",\n      startReached: \"startReached\",\n      rangeChanged: \"rangeChanged\",\n      atBottomStateChange: \"atBottomStateChange\",\n      atTopStateChange: \"atTopStateChange\",\n      totalListHeightChanged: \"totalListHeightChanged\",\n      itemsRendered: \"itemsRendered\",\n      groupIndices: \"groupIndices\"\n    }\n  },\n  TableRoot\n);\nconst Scroller = /* @__PURE__ */ buildScroller({ usePublisher, useEmitterValue, useEmitter });\nconst WindowScroller = /* @__PURE__ */ buildWindowScroller({ usePublisher, useEmitterValue, useEmitter });\nconst TableVirtuoso = Table;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNYO0FBQ1o7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWSxJQUFJLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQ0FBK0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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anMvLi9ub2RlX21vZHVsZXMvcmVhY3QtdmlydHVvc28vZGlzdC9pbmRleC5tanM/NzU4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlRWxlbWVudCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmNvbnN0IFBVQkxJU0ggPSAwO1xuY29uc3QgU1VCU0NSSUJFID0gMTtcbmNvbnN0IFJFU0VUID0gMjtcbmNvbnN0IFZBTFVFID0gNDtcbmZ1bmN0aW9uIGNvbXBvc2UoYSwgYikge1xuICByZXR1cm4gKGFyZykgPT4gYShiKGFyZykpO1xufVxuZnVuY3Rpb24gdGhydXNoKGFyZywgcHJvYykge1xuICByZXR1cm4gcHJvYyhhcmcpO1xufVxuZnVuY3Rpb24gY3VycnkydG8xKHByb2MsIGFyZzEpIHtcbiAgcmV0dXJuIChhcmcyKSA9PiBwcm9jKGFyZzEsIGFyZzIpO1xufVxuZnVuY3Rpb24gY3VycnkxdG8wKHByb2MsIGFyZykge1xuICByZXR1cm4gKCkgPT4gcHJvYyhhcmcpO1xufVxuZnVuY3Rpb24gdGFwKGFyZywgcHJvYykge1xuICBwcm9jKGFyZyk7XG4gIHJldHVybiBhcmc7XG59XG5mdW5jdGlvbiB0dXAoLi4uYXJncykge1xuICByZXR1cm4gYXJncztcbn1cbmZ1bmN0aW9uIGNhbGwocHJvYykge1xuICBwcm9jKCk7XG59XG5mdW5jdGlvbiBhbHdheXModmFsdWUpIHtcbiAgcmV0dXJuICgpID0+IHZhbHVlO1xufVxuZnVuY3Rpb24gam9pblByb2MoLi4ucHJvY3MpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBwcm9jcy5tYXAoY2FsbCk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0RlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgIT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG5mdW5jdGlvbiBzdWJzY3JpYmUoZW1pdHRlciwgc3Vic2NyaXB0aW9uKSB7XG4gIHJldHVybiBlbWl0dGVyKFNVQlNDUklCRSwgc3Vic2NyaXB0aW9uKTtcbn1cbmZ1bmN0aW9uIHB1Ymxpc2gocHVibGlzaGVyLCB2YWx1ZSkge1xuICBwdWJsaXNoZXIoUFVCTElTSCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gcmVzZXQoZW1pdHRlcikge1xuICBlbWl0dGVyKFJFU0VUKTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGRlcG90KSB7XG4gIHJldHVybiBkZXBvdChWQUxVRSk7XG59XG5mdW5jdGlvbiBjb25uZWN0KGVtaXR0ZXIsIHB1Ymxpc2hlcikge1xuICByZXR1cm4gc3Vic2NyaWJlKGVtaXR0ZXIsIGN1cnJ5MnRvMShwdWJsaXNoZXIsIFBVQkxJU0gpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5leHQoZW1pdHRlciwgc3Vic2NyaXB0aW9uKSB7XG4gIGNvbnN0IHVuc3ViID0gZW1pdHRlcihTVUJTQ1JJQkUsICh2YWx1ZSkgPT4ge1xuICAgIHVuc3ViKCk7XG4gICAgc3Vic2NyaXB0aW9uKHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiB1bnN1Yjtcbn1cbmZ1bmN0aW9uIHN0cmVhbSgpIHtcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IFtdO1xuICByZXR1cm4gKGFjdGlvbiwgYXJnKSA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKDAsIHN1YnNjcmlwdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChhcmcpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGluZGV4T2YgPSBzdWJzY3JpcHRpb25zLmluZGV4T2YoYXJnKTtcbiAgICAgICAgICBpZiAoaW5kZXhPZiA+IC0xKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShpbmRleE9mLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICBjYXNlIFBVQkxJU0g6XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuc2xpY2UoKS5mb3JFYWNoKChzdWJzY3JpcHRpb24pID0+IHtcbiAgICAgICAgICBzdWJzY3JpcHRpb24oYXJnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGFjdGlvbiAke2FjdGlvbn1gKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzdGF0ZWZ1bFN0cmVhbShpbml0aWFsKSB7XG4gIGxldCB2YWx1ZSA9IGluaXRpYWw7XG4gIGNvbnN0IGlubmVyU3ViamVjdCA9IHN0cmVhbSgpO1xuICByZXR1cm4gKGFjdGlvbiwgYXJnKSA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhcmc7XG4gICAgICAgIHN1YnNjcmlwdGlvbih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQVUJMSVNIOlxuICAgICAgICB2YWx1ZSA9IGFyZztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZBTFVFOlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbm5lclN1YmplY3QoYWN0aW9uLCBhcmcpO1xuICB9O1xufVxuZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGVtaXR0ZXIpIHtcbiAgbGV0IHVuc3ViO1xuICBsZXQgY3VycmVudFN1YnNjcmlwdGlvbjtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IHVuc3ViICYmIHVuc3ViKCk7XG4gIHJldHVybiBmdW5jdGlvbihhY3Rpb24sIHN1YnNjcmlwdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgIGlmIChjdXJyZW50U3Vic2NyaXB0aW9uID09PSBzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgdW5zdWIgPSBzdWJzY3JpYmUoZW1pdHRlciwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICByZXR1cm4gdW5zdWI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBhY3Rpb24gJHthY3Rpb259YCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3RyZWFtRnJvbUVtaXR0ZXIoZW1pdHRlcikge1xuICByZXR1cm4gdGFwKHN0cmVhbSgpLCAoc3RyZWFtMikgPT4gY29ubmVjdChlbWl0dGVyLCBzdHJlYW0yKSk7XG59XG5mdW5jdGlvbiBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKGVtaXR0ZXIsIGluaXRpYWwpIHtcbiAgcmV0dXJuIHRhcChzdGF0ZWZ1bFN0cmVhbShpbml0aWFsKSwgKHN0cmVhbTIpID0+IGNvbm5lY3QoZW1pdHRlciwgc3RyZWFtMikpO1xufVxuZnVuY3Rpb24gY29tYmluZU9wZXJhdG9ycyguLi5vcGVyYXRvcnMpIHtcbiAgcmV0dXJuIChzdWJzY3JpYmVyKSA9PiB7XG4gICAgcmV0dXJuIG9wZXJhdG9ycy5yZWR1Y2VSaWdodCh0aHJ1c2gsIHN1YnNjcmliZXIpO1xuICB9O1xufVxuZnVuY3Rpb24gcGlwZShzb3VyY2UsIC4uLm9wZXJhdG9ycykge1xuICBjb25zdCBwcm9qZWN0ID0gY29tYmluZU9wZXJhdG9ycyguLi5vcGVyYXRvcnMpO1xuICByZXR1cm4gKGFjdGlvbiwgc3Vic2NyaXB0aW9uKSA9PiB7XG4gICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgU1VCU0NSSUJFOlxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlKHNvdXJjZSwgcHJvamVjdChzdWJzY3JpcHRpb24pKTtcbiAgICAgIGNhc2UgUkVTRVQ6XG4gICAgICAgIHJlc2V0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihwcmV2aW91cywgbmV4dCkge1xuICByZXR1cm4gcHJldmlvdXMgPT09IG5leHQ7XG59XG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJhdG9yID0gZGVmYXVsdENvbXBhcmF0b3IpIHtcbiAgbGV0IGN1cnJlbnQ7XG4gIHJldHVybiAoZG9uZSkgPT4gKG5leHQpID0+IHtcbiAgICBpZiAoIWNvbXBhcmF0b3IoY3VycmVudCwgbmV4dCkpIHtcbiAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgZG9uZShuZXh0KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlKSB7XG4gIHJldHVybiAoZG9uZSkgPT4gKHZhbHVlKSA9PiB7XG4gICAgcHJlZGljYXRlKHZhbHVlKSAmJiBkb25lKHZhbHVlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG1hcChwcm9qZWN0KSB7XG4gIHJldHVybiAoZG9uZSkgPT4gY29tcG9zZShkb25lLCBwcm9qZWN0KTtcbn1cbmZ1bmN0aW9uIG1hcFRvKHZhbHVlKSB7XG4gIHJldHVybiAoZG9uZSkgPT4gKCkgPT4gZG9uZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBzY2FuKHNjYW5uZXIsIGluaXRpYWwpIHtcbiAgcmV0dXJuIChkb25lKSA9PiAodmFsdWUpID0+IGRvbmUoaW5pdGlhbCA9IHNjYW5uZXIoaW5pdGlhbCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHNraXAodGltZXMpIHtcbiAgcmV0dXJuIChkb25lKSA9PiAodmFsdWUpID0+IHtcbiAgICB0aW1lcyA+IDAgPyB0aW1lcy0tIDogZG9uZSh2YWx1ZSk7XG4gIH07XG59XG5mdW5jdGlvbiB0aHJvdHRsZVRpbWUoaW50ZXJ2YWwpIHtcbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IG51bGw7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gKGRvbmUpID0+ICh2YWx1ZSkgPT4ge1xuICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICBkb25lKGN1cnJlbnRWYWx1ZSk7XG4gICAgfSwgaW50ZXJ2YWwpO1xuICB9O1xufVxuZnVuY3Rpb24gZGVib3VuY2VUaW1lKGludGVydmFsKSB7XG4gIGxldCBjdXJyZW50VmFsdWU7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gKGRvbmUpID0+ICh2YWx1ZSkgPT4ge1xuICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgfVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRvbmUoY3VycmVudFZhbHVlKTtcbiAgICB9LCBpbnRlcnZhbCk7XG4gIH07XG59XG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSguLi5zb3VyY2VzKSB7XG4gIGNvbnN0IHZhbHVlcyA9IG5ldyBBcnJheShzb3VyY2VzLmxlbmd0aCk7XG4gIGxldCBjYWxsZWQgPSAwO1xuICBsZXQgcGVuZGluZ0NhbGwgPSBudWxsO1xuICBjb25zdCBhbGxDYWxsZWQgPSBNYXRoLnBvdygyLCBzb3VyY2VzLmxlbmd0aCkgLSAxO1xuICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBiaXQgPSBNYXRoLnBvdygyLCBpbmRleCk7XG4gICAgc3Vic2NyaWJlKHNvdXJjZSwgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBwcmV2Q2FsbGVkID0gY2FsbGVkO1xuICAgICAgY2FsbGVkID0gY2FsbGVkIHwgYml0O1xuICAgICAgdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgaWYgKHByZXZDYWxsZWQgIT09IGFsbENhbGxlZCAmJiBjYWxsZWQgPT09IGFsbENhbGxlZCAmJiBwZW5kaW5nQ2FsbCkge1xuICAgICAgICBwZW5kaW5nQ2FsbCgpO1xuICAgICAgICBwZW5kaW5nQ2FsbCA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gKGRvbmUpID0+ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGNhbGwyID0gKCkgPT4gZG9uZShbdmFsdWVdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICBpZiAoY2FsbGVkID09PSBhbGxDYWxsZWQpIHtcbiAgICAgIGNhbGwyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdDYWxsID0gY2FsbDI7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2UoLi4uc291cmNlcykge1xuICByZXR1cm4gZnVuY3Rpb24oYWN0aW9uLCBzdWJzY3JpcHRpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgY2FzZSBTVUJTQ1JJQkU6XG4gICAgICAgIHJldHVybiBqb2luUHJvYyguLi5zb3VyY2VzLm1hcCgoc291cmNlKSA9PiBzdWJzY3JpYmUoc291cmNlLCBzdWJzY3JpcHRpb24pKSk7XG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVucmVjb2duaXplZCBhY3Rpb24gJHthY3Rpb259YCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZHVjKHNvdXJjZSwgY29tcGFyYXRvciA9IGRlZmF1bHRDb21wYXJhdG9yKSB7XG4gIHJldHVybiBwaXBlKHNvdXJjZSwgZGlzdGluY3RVbnRpbENoYW5nZWQoY29tcGFyYXRvcikpO1xufVxuZnVuY3Rpb24gY29tYmluZUxhdGVzdCguLi5lbWl0dGVycykge1xuICBjb25zdCBpbm5lclN1YmplY3QgPSBzdHJlYW0oKTtcbiAgY29uc3QgdmFsdWVzID0gbmV3IEFycmF5KGVtaXR0ZXJzLmxlbmd0aCk7XG4gIGxldCBjYWxsZWQgPSAwO1xuICBjb25zdCBhbGxDYWxsZWQgPSBNYXRoLnBvdygyLCBlbWl0dGVycy5sZW5ndGgpIC0gMTtcbiAgZW1pdHRlcnMuZm9yRWFjaCgoc291cmNlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGJpdCA9IE1hdGgucG93KDIsIGluZGV4KTtcbiAgICBzdWJzY3JpYmUoc291cmNlLCAodmFsdWUpID0+IHtcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgIGNhbGxlZCA9IGNhbGxlZCB8IGJpdDtcbiAgICAgIGlmIChjYWxsZWQgPT09IGFsbENhbGxlZCkge1xuICAgICAgICBwdWJsaXNoKGlubmVyU3ViamVjdCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhY3Rpb24sIHN1YnNjcmlwdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICBjYXNlIFNVQlNDUklCRTpcbiAgICAgICAgaWYgKGNhbGxlZCA9PT0gYWxsQ2FsbGVkKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZShpbm5lclN1YmplY3QsIHN1YnNjcmlwdGlvbik7XG4gICAgICBjYXNlIFJFU0VUOlxuICAgICAgICByZXR1cm4gcmVzZXQoaW5uZXJTdWJqZWN0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5yZWNvZ25pemVkIGFjdGlvbiAke2FjdGlvbn1gKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzeXN0ZW0oY29uc3RydWN0b3IsIGRlcGVuZGVuY2llcyA9IFtdLCB7IHNpbmdsZXRvbiB9ID0geyBzaW5nbGV0b246IHRydWUgfSkge1xuICByZXR1cm4ge1xuICAgIGlkOiBpZCgpLFxuICAgIGNvbnN0cnVjdG9yLFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBzaW5nbGV0b25cbiAgfTtcbn1cbmNvbnN0IGlkID0gKCkgPT4gU3ltYm9sKCk7XG5mdW5jdGlvbiBpbml0KHN5c3RlbVNwZWMpIHtcbiAgY29uc3Qgc2luZ2xldG9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IF9pbml0ID0gKHsgaWQ6IGlkMiwgY29uc3RydWN0b3IsIGRlcGVuZGVuY2llcywgc2luZ2xldG9uIH0pID0+IHtcbiAgICBpZiAoc2luZ2xldG9uICYmIHNpbmdsZXRvbnMuaGFzKGlkMikpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b25zLmdldChpZDIpO1xuICAgIH1cbiAgICBjb25zdCBzeXN0ZW0yID0gY29uc3RydWN0b3IoZGVwZW5kZW5jaWVzLm1hcCgoZSkgPT4gX2luaXQoZSkpKTtcbiAgICBpZiAoc2luZ2xldG9uKSB7XG4gICAgICBzaW5nbGV0b25zLnNldChpZDIsIHN5c3RlbTIpO1xuICAgIH1cbiAgICByZXR1cm4gc3lzdGVtMjtcbiAgfTtcbiAgcmV0dXJuIF9pbml0KHN5c3RlbVNwZWMpO1xufVxuZnVuY3Rpb24gb21pdChrZXlzLCBvYmopIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGNvbnN0IGluZGV4ID0ge307XG4gIGxldCBpZHggPSAwO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGluZGV4W2tleXNbaWR4XV0gPSAxO1xuICAgIGlkeCArPSAxO1xuICB9XG4gIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICBpZiAoIWluZGV4Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JDEgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiBzeXN0ZW1Ub0NvbXBvbmVudChzeXN0ZW1TcGVjLCBtYXAyLCBSb290KSB7XG4gIGNvbnN0IHJlcXVpcmVkUHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwMi5yZXF1aXJlZCB8fCB7fSk7XG4gIGNvbnN0IG9wdGlvbmFsUHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwMi5vcHRpb25hbCB8fCB7fSk7XG4gIGNvbnN0IG1ldGhvZE5hbWVzID0gT2JqZWN0LmtleXMobWFwMi5tZXRob2RzIHx8IHt9KTtcbiAgY29uc3QgZXZlbnROYW1lcyA9IE9iamVjdC5rZXlzKG1hcDIuZXZlbnRzIHx8IHt9KTtcbiAgY29uc3QgQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pO1xuICBmdW5jdGlvbiBhcHBseVByb3BzVG9TeXN0ZW0oc3lzdGVtMiwgcHJvcHMpIHtcbiAgICBpZiAoc3lzdGVtMltcInByb3BzUmVhZHlcIl0pIHtcbiAgICAgIHB1Ymxpc2goc3lzdGVtMltcInByb3BzUmVhZHlcIl0sIGZhbHNlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCByZXF1aXJlZFByb3BOYW1lIG9mIHJlcXVpcmVkUHJvcE5hbWVzKSB7XG4gICAgICBjb25zdCBzdHJlYW0yID0gc3lzdGVtMlttYXAyLnJlcXVpcmVkW3JlcXVpcmVkUHJvcE5hbWVdXTtcbiAgICAgIHB1Ymxpc2goc3RyZWFtMiwgcHJvcHNbcmVxdWlyZWRQcm9wTmFtZV0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9wdGlvbmFsUHJvcE5hbWUgb2Ygb3B0aW9uYWxQcm9wTmFtZXMpIHtcbiAgICAgIGlmIChvcHRpb25hbFByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbTIgPSBzeXN0ZW0yW21hcDIub3B0aW9uYWxbb3B0aW9uYWxQcm9wTmFtZV1dO1xuICAgICAgICBwdWJsaXNoKHN0cmVhbTIsIHByb3BzW29wdGlvbmFsUHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5c3RlbTJbXCJwcm9wc1JlYWR5XCJdKSB7XG4gICAgICBwdWJsaXNoKHN5c3RlbTJbXCJwcm9wc1JlYWR5XCJdLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYnVpbGRNZXRob2RzKHN5c3RlbTIpIHtcbiAgICByZXR1cm4gbWV0aG9kTmFtZXMucmVkdWNlKChhY2MsIG1ldGhvZE5hbWUpID0+IHtcbiAgICAgIGFjY1ttZXRob2ROYW1lXSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBzdHJlYW0yID0gc3lzdGVtMlttYXAyLm1ldGhvZHNbbWV0aG9kTmFtZV1dO1xuICAgICAgICBwdWJsaXNoKHN0cmVhbTIsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfVxuICBmdW5jdGlvbiBidWlsZEV2ZW50SGFuZGxlcnMoc3lzdGVtMikge1xuICAgIHJldHVybiBldmVudE5hbWVzLnJlZHVjZSgoaGFuZGxlcnMsIGV2ZW50TmFtZSkgPT4ge1xuICAgICAgaGFuZGxlcnNbZXZlbnROYW1lXSA9IGV2ZW50SGFuZGxlcihzeXN0ZW0yW21hcDIuZXZlbnRzW2V2ZW50TmFtZV1dKTtcbiAgICAgIHJldHVybiBoYW5kbGVycztcbiAgICB9LCB7fSk7XG4gIH1cbiAgY29uc3QgQ29tcG9uZW50ID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHNXaXRoQ2hpbGRyZW4sIHJlZikgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnByb3BzIH0gPSBwcm9wc1dpdGhDaGlsZHJlbjtcbiAgICBjb25zdCBbc3lzdGVtMl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm4gdGFwKGluaXQoc3lzdGVtU3BlYyksIChzeXN0ZW0yMikgPT4gYXBwbHlQcm9wc1RvU3lzdGVtKHN5c3RlbTIyLCBwcm9wcykpO1xuICAgIH0pO1xuICAgIGNvbnN0IFtoYW5kbGVyc10gPSBSZWFjdC51c2VTdGF0ZShjdXJyeTF0bzAoYnVpbGRFdmVudEhhbmRsZXJzLCBzeXN0ZW0yKSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCQxKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIG9mIGV2ZW50TmFtZXMpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSBpbiBwcm9wcykge1xuICAgICAgICAgIHN1YnNjcmliZShoYW5kbGVyc1tldmVudE5hbWVdLCBwcm9wc1tldmVudE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhoYW5kbGVycykubWFwKHJlc2V0KTtcbiAgICAgIH07XG4gICAgfSwgW3Byb3BzLCBoYW5kbGVycywgc3lzdGVtMl0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QkMSgoKSA9PiB7XG4gICAgICBhcHBseVByb3BzVG9TeXN0ZW0oc3lzdGVtMiwgcHJvcHMpO1xuICAgIH0pO1xuICAgIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBhbHdheXMoYnVpbGRNZXRob2RzKHN5c3RlbTIpKSk7XG4gICAgY29uc3QgUm9vdENvbXBvbmVudCA9IFJvb3Q7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogc3lzdGVtMiwgY2hpbGRyZW46IFJvb3QgPyAvKiBAX19QVVJFX18gKi8ganN4KFJvb3RDb21wb25lbnQsIHsgLi4ub21pdChbLi4ucmVxdWlyZWRQcm9wTmFtZXMsIC4uLm9wdGlvbmFsUHJvcE5hbWVzLCAuLi5ldmVudE5hbWVzXSwgcHJvcHMpLCBjaGlsZHJlbiB9KSA6IGNoaWxkcmVuIH0pO1xuICB9KTtcbiAgY29uc3QgdXNlUHVibGlzaGVyMiA9IChrZXkpID0+IHtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soY3VycnkydG8xKHB1Ymxpc2gsIFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dClba2V5XSksIFtrZXldKTtcbiAgfTtcbiAgY29uc3QgdXNlRW1pdHRlclZhbHVlMTggPSAoa2V5KSA9PiB7XG4gICAgY29uc3Qgc3lzdGVtMiA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgY29uc3Qgc291cmNlID0gc3lzdGVtMltrZXldO1xuICAgIGNvbnN0IGNiID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgICAoYykgPT4ge1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlKHNvdXJjZSwgYyk7XG4gICAgICB9LFxuICAgICAgW3NvdXJjZV1cbiAgICApO1xuICAgIHJldHVybiBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgIGNiLFxuICAgICAgKCkgPT4gZ2V0VmFsdWUoc291cmNlKSxcbiAgICAgICgpID0+IGdldFZhbHVlKHNvdXJjZSlcbiAgICApO1xuICB9O1xuICBjb25zdCB1c2VFbWl0dGVyVmFsdWVMZWdhY3kgPSAoa2V5KSA9PiB7XG4gICAgY29uc3Qgc3lzdGVtMiA9IFJlYWN0LnVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgY29uc3Qgc291cmNlID0gc3lzdGVtMltrZXldO1xuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoY3VycnkxdG8wKGdldFZhbHVlLCBzb3VyY2UpKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JDEoXG4gICAgICAoKSA9PiBzdWJzY3JpYmUoc291cmNlLCAobmV4dCkgPT4ge1xuICAgICAgICBpZiAobmV4dCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBzZXRWYWx1ZShhbHdheXMobmV4dCkpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIFtzb3VyY2UsIHZhbHVlXVxuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBjb25zdCB1c2VFbWl0dGVyVmFsdWUyID0gUmVhY3QudmVyc2lvbi5zdGFydHNXaXRoKFwiMThcIikgPyB1c2VFbWl0dGVyVmFsdWUxOCA6IHVzZUVtaXR0ZXJWYWx1ZUxlZ2FjeTtcbiAgY29uc3QgdXNlRW1pdHRlcjIgPSAoa2V5LCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpO1xuICAgIGNvbnN0IHNvdXJjZSA9IGNvbnRleHRba2V5XTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0JDEoKCkgPT4gc3Vic2NyaWJlKHNvdXJjZSwgY2FsbGJhY2spLCBbY2FsbGJhY2ssIHNvdXJjZV0pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIENvbXBvbmVudCxcbiAgICB1c2VQdWJsaXNoZXI6IHVzZVB1Ymxpc2hlcjIsXG4gICAgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUyLFxuICAgIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIyXG4gIH07XG59XG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIExvZ0xldmVsID0gLyogQF9fUFVSRV9fICovICgoTG9nTGV2ZWwyKSA9PiB7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICBMb2dMZXZlbDJbTG9nTGV2ZWwyW1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJXQVJOXCJdID0gMl0gPSBcIldBUk5cIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIkVSUk9SXCJdID0gM10gPSBcIkVSUk9SXCI7XG4gIHJldHVybiBMb2dMZXZlbDI7XG59KShMb2dMZXZlbCB8fCB7fSk7XG5jb25zdCBDT05TT0xFX01FVEhPRF9NQVAgPSB7XG4gIFtcbiAgICAwXG4gICAgLyogREVCVUcgKi9cbiAgXTogXCJkZWJ1Z1wiLFxuICBbXG4gICAgMVxuICAgIC8qIElORk8gKi9cbiAgXTogXCJsb2dcIixcbiAgW1xuICAgIDJcbiAgICAvKiBXQVJOICovXG4gIF06IFwid2FyblwiLFxuICBbXG4gICAgM1xuICAgIC8qIEVSUk9SICovXG4gIF06IFwiZXJyb3JcIlxufTtcbmNvbnN0IGdldEdsb2JhbFRoaXMgPSAoKSA9PiB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IGdsb2JhbFRoaXM7XG5jb25zdCBsb2dnZXJTeXN0ZW0gPSBzeXN0ZW0oXG4gICgpID0+IHtcbiAgICBjb25zdCBsb2dMZXZlbCA9IHN0YXRlZnVsU3RyZWFtKFxuICAgICAgM1xuICAgICAgLyogRVJST1IgKi9cbiAgICApO1xuICAgIGNvbnN0IGxvZyA9IHN0YXRlZnVsU3RyZWFtKChsYWJlbCwgbWVzc2FnZSwgbGV2ZWwgPSAxKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSAoX2EgPSBnZXRHbG9iYWxUaGlzKClbXCJWSVJUVU9TT19MT0dfTEVWRUxcIl0pICE9IG51bGwgPyBfYSA6IGdldFZhbHVlKGxvZ0xldmVsKTtcbiAgICAgIGlmIChsZXZlbCA+PSBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgY29uc29sZVtDT05TT0xFX01FVEhPRF9NQVBbbGV2ZWxdXShcbiAgICAgICAgICBcIiVjcmVhY3QtdmlydHVvc286ICVjJXMgJW9cIixcbiAgICAgICAgICBcImNvbG9yOiAjMDI1M2IzOyBmb250LXdlaWdodDogYm9sZFwiLFxuICAgICAgICAgIFwiY29sb3I6IGluaXRpYWxcIixcbiAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvZyxcbiAgICAgIGxvZ0xldmVsXG4gICAgfTtcbiAgfSxcbiAgW10sXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiB1c2VTaXplV2l0aEVsUmVmKGNhbGxiYWNrLCBlbmFibGVkLCBza2lwQW5pbWF0aW9uRnJhbWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBsZXQgY2FsbGJhY2tSZWYgPSAoX2VsKSA9PiB7XG4gIH07XG4gIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICBjb25zdCBjb2RlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbnRyaWVzWzBdLnRhcmdldDtcbiAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2tpcEFuaW1hdGlvbkZyYW1lID8gY29kZSgpIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNvZGUpO1xuICAgICAgfSk7XG4gICAgfSwgW2NhbGxiYWNrXSk7XG4gICAgY2FsbGJhY2tSZWYgPSAoZWxSZWYpID0+IHtcbiAgICAgIGlmIChlbFJlZiAmJiBlbmFibGVkKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWxSZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IGVsUmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICByZXR1cm4geyByZWYsIGNhbGxiYWNrUmVmIH07XG59XG5mdW5jdGlvbiB1c2VTaXplKGNhbGxiYWNrLCBlbmFibGVkLCBza2lwQW5pbWF0aW9uRnJhbWUpIHtcbiAgcmV0dXJuIHVzZVNpemVXaXRoRWxSZWYoY2FsbGJhY2ssIGVuYWJsZWQsIHNraXBBbmltYXRpb25GcmFtZSkuY2FsbGJhY2tSZWY7XG59XG5mdW5jdGlvbiB1c2VDaGFuZ2VkTGlzdENvbnRlbnRzU2l6ZXMoY2FsbGJhY2ssIGl0ZW1TaXplLCBlbmFibGVkLCBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLCBsb2csIGdhcCwgY3VzdG9tU2Nyb2xsUGFyZW50LCBob3Jpem9udGFsRGlyZWN0aW9uLCBza2lwQW5pbWF0aW9uRnJhbWUpIHtcbiAgY29uc3QgbWVtb2VkQ2FsbGJhY2sgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZWwpID0+IHtcbiAgICAgIGNvbnN0IHJhbmdlcyA9IGdldENoYW5nZWRDaGlsZFNpemVzKGVsLmNoaWxkcmVuLCBpdGVtU2l6ZSwgaG9yaXpvbnRhbERpcmVjdGlvbiA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCIsIGxvZyk7XG4gICAgICBsZXQgc2Nyb2xsYWJsZUVsZW1lbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgICAgd2hpbGUgKCFzY3JvbGxhYmxlRWxlbWVudC5kYXRhc2V0W1widmlydHVvc29TY3JvbGxlclwiXSkge1xuICAgICAgICBzY3JvbGxhYmxlRWxlbWVudCA9IHNjcm9sbGFibGVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBjb25zdCB3aW5kb3dTY3JvbGxpbmcgPSBzY3JvbGxhYmxlRWxlbWVudC5sYXN0RWxlbWVudENoaWxkLmRhdGFzZXRbXCJ2aWV3cG9ydFR5cGVcIl0gPT09IFwid2luZG93XCI7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBjdXN0b21TY3JvbGxQYXJlbnQgPyBob3Jpem9udGFsRGlyZWN0aW9uID8gY3VzdG9tU2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgOiBjdXN0b21TY3JvbGxQYXJlbnQuc2Nyb2xsVG9wIDogd2luZG93U2Nyb2xsaW5nID8gaG9yaXpvbnRhbERpcmVjdGlvbiA/IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogaG9yaXpvbnRhbERpcmVjdGlvbiA/IHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbExlZnQgOiBzY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBjdXN0b21TY3JvbGxQYXJlbnQgPyBob3Jpem9udGFsRGlyZWN0aW9uID8gY3VzdG9tU2Nyb2xsUGFyZW50LnNjcm9sbFdpZHRoIDogY3VzdG9tU2Nyb2xsUGFyZW50LnNjcm9sbEhlaWdodCA6IHdpbmRvd1Njcm9sbGluZyA/IGhvcml6b250YWxEaXJlY3Rpb24gPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IDogaG9yaXpvbnRhbERpcmVjdGlvbiA/IHNjcm9sbGFibGVFbGVtZW50LnNjcm9sbFdpZHRoIDogc2Nyb2xsYWJsZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBjdXN0b21TY3JvbGxQYXJlbnQgPyBob3Jpem9udGFsRGlyZWN0aW9uID8gY3VzdG9tU2Nyb2xsUGFyZW50Lm9mZnNldFdpZHRoIDogY3VzdG9tU2Nyb2xsUGFyZW50Lm9mZnNldEhlaWdodCA6IHdpbmRvd1Njcm9sbGluZyA/IGhvcml6b250YWxEaXJlY3Rpb24gPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHdpbmRvdy5pbm5lckhlaWdodCA6IGhvcml6b250YWxEaXJlY3Rpb24gPyBzY3JvbGxhYmxlRWxlbWVudC5vZmZzZXRXaWR0aCA6IHNjcm9sbGFibGVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2soe1xuICAgICAgICBzY3JvbGxUb3A6IE1hdGgubWF4KHNjcm9sbFRvcCwgMCksXG4gICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgdmlld3BvcnRIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgZ2FwID09IG51bGwgPyB2b2lkIDAgOiBnYXAoXG4gICAgICAgIGhvcml6b250YWxEaXJlY3Rpb24gPyByZXNvbHZlR2FwVmFsdWUkMShcImNvbHVtbi1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkuY29sdW1uR2FwLCBsb2cpIDogcmVzb2x2ZUdhcFZhbHVlJDEoXCJyb3ctZ2FwXCIsIGdldENvbXB1dGVkU3R5bGUoZWwpLnJvd0dhcCwgbG9nKVxuICAgICAgKTtcbiAgICAgIGlmIChyYW5nZXMgIT09IG51bGwpIHtcbiAgICAgICAgY2FsbGJhY2socmFuZ2VzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtjYWxsYmFjaywgaXRlbVNpemUsIGxvZywgZ2FwLCBjdXN0b21TY3JvbGxQYXJlbnQsIHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2tdXG4gICk7XG4gIHJldHVybiB1c2VTaXplV2l0aEVsUmVmKG1lbW9lZENhbGxiYWNrLCBlbmFibGVkLCBza2lwQW5pbWF0aW9uRnJhbWUpO1xufVxuZnVuY3Rpb24gZ2V0Q2hhbmdlZENoaWxkU2l6ZXMoY2hpbGRyZW4sIGl0ZW1TaXplLCBmaWVsZCwgbG9nKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW4uaXRlbShpKTtcbiAgICBpZiAoIWNoaWxkIHx8IGNoaWxkLmRhdGFzZXQuaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY2hpbGQuZGF0YXNldC5pbmRleCk7XG4gICAgY29uc3Qga25vd25TaXplID0gcGFyc2VGbG9hdChjaGlsZC5kYXRhc2V0Lmtub3duU2l6ZSk7XG4gICAgY29uc3Qgc2l6ZSA9IGl0ZW1TaXplKGNoaWxkLCBmaWVsZCk7XG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIGxvZyhcIlplcm8tc2l6ZWQgZWxlbWVudCwgdGhpcyBzaG91bGQgbm90IGhhcHBlblwiLCB7IGNoaWxkIH0sIExvZ0xldmVsLkVSUk9SKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPT09IGtub3duU2l6ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RSZXN1bHQgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwIHx8IGxhc3RSZXN1bHQuc2l6ZSAhPT0gc2l6ZSB8fCBsYXN0UmVzdWx0LmVuZEluZGV4ICE9PSBpbmRleCAtIDEpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7IHN0YXJ0SW5kZXg6IGluZGV4LCBlbmRJbmRleDogaW5kZXgsIHNpemUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS5lbmRJbmRleCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVHYXBWYWx1ZSQxKHByb3BlcnR5LCB2YWx1ZSwgbG9nKSB7XG4gIGlmICh2YWx1ZSAhPT0gXCJub3JtYWxcIiAmJiAhKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5lbmRzV2l0aChcInB4XCIpKSkge1xuICAgIGxvZyhgJHtwcm9wZXJ0eX0gd2FzIG5vdCByZXNvbHZlZCB0byBwaXhlbCB2YWx1ZSBjb3JyZWN0bHlgLCB2YWx1ZSwgTG9nTGV2ZWwuV0FSTik7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiMFwiLCAxMCk7XG59XG5mdW5jdGlvbiBjb3JyZWN0SXRlbVNpemUoZWwsIGRpbWVuc2lvbikge1xuICByZXR1cm4gTWF0aC5yb3VuZChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dKTtcbn1cbmZ1bmN0aW9uIGFwcHJveGltYXRlbHlFcXVhbChudW0xLCBudW0yKSB7XG4gIHJldHVybiBNYXRoLmFicyhudW0xIC0gbnVtMikgPCAxLjAxO1xufVxuZnVuY3Rpb24gdXNlU2Nyb2xsVG9wKHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2ssIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQsIHNjcm9sbGVyRWxlbWVudCwgc2Nyb2xsZXJSZWZDYWxsYmFjayA9IG5vb3AsIGN1c3RvbVNjcm9sbFBhcmVudCwgaG9yaXpvbnRhbERpcmVjdGlvbikge1xuICBjb25zdCBzY3JvbGxlclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgc2Nyb2xsVG9wVGFyZ2V0ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBoYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2KSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGV2LnRhcmdldDtcbiAgICAgIGNvbnN0IHdpbmRvd1Njcm9sbCA9IGVsID09PSB3aW5kb3cgfHwgZWwgPT09IGRvY3VtZW50O1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gaG9yaXpvbnRhbERpcmVjdGlvbiA/IHdpbmRvd1Njcm9sbCA/IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IGVsLnNjcm9sbExlZnQgOiB3aW5kb3dTY3JvbGwgPyB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IGVsLnNjcm9sbFRvcDtcbiAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IGhvcml6b250YWxEaXJlY3Rpb24gPyB3aW5kb3dTY3JvbGwgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggOiBlbC5zY3JvbGxXaWR0aCA6IHdpbmRvd1Njcm9sbCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgOiBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IGhvcml6b250YWxEaXJlY3Rpb24gPyB3aW5kb3dTY3JvbGwgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IGVsLm9mZnNldFdpZHRoIDogd2luZG93U2Nyb2xsID8gd2luZG93LmlubmVySGVpZ2h0IDogZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgY29uc3QgY2FsbDIgPSAoKSA9PiB7XG4gICAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2soe1xuICAgICAgICAgIHNjcm9sbFRvcDogTWF0aC5tYXgoc2Nyb2xsVG9wLCAwKSxcbiAgICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgICAgdmlld3BvcnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgaWYgKGV2LnN1cHByZXNzRmx1c2hTeW5jKSB7XG4gICAgICAgIGNhbGwyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoY2FsbDIpO1xuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbFRvcFRhcmdldC5jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzY3JvbGxUb3AgPT09IHNjcm9sbFRvcFRhcmdldC5jdXJyZW50IHx8IHNjcm9sbFRvcCA8PSAwIHx8IHNjcm9sbFRvcCA9PT0gc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnRIZWlnaHQpIHtcbiAgICAgICAgICBzY3JvbGxUb3BUYXJnZXQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCh0cnVlKTtcbiAgICAgICAgICBpZiAodGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjaywgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZF1cbiAgKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2NhbFJlZiA9IGN1c3RvbVNjcm9sbFBhcmVudCA/IGN1c3RvbVNjcm9sbFBhcmVudCA6IHNjcm9sbGVyUmVmLmN1cnJlbnQ7XG4gICAgc2Nyb2xsZXJSZWZDYWxsYmFjayhjdXN0b21TY3JvbGxQYXJlbnQgPyBjdXN0b21TY3JvbGxQYXJlbnQgOiBzY3JvbGxlclJlZi5jdXJyZW50KTtcbiAgICBoYW5kbGVyKHsgdGFyZ2V0OiBsb2NhbFJlZiwgc3VwcHJlc3NGbHVzaFN5bmM6IHRydWUgfSk7XG4gICAgbG9jYWxSZWYuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNjcm9sbGVyUmVmQ2FsbGJhY2sobnVsbCk7XG4gICAgICBsb2NhbFJlZi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZXIpO1xuICAgIH07XG4gIH0sIFtzY3JvbGxlclJlZiwgaGFuZGxlciwgc2Nyb2xsZXJFbGVtZW50LCBzY3JvbGxlclJlZkNhbGxiYWNrLCBjdXN0b21TY3JvbGxQYXJlbnRdKTtcbiAgZnVuY3Rpb24gc2Nyb2xsVG9DYWxsYmFjayhsb2NhdGlvbikge1xuICAgIGNvbnN0IHNjcm9sbGVyRWxlbWVudDIgPSBzY3JvbGxlclJlZi5jdXJyZW50O1xuICAgIGlmICghc2Nyb2xsZXJFbGVtZW50MiB8fCAoaG9yaXpvbnRhbERpcmVjdGlvbiA/IFwib2Zmc2V0V2lkdGhcIiBpbiBzY3JvbGxlckVsZW1lbnQyICYmIHNjcm9sbGVyRWxlbWVudDIub2Zmc2V0V2lkdGggPT09IDAgOiBcIm9mZnNldEhlaWdodFwiIGluIHNjcm9sbGVyRWxlbWVudDIgJiYgc2Nyb2xsZXJFbGVtZW50Mi5vZmZzZXRIZWlnaHQgPT09IDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzU21vb3RoID0gbG9jYXRpb24uYmVoYXZpb3IgPT09IFwic21vb3RoXCI7XG4gICAgbGV0IG9mZnNldEhlaWdodDtcbiAgICBsZXQgc2Nyb2xsSGVpZ2h0O1xuICAgIGxldCBzY3JvbGxUb3A7XG4gICAgaWYgKHNjcm9sbGVyRWxlbWVudDIgPT09IHdpbmRvdykge1xuICAgICAgc2Nyb2xsSGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgIGNvcnJlY3RJdGVtU2l6ZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGhvcml6b250YWxEaXJlY3Rpb24gPyBcIndpZHRoXCIgOiBcImhlaWdodFwiKSxcbiAgICAgICAgaG9yaXpvbnRhbERpcmVjdGlvbiA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICAgICk7XG4gICAgICBvZmZzZXRIZWlnaHQgPSBob3Jpem9udGFsRGlyZWN0aW9uID8gd2luZG93LmlubmVyV2lkdGggOiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBzY3JvbGxUb3AgPSBob3Jpem9udGFsRGlyZWN0aW9uID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxIZWlnaHQgPSBzY3JvbGxlckVsZW1lbnQyW2hvcml6b250YWxEaXJlY3Rpb24gPyBcInNjcm9sbFdpZHRoXCIgOiBcInNjcm9sbEhlaWdodFwiXTtcbiAgICAgIG9mZnNldEhlaWdodCA9IGNvcnJlY3RJdGVtU2l6ZShzY3JvbGxlckVsZW1lbnQyLCBob3Jpem9udGFsRGlyZWN0aW9uID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIik7XG4gICAgICBzY3JvbGxUb3AgPSBzY3JvbGxlckVsZW1lbnQyW2hvcml6b250YWxEaXJlY3Rpb24gPyBcInNjcm9sbExlZnRcIiA6IFwic2Nyb2xsVG9wXCJdO1xuICAgIH1cbiAgICBjb25zdCBtYXhTY3JvbGxUb3AgPSBzY3JvbGxIZWlnaHQgLSBvZmZzZXRIZWlnaHQ7XG4gICAgbG9jYXRpb24udG9wID0gTWF0aC5jZWlsKE1hdGgubWF4KE1hdGgubWluKG1heFNjcm9sbFRvcCwgbG9jYXRpb24udG9wKSwgMCkpO1xuICAgIGlmIChhcHByb3hpbWF0ZWx5RXF1YWwob2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQpIHx8IGxvY2F0aW9uLnRvcCA9PT0gc2Nyb2xsVG9wKSB7XG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrKHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIHZpZXdwb3J0SGVpZ2h0OiBvZmZzZXRIZWlnaHQgfSk7XG4gICAgICBpZiAoaXNTbW9vdGgpIHtcbiAgICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzU21vb3RoKSB7XG4gICAgICBzY3JvbGxUb3BUYXJnZXQuY3VycmVudCA9IGxvY2F0aW9uLnRvcDtcbiAgICAgIGlmICh0aW1lb3V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgc2Nyb2xsVG9wVGFyZ2V0LmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkKHRydWUpO1xuICAgICAgfSwgMWUzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsVG9wVGFyZ2V0LmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoaG9yaXpvbnRhbERpcmVjdGlvbikge1xuICAgICAgbG9jYXRpb24gPSB7IGxlZnQ6IGxvY2F0aW9uLnRvcCwgYmVoYXZpb3I6IGxvY2F0aW9uLmJlaGF2aW9yIH07XG4gICAgfVxuICAgIHNjcm9sbGVyRWxlbWVudDIuc2Nyb2xsVG8obG9jYXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIHNjcm9sbEJ5Q2FsbGJhY2sobG9jYXRpb24pIHtcbiAgICBpZiAoaG9yaXpvbnRhbERpcmVjdGlvbikge1xuICAgICAgbG9jYXRpb24gPSB7IGxlZnQ6IGxvY2F0aW9uLnRvcCwgYmVoYXZpb3I6IGxvY2F0aW9uLmJlaGF2aW9yIH07XG4gICAgfVxuICAgIHNjcm9sbGVyUmVmLmN1cnJlbnQuc2Nyb2xsQnkobG9jYXRpb24pO1xuICB9XG4gIHJldHVybiB7IHNjcm9sbGVyUmVmLCBzY3JvbGxCeUNhbGxiYWNrLCBzY3JvbGxUb0NhbGxiYWNrIH07XG59XG5jb25zdCBkb21JT1N5c3RlbSA9IHN5c3RlbShcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2Nyb2xsVG9wID0gc3RyZWFtKCk7XG4gICAgY29uc3QgZGV2aWF0aW9uID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHN0YXRlZnVsU2Nyb2xsVG9wID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBoZWFkZXJIZWlnaHQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBmaXhlZEhlYWRlckhlaWdodCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGZpeGVkRm9vdGVySGVpZ2h0ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgZm9vdGVySGVpZ2h0ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgc2Nyb2xsVG8gPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzY3JvbGxCeSA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHNjcm9sbGluZ0luUHJvZ3Jlc3MgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgaG9yaXpvbnRhbERpcmVjdGlvbiA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25zdCBza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBzY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgICAgbWFwKCh7IHNjcm9sbFRvcDogc2Nyb2xsVG9wMiB9KSA9PiBzY3JvbGxUb3AyKVxuICAgICAgKSxcbiAgICAgIHNjcm9sbFRvcFxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlLFxuICAgICAgICBtYXAoKHsgc2Nyb2xsSGVpZ2h0OiBzY3JvbGxIZWlnaHQyIH0pID0+IHNjcm9sbEhlaWdodDIpXG4gICAgICApLFxuICAgICAgc2Nyb2xsSGVpZ2h0XG4gICAgKTtcbiAgICBjb25uZWN0KHNjcm9sbFRvcCwgc3RhdGVmdWxTY3JvbGxUb3ApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgICBzY3JvbGxUb3AsXG4gICAgICB2aWV3cG9ydEhlaWdodCxcbiAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgIGZpeGVkSGVhZGVySGVpZ2h0LFxuICAgICAgZml4ZWRGb290ZXJIZWlnaHQsXG4gICAgICBmb290ZXJIZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkLFxuICAgICAgaG9yaXpvbnRhbERpcmVjdGlvbixcbiAgICAgIHNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXIsXG4gICAgICAvLyBzaWduYWxzXG4gICAgICBzY3JvbGxUbyxcbiAgICAgIHNjcm9sbEJ5LFxuICAgICAgLy8gc3RhdGVcbiAgICAgIHN0YXRlZnVsU2Nyb2xsVG9wLFxuICAgICAgZGV2aWF0aW9uLFxuICAgICAgc2Nyb2xsaW5nSW5Qcm9ncmVzc1xuICAgIH07XG4gIH0sXG4gIFtdLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3QgTklMX05PREUgPSB7IGx2bDogMCB9O1xuZnVuY3Rpb24gbmV3QUFOb2RlKGssIHYsIGx2bCwgbCA9IE5JTF9OT0RFLCByID0gTklMX05PREUpIHtcbiAgcmV0dXJuIHsgaywgdiwgbHZsLCBsLCByIH07XG59XG5mdW5jdGlvbiBlbXB0eShub2RlKSB7XG4gIHJldHVybiBub2RlID09PSBOSUxfTk9ERTtcbn1cbmZ1bmN0aW9uIG5ld1RyZWUoKSB7XG4gIHJldHVybiBOSUxfTk9ERTtcbn1cbmZ1bmN0aW9uIHJlbW92ZShub2RlLCBrZXkpIHtcbiAgaWYgKGVtcHR5KG5vZGUpKSByZXR1cm4gTklMX05PREU7XG4gIGNvbnN0IHsgaywgbCwgciB9ID0gbm9kZTtcbiAgaWYgKGtleSA9PT0gaykge1xuICAgIGlmIChlbXB0eShsKSkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSBlbHNlIGlmIChlbXB0eShyKSkge1xuICAgICAgcmV0dXJuIGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtsYXN0S2V5LCBsYXN0VmFsdWVdID0gbGFzdChsKTtcbiAgICAgIHJldHVybiBhZGp1c3QoY2xvbmUobm9kZSwgeyBrOiBsYXN0S2V5LCB2OiBsYXN0VmFsdWUsIGw6IGRlbGV0ZUxhc3QobCkgfSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChrZXkgPCBrKSB7XG4gICAgcmV0dXJuIGFkanVzdChjbG9uZShub2RlLCB7IGw6IHJlbW92ZShsLCBrZXkpIH0pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYWRqdXN0KGNsb25lKG5vZGUsIHsgcjogcmVtb3ZlKHIsIGtleSkgfSkpO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kKG5vZGUsIGtleSkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGtleSA9PT0gbm9kZS5rKSB7XG4gICAgcmV0dXJuIG5vZGUudjtcbiAgfSBlbHNlIGlmIChrZXkgPCBub2RlLmspIHtcbiAgICByZXR1cm4gZmluZChub2RlLmwsIGtleSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmQobm9kZS5yLCBrZXkpO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kTWF4S2V5VmFsdWUobm9kZSwgdmFsdWUsIGZpZWxkID0gXCJrXCIpIHtcbiAgaWYgKGVtcHR5KG5vZGUpKSB7XG4gICAgcmV0dXJuIFstSW5maW5pdHksIHZvaWQgMF07XG4gIH1cbiAgaWYgKE51bWJlcihub2RlW2ZpZWxkXSkgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIFtub2RlLmssIG5vZGUudl07XG4gIH1cbiAgaWYgKE51bWJlcihub2RlW2ZpZWxkXSkgPCB2YWx1ZSkge1xuICAgIGNvbnN0IHIgPSBmaW5kTWF4S2V5VmFsdWUobm9kZS5yLCB2YWx1ZSwgZmllbGQpO1xuICAgIGlmIChyWzBdID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBbbm9kZS5rLCBub2RlLnZdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbmRNYXhLZXlWYWx1ZShub2RlLmwsIHZhbHVlLCBmaWVsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnQobm9kZSwgaywgdikge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gbmV3QUFOb2RlKGssIHYsIDEpO1xuICB9XG4gIGlmIChrID09PSBub2RlLmspIHtcbiAgICByZXR1cm4gY2xvbmUobm9kZSwgeyBrLCB2IH0pO1xuICB9IGVsc2UgaWYgKGsgPCBub2RlLmspIHtcbiAgICByZXR1cm4gcmViYWxhbmNlKGNsb25lKG5vZGUsIHsgbDogaW5zZXJ0KG5vZGUubCwgaywgdikgfSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWJhbGFuY2UoY2xvbmUobm9kZSwgeyByOiBpbnNlcnQobm9kZS5yLCBrLCB2KSB9KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhbGtXaXRoaW4obm9kZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgeyBrLCB2LCBsLCByIH0gPSBub2RlO1xuICBsZXQgcmVzdWx0ID0gW107XG4gIGlmIChrID4gc3RhcnQpIHtcbiAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHdhbGtXaXRoaW4obCwgc3RhcnQsIGVuZCkpO1xuICB9XG4gIGlmIChrID49IHN0YXJ0ICYmIGsgPD0gZW5kKSB7XG4gICAgcmVzdWx0LnB1c2goeyBrLCB2IH0pO1xuICB9XG4gIGlmIChrIDw9IGVuZCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQod2Fsa1dpdGhpbihyLCBzdGFydCwgZW5kKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFsuLi53YWxrKG5vZGUubCksIHsgazogbm9kZS5rLCB2OiBub2RlLnYgfSwgLi4ud2Fsayhub2RlLnIpXTtcbn1cbmZ1bmN0aW9uIGxhc3Qobm9kZSkge1xuICByZXR1cm4gZW1wdHkobm9kZS5yKSA/IFtub2RlLmssIG5vZGUudl0gOiBsYXN0KG5vZGUucik7XG59XG5mdW5jdGlvbiBkZWxldGVMYXN0KG5vZGUpIHtcbiAgcmV0dXJuIGVtcHR5KG5vZGUucikgPyBub2RlLmwgOiBhZGp1c3QoY2xvbmUobm9kZSwgeyByOiBkZWxldGVMYXN0KG5vZGUucikgfSkpO1xufVxuZnVuY3Rpb24gY2xvbmUobm9kZSwgYXJncykge1xuICByZXR1cm4gbmV3QUFOb2RlKFxuICAgIGFyZ3MuayAhPT0gdm9pZCAwID8gYXJncy5rIDogbm9kZS5rLFxuICAgIGFyZ3MudiAhPT0gdm9pZCAwID8gYXJncy52IDogbm9kZS52LFxuICAgIGFyZ3MubHZsICE9PSB2b2lkIDAgPyBhcmdzLmx2bCA6IG5vZGUubHZsLFxuICAgIGFyZ3MubCAhPT0gdm9pZCAwID8gYXJncy5sIDogbm9kZS5sLFxuICAgIGFyZ3MuciAhPT0gdm9pZCAwID8gYXJncy5yIDogbm9kZS5yXG4gICk7XG59XG5mdW5jdGlvbiBpc1NpbmdsZShub2RlKSB7XG4gIHJldHVybiBlbXB0eShub2RlKSB8fCBub2RlLmx2bCA+IG5vZGUuci5sdmw7XG59XG5mdW5jdGlvbiByZWJhbGFuY2Uobm9kZSkge1xuICByZXR1cm4gc3BsaXQoc2tldyhub2RlKSk7XG59XG5mdW5jdGlvbiBhZGp1c3Qobm9kZSkge1xuICBjb25zdCB7IGwsIHIsIGx2bCB9ID0gbm9kZTtcbiAgaWYgKHIubHZsID49IGx2bCAtIDEgJiYgbC5sdmwgPj0gbHZsIC0gMSkge1xuICAgIHJldHVybiBub2RlO1xuICB9IGVsc2UgaWYgKGx2bCA+IHIubHZsICsgMSkge1xuICAgIGlmIChpc1NpbmdsZShsKSkge1xuICAgICAgcmV0dXJuIHNrZXcoY2xvbmUobm9kZSwgeyBsdmw6IGx2bCAtIDEgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWVtcHR5KGwpICYmICFlbXB0eShsLnIpKSB7XG4gICAgICAgIHJldHVybiBjbG9uZShsLnIsIHtcbiAgICAgICAgICBsOiBjbG9uZShsLCB7IHI6IGwuci5sIH0pLFxuICAgICAgICAgIHI6IGNsb25lKG5vZGUsIHtcbiAgICAgICAgICAgIGw6IGwuci5yLFxuICAgICAgICAgICAgbHZsOiBsdmwgLSAxXG4gICAgICAgICAgfSksXG4gICAgICAgICAgbHZsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBub2Rlc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzU2luZ2xlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gc3BsaXQoY2xvbmUobm9kZSwgeyBsdmw6IGx2bCAtIDEgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWVtcHR5KHIpICYmICFlbXB0eShyLmwpKSB7XG4gICAgICAgIGNvbnN0IHJsID0gci5sO1xuICAgICAgICBjb25zdCBybHZsID0gaXNTaW5nbGUocmwpID8gci5sdmwgLSAxIDogci5sdmw7XG4gICAgICAgIHJldHVybiBjbG9uZShybCwge1xuICAgICAgICAgIGw6IGNsb25lKG5vZGUsIHtcbiAgICAgICAgICAgIHI6IHJsLmwsXG4gICAgICAgICAgICBsdmw6IGx2bCAtIDFcbiAgICAgICAgICB9KSxcbiAgICAgICAgICByOiBzcGxpdChjbG9uZShyLCB7IGw6IHJsLnIsIGx2bDogcmx2bCB9KSksXG4gICAgICAgICAgbHZsOiBybC5sdmwgKyAxXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlbXB0eSBub2Rlc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJhbmdlc1dpdGhpbihub2RlLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICBpZiAoZW1wdHkobm9kZSkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgYWRqdXN0ZWRTdGFydCA9IGZpbmRNYXhLZXlWYWx1ZShub2RlLCBzdGFydEluZGV4KVswXTtcbiAgcmV0dXJuIHRvUmFuZ2VzKHdhbGtXaXRoaW4obm9kZSwgYWRqdXN0ZWRTdGFydCwgZW5kSW5kZXgpKTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9SYW5nZXMoaXRlbXMsIHBhcnNlcikge1xuICBjb25zdCBsZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbGV0IHsgaW5kZXg6IHN0YXJ0LCB2YWx1ZSB9ID0gcGFyc2VyKGl0ZW1zWzBdKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7IGluZGV4OiBuZXh0SW5kZXgsIHZhbHVlOiBuZXh0VmFsdWUgfSA9IHBhcnNlcihpdGVtc1tpXSk7XG4gICAgcmVzdWx0LnB1c2goeyBzdGFydCwgZW5kOiBuZXh0SW5kZXggLSAxLCB2YWx1ZSB9KTtcbiAgICBzdGFydCA9IG5leHRJbmRleDtcbiAgICB2YWx1ZSA9IG5leHRWYWx1ZTtcbiAgfVxuICByZXN1bHQucHVzaCh7IHN0YXJ0LCBlbmQ6IEluZmluaXR5LCB2YWx1ZSB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvUmFuZ2VzKG5vZGVzKSB7XG4gIHJldHVybiBhcnJheVRvUmFuZ2VzKG5vZGVzLCAoeyBrOiBpbmRleCwgdjogdmFsdWUgfSkgPT4gKHsgaW5kZXgsIHZhbHVlIH0pKTtcbn1cbmZ1bmN0aW9uIHNwbGl0KG5vZGUpIHtcbiAgY29uc3QgeyByLCBsdmwgfSA9IG5vZGU7XG4gIHJldHVybiAhZW1wdHkocikgJiYgIWVtcHR5KHIucikgJiYgci5sdmwgPT09IGx2bCAmJiByLnIubHZsID09PSBsdmwgPyBjbG9uZShyLCB7IGw6IGNsb25lKG5vZGUsIHsgcjogci5sIH0pLCBsdmw6IGx2bCArIDEgfSkgOiBub2RlO1xufVxuZnVuY3Rpb24gc2tldyhub2RlKSB7XG4gIGNvbnN0IHsgbCB9ID0gbm9kZTtcbiAgcmV0dXJuICFlbXB0eShsKSAmJiBsLmx2bCA9PT0gbm9kZS5sdmwgPyBjbG9uZShsLCB7IHI6IGNsb25lKG5vZGUsIHsgbDogbC5yIH0pIH0pIDogbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmRJbmRleE9mQ2xvc2VzdFNtYWxsZXJPckVxdWFsKGl0ZW1zLCB2YWx1ZSwgY29tcGFyYXRvciwgc3RhcnQgPSAwKSB7XG4gIGxldCBlbmQgPSBpdGVtcy5sZW5ndGggLSAxO1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICBjb25zdCBpdGVtID0gaXRlbXNbaW5kZXhdO1xuICAgIGNvbnN0IG1hdGNoID0gY29tcGFyYXRvcihpdGVtLCB2YWx1ZSk7XG4gICAgaWYgKG1hdGNoID09PSAwKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGlmIChtYXRjaCA9PT0gLTEpIHtcbiAgICAgIGlmIChlbmQgLSBzdGFydCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGluZGV4IC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBpbmRleCArIDE7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIGJpbmFyeSBmaW5kaW5nIHJlY29yZCBpbiBhcnJheSAtICR7aXRlbXMuam9pbihcIixcIil9LCBzZWFyY2hlZCBmb3IgJHt2YWx1ZX1gKTtcbn1cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0U21hbGxlck9yRXF1YWwoaXRlbXMsIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHJldHVybiBpdGVtc1tmaW5kSW5kZXhPZkNsb3Nlc3RTbWFsbGVyT3JFcXVhbChpdGVtcywgdmFsdWUsIGNvbXBhcmF0b3IpXTtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpdGVtcywgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgY29uc3Qgc3RhcnRJbmRleCA9IGZpbmRJbmRleE9mQ2xvc2VzdFNtYWxsZXJPckVxdWFsKGl0ZW1zLCBzdGFydFZhbHVlLCBjb21wYXJhdG9yKTtcbiAgY29uc3QgZW5kSW5kZXggPSBmaW5kSW5kZXhPZkNsb3Nlc3RTbWFsbGVyT3JFcXVhbChpdGVtcywgZW5kVmFsdWUsIGNvbXBhcmF0b3IsIHN0YXJ0SW5kZXgpO1xuICByZXR1cm4gaXRlbXMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXggKyAxKTtcbn1cbmNvbnN0IHJlY2FsY1N5c3RlbSA9IHN5c3RlbShcbiAgKCkgPT4ge1xuICAgIGNvbnN0IHJlY2FsY0luUHJvZ3Jlc3MgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgcmV0dXJuIHsgcmVjYWxjSW5Qcm9ncmVzcyB9O1xuICB9LFxuICBbXSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHJhbmdlSW5jbHVkZXMocmVmUmFuZ2UpIHtcbiAgY29uc3QgeyBzaXplLCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmVmUmFuZ2U7XG4gIHJldHVybiAocmFuZ2UpID0+IHtcbiAgICByZXR1cm4gcmFuZ2Uuc3RhcnQgPT09IHN0YXJ0SW5kZXggJiYgKHJhbmdlLmVuZCA9PT0gZW5kSW5kZXggfHwgcmFuZ2UuZW5kID09PSBJbmZpbml0eSkgJiYgcmFuZ2UudmFsdWUgPT09IHNpemU7XG4gIH07XG59XG5mdW5jdGlvbiBhZmZlY3RlZEdyb3VwQ291bnQob2Zmc2V0LCBncm91cEluZGljZXMpIHtcbiAgbGV0IHJlY29nbml6ZWRPZmZzZXRJdGVtcyA9IDA7XG4gIGxldCBncm91cEluZGV4ID0gMDtcbiAgd2hpbGUgKHJlY29nbml6ZWRPZmZzZXRJdGVtcyA8IG9mZnNldCkge1xuICAgIHJlY29nbml6ZWRPZmZzZXRJdGVtcyArPSBncm91cEluZGljZXNbZ3JvdXBJbmRleCArIDFdIC0gZ3JvdXBJbmRpY2VzW2dyb3VwSW5kZXhdIC0gMTtcbiAgICBncm91cEluZGV4Kys7XG4gIH1cbiAgY29uc3Qgb2Zmc2V0SXNFeGFjdCA9IHJlY29nbml6ZWRPZmZzZXRJdGVtcyA9PT0gb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXBJbmRleCAtIChvZmZzZXRJc0V4YWN0ID8gMCA6IDEpO1xufVxuZnVuY3Rpb24gaW5zZXJ0UmFuZ2VzKHNpemVUcmVlLCByYW5nZXMpIHtcbiAgbGV0IHN5bmNTdGFydCA9IGVtcHR5KHNpemVUcmVlKSA/IDAgOiBJbmZpbml0eTtcbiAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXMpIHtcbiAgICBjb25zdCB7IHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBzeW5jU3RhcnQgPSBNYXRoLm1pbihzeW5jU3RhcnQsIHN0YXJ0SW5kZXgpO1xuICAgIGlmIChlbXB0eShzaXplVHJlZSkpIHtcbiAgICAgIHNpemVUcmVlID0gaW5zZXJ0KHNpemVUcmVlLCAwLCBzaXplKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvdmVybGFwcGluZ1JhbmdlcyA9IHJhbmdlc1dpdGhpbihzaXplVHJlZSwgc3RhcnRJbmRleCAtIDEsIGVuZEluZGV4ICsgMSk7XG4gICAgaWYgKG92ZXJsYXBwaW5nUmFuZ2VzLnNvbWUocmFuZ2VJbmNsdWRlcyhyYW5nZSkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IGZpcnN0UGFzc0RvbmUgPSBmYWxzZTtcbiAgICBsZXQgc2hvdWxkSW5zZXJ0ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB7IHN0YXJ0OiByYW5nZVN0YXJ0LCBlbmQ6IHJhbmdlRW5kLCB2YWx1ZTogcmFuZ2VWYWx1ZSB9IG9mIG92ZXJsYXBwaW5nUmFuZ2VzKSB7XG4gICAgICBpZiAoIWZpcnN0UGFzc0RvbmUpIHtcbiAgICAgICAgc2hvdWxkSW5zZXJ0ID0gcmFuZ2VWYWx1ZSAhPT0gc2l6ZTtcbiAgICAgICAgZmlyc3RQYXNzRG9uZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZW5kSW5kZXggPj0gcmFuZ2VTdGFydCB8fCBzaXplID09PSByYW5nZVZhbHVlKSB7XG4gICAgICAgICAgc2l6ZVRyZWUgPSByZW1vdmUoc2l6ZVRyZWUsIHJhbmdlU3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2VFbmQgPiBlbmRJbmRleCAmJiBlbmRJbmRleCA+PSByYW5nZVN0YXJ0KSB7XG4gICAgICAgIGlmIChyYW5nZVZhbHVlICE9PSBzaXplKSB7XG4gICAgICAgICAgc2l6ZVRyZWUgPSBpbnNlcnQoc2l6ZVRyZWUsIGVuZEluZGV4ICsgMSwgcmFuZ2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZEluc2VydCkge1xuICAgICAgc2l6ZVRyZWUgPSBpbnNlcnQoc2l6ZVRyZWUsIHN0YXJ0SW5kZXgsIHNpemUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3NpemVUcmVlLCBzeW5jU3RhcnRdO1xufVxuZnVuY3Rpb24gaW5pdGlhbFNpemVTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBvZmZzZXRUcmVlOiBbXSxcbiAgICBzaXplVHJlZTogbmV3VHJlZSgpLFxuICAgIGdyb3VwT2Zmc2V0VHJlZTogbmV3VHJlZSgpLFxuICAgIGxhc3RJbmRleDogMCxcbiAgICBsYXN0T2Zmc2V0OiAwLFxuICAgIGxhc3RTaXplOiAwLFxuICAgIGdyb3VwSW5kaWNlczogW11cbiAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4Q29tcGFyYXRvcih7IGluZGV4OiBpdGVtSW5kZXggfSwgaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ID09PSBpdGVtSW5kZXggPyAwIDogaW5kZXggPCBpdGVtSW5kZXggPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBvZmZzZXRDb21wYXJhdG9yKHsgb2Zmc2V0OiBpdGVtT2Zmc2V0IH0sIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0ID09PSBpdGVtT2Zmc2V0ID8gMCA6IG9mZnNldCA8IGl0ZW1PZmZzZXQgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBvZmZzZXRQb2ludFBhcnNlcihwb2ludCkge1xuICByZXR1cm4geyBpbmRleDogcG9pbnQuaW5kZXgsIHZhbHVlOiBwb2ludCB9O1xufVxuZnVuY3Rpb24gcmFuZ2VzV2l0aGluT2Zmc2V0cyh0cmVlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBtaW5TdGFydEluZGV4ID0gMCkge1xuICBpZiAobWluU3RhcnRJbmRleCA+IDApIHtcbiAgICBzdGFydE9mZnNldCA9IE1hdGgubWF4KHN0YXJ0T2Zmc2V0LCBmaW5kQ2xvc2VzdFNtYWxsZXJPckVxdWFsKHRyZWUsIG1pblN0YXJ0SW5kZXgsIGluZGV4Q29tcGFyYXRvcikub2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gYXJyYXlUb1JhbmdlcyhmaW5kUmFuZ2UodHJlZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgb2Zmc2V0Q29tcGFyYXRvciksIG9mZnNldFBvaW50UGFyc2VyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9mZnNldFRyZWUocHJldk9mZnNldFRyZWUsIHN5bmNTdGFydCwgc2l6ZVRyZWUsIGdhcCkge1xuICBsZXQgb2Zmc2V0VHJlZSA9IHByZXZPZmZzZXRUcmVlO1xuICBsZXQgcHJldkluZGV4ID0gMDtcbiAgbGV0IHByZXZTaXplID0gMDtcbiAgbGV0IHByZXZPZmZzZXQgPSAwO1xuICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gIGlmIChzeW5jU3RhcnQgIT09IDApIHtcbiAgICBzdGFydEluZGV4ID0gZmluZEluZGV4T2ZDbG9zZXN0U21hbGxlck9yRXF1YWwob2Zmc2V0VHJlZSwgc3luY1N0YXJ0IC0gMSwgaW5kZXhDb21wYXJhdG9yKTtcbiAgICBjb25zdCBvZmZzZXRJbmZvID0gb2Zmc2V0VHJlZVtzdGFydEluZGV4XTtcbiAgICBwcmV2T2Zmc2V0ID0gb2Zmc2V0SW5mby5vZmZzZXQ7XG4gICAgY29uc3Qga3YgPSBmaW5kTWF4S2V5VmFsdWUoc2l6ZVRyZWUsIHN5bmNTdGFydCAtIDEpO1xuICAgIHByZXZJbmRleCA9IGt2WzBdO1xuICAgIHByZXZTaXplID0ga3ZbMV07XG4gICAgaWYgKG9mZnNldFRyZWUubGVuZ3RoICYmIG9mZnNldFRyZWVbc3RhcnRJbmRleF0uc2l6ZSA9PT0gZmluZE1heEtleVZhbHVlKHNpemVUcmVlLCBzeW5jU3RhcnQpWzFdKSB7XG4gICAgICBzdGFydEluZGV4IC09IDE7XG4gICAgfVxuICAgIG9mZnNldFRyZWUgPSBvZmZzZXRUcmVlLnNsaWNlKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRUcmVlID0gW107XG4gIH1cbiAgZm9yIChjb25zdCB7IHN0YXJ0OiBzdGFydEluZGV4MiwgdmFsdWUgfSBvZiByYW5nZXNXaXRoaW4oc2l6ZVRyZWUsIHN5bmNTdGFydCwgSW5maW5pdHkpKSB7XG4gICAgY29uc3QgaW5kZXhPZmZzZXQgPSBzdGFydEluZGV4MiAtIHByZXZJbmRleDtcbiAgICBjb25zdCBhT2Zmc2V0ID0gaW5kZXhPZmZzZXQgKiBwcmV2U2l6ZSArIHByZXZPZmZzZXQgKyBpbmRleE9mZnNldCAqIGdhcDtcbiAgICBvZmZzZXRUcmVlLnB1c2goe1xuICAgICAgb2Zmc2V0OiBhT2Zmc2V0LFxuICAgICAgc2l6ZTogdmFsdWUsXG4gICAgICBpbmRleDogc3RhcnRJbmRleDJcbiAgICB9KTtcbiAgICBwcmV2SW5kZXggPSBzdGFydEluZGV4MjtcbiAgICBwcmV2T2Zmc2V0ID0gYU9mZnNldDtcbiAgICBwcmV2U2l6ZSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgb2Zmc2V0VHJlZSxcbiAgICBsYXN0SW5kZXg6IHByZXZJbmRleCxcbiAgICBsYXN0T2Zmc2V0OiBwcmV2T2Zmc2V0LFxuICAgIGxhc3RTaXplOiBwcmV2U2l6ZVxuICB9O1xufVxuZnVuY3Rpb24gc2l6ZVN0YXRlUmVkdWNlcihzdGF0ZSwgW3JhbmdlcywgZ3JvdXBJbmRpY2VzLCBsb2csIGdhcF0pIHtcbiAgaWYgKHJhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgbG9nKFwicmVjZWl2ZWQgaXRlbSBzaXplc1wiLCByYW5nZXMsIExvZ0xldmVsLkRFQlVHKTtcbiAgfVxuICBjb25zdCBzaXplVHJlZSA9IHN0YXRlLnNpemVUcmVlO1xuICBsZXQgbmV3U2l6ZVRyZWUgPSBzaXplVHJlZTtcbiAgbGV0IHN5bmNTdGFydCA9IDA7XG4gIGlmIChncm91cEluZGljZXMubGVuZ3RoID4gMCAmJiBlbXB0eShzaXplVHJlZSkgJiYgcmFuZ2VzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IGdyb3VwU2l6ZSA9IHJhbmdlc1swXS5zaXplO1xuICAgIGNvbnN0IGl0ZW1TaXplID0gcmFuZ2VzWzFdLnNpemU7XG4gICAgbmV3U2l6ZVRyZWUgPSBncm91cEluZGljZXMucmVkdWNlKCh0cmVlLCBncm91cEluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gaW5zZXJ0KGluc2VydCh0cmVlLCBncm91cEluZGV4LCBncm91cFNpemUpLCBncm91cEluZGV4ICsgMSwgaXRlbVNpemUpO1xuICAgIH0sIG5ld1NpemVUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBbbmV3U2l6ZVRyZWUsIHN5bmNTdGFydF0gPSBpbnNlcnRSYW5nZXMobmV3U2l6ZVRyZWUsIHJhbmdlcyk7XG4gIH1cbiAgaWYgKG5ld1NpemVUcmVlID09PSBzaXplVHJlZSkge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBjb25zdCB7IG9mZnNldFRyZWU6IG5ld09mZnNldFRyZWUsIGxhc3RJbmRleCwgbGFzdFNpemUsIGxhc3RPZmZzZXQgfSA9IGNyZWF0ZU9mZnNldFRyZWUoc3RhdGUub2Zmc2V0VHJlZSwgc3luY1N0YXJ0LCBuZXdTaXplVHJlZSwgZ2FwKTtcbiAgcmV0dXJuIHtcbiAgICBzaXplVHJlZTogbmV3U2l6ZVRyZWUsXG4gICAgb2Zmc2V0VHJlZTogbmV3T2Zmc2V0VHJlZSxcbiAgICBsYXN0SW5kZXgsXG4gICAgbGFzdE9mZnNldCxcbiAgICBsYXN0U2l6ZSxcbiAgICBncm91cE9mZnNldFRyZWU6IGdyb3VwSW5kaWNlcy5yZWR1Y2UoKHRyZWUsIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4gaW5zZXJ0KHRyZWUsIGluZGV4LCBvZmZzZXRPZihpbmRleCwgbmV3T2Zmc2V0VHJlZSwgZ2FwKSk7XG4gICAgfSwgbmV3VHJlZSgpKSxcbiAgICBncm91cEluZGljZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIG9mZnNldE9mKGluZGV4LCB0cmVlLCBnYXApIHtcbiAgaWYgKHRyZWUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgeyBvZmZzZXQsIGluZGV4OiBzdGFydEluZGV4LCBzaXplIH0gPSBmaW5kQ2xvc2VzdFNtYWxsZXJPckVxdWFsKHRyZWUsIGluZGV4LCBpbmRleENvbXBhcmF0b3IpO1xuICBjb25zdCBpdGVtQ291bnQgPSBpbmRleCAtIHN0YXJ0SW5kZXg7XG4gIGNvbnN0IHRvcCA9IHNpemUgKiBpdGVtQ291bnQgKyAoaXRlbUNvdW50IC0gMSkgKiBnYXAgKyBvZmZzZXQ7XG4gIHJldHVybiB0b3AgPiAwID8gdG9wICsgZ2FwIDogdG9wO1xufVxuZnVuY3Rpb24gaXNHcm91cExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24uZ3JvdXBJbmRleCAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIG9yaWdpbmFsSW5kZXhGcm9tTG9jYXRpb24obG9jYXRpb24sIHNpemVzLCBsYXN0SW5kZXgpIHtcbiAgaWYgKGlzR3JvdXBMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICByZXR1cm4gc2l6ZXMuZ3JvdXBJbmRpY2VzW2xvY2F0aW9uLmdyb3VwSW5kZXhdICsgMTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBudW1lcmljSW5kZXggPSBsb2NhdGlvbi5pbmRleCA9PT0gXCJMQVNUXCIgPyBsYXN0SW5kZXggOiBsb2NhdGlvbi5pbmRleDtcbiAgICBsZXQgcmVzdWx0ID0gb3JpZ2luYWxJbmRleEZyb21JdGVtSW5kZXgobnVtZXJpY0luZGV4LCBzaXplcyk7XG4gICAgcmVzdWx0ID0gTWF0aC5tYXgoMCwgcmVzdWx0LCBNYXRoLm1pbihsYXN0SW5kZXgsIHJlc3VsdCkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG9yaWdpbmFsSW5kZXhGcm9tSXRlbUluZGV4KGl0ZW1JbmRleCwgc2l6ZXMpIHtcbiAgaWYgKCFoYXNHcm91cHMoc2l6ZXMpKSB7XG4gICAgcmV0dXJuIGl0ZW1JbmRleDtcbiAgfVxuICBsZXQgZ3JvdXBPZmZzZXQgPSAwO1xuICB3aGlsZSAoc2l6ZXMuZ3JvdXBJbmRpY2VzW2dyb3VwT2Zmc2V0XSA8PSBpdGVtSW5kZXggKyBncm91cE9mZnNldCkge1xuICAgIGdyb3VwT2Zmc2V0Kys7XG4gIH1cbiAgcmV0dXJuIGl0ZW1JbmRleCArIGdyb3VwT2Zmc2V0O1xufVxuZnVuY3Rpb24gaGFzR3JvdXBzKHNpemVzKSB7XG4gIHJldHVybiAhZW1wdHkoc2l6ZXMuZ3JvdXBPZmZzZXRUcmVlKTtcbn1cbmZ1bmN0aW9uIHNpemVUcmVlVG9SYW5nZXMoc2l6ZVRyZWUpIHtcbiAgcmV0dXJuIHdhbGsoc2l6ZVRyZWUpLm1hcCgoeyBrOiBzdGFydEluZGV4LCB2OiBzaXplIH0sIGluZGV4LCBzaXplQXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXh0U2l6ZSA9IHNpemVBcnJheVtpbmRleCArIDFdO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gbmV4dFNpemUgPyBuZXh0U2l6ZS5rIC0gMSA6IEluZmluaXR5O1xuICAgIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzaXplIH07XG4gIH0pO1xufVxuY29uc3QgU0laRV9NQVAgPSB7XG4gIG9mZnNldEhlaWdodDogXCJoZWlnaHRcIixcbiAgb2Zmc2V0V2lkdGg6IFwid2lkdGhcIlxufTtcbmNvbnN0IHNpemVTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBsb2cgfSwgeyByZWNhbGNJblByb2dyZXNzIH1dKSA9PiB7XG4gICAgY29uc3Qgc2l6ZVJhbmdlcyA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHRvdGFsQ291bnQgPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzdGF0ZWZ1bFRvdGFsQ291bnQgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKHRvdGFsQ291bnQsIDApO1xuICAgIGNvbnN0IHVuc2hpZnRXaXRoID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2hpZnRXaXRoID0gc3RyZWFtKCk7XG4gICAgY29uc3QgZmlyc3RJdGVtSW5kZXggPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBncm91cEluZGljZXMgPSBzdGF0ZWZ1bFN0cmVhbShbXSk7XG4gICAgY29uc3QgZml4ZWRJdGVtU2l6ZSA9IHN0YXRlZnVsU3RyZWFtKHZvaWQgMCk7XG4gICAgY29uc3QgZGVmYXVsdEl0ZW1TaXplID0gc3RhdGVmdWxTdHJlYW0odm9pZCAwKTtcbiAgICBjb25zdCBpdGVtU2l6ZSA9IHN0YXRlZnVsU3RyZWFtKChlbCwgZmllbGQpID0+IGNvcnJlY3RJdGVtU2l6ZShlbCwgU0laRV9NQVBbZmllbGRdKSk7XG4gICAgY29uc3QgZGF0YSA9IHN0YXRlZnVsU3RyZWFtKHZvaWQgMCk7XG4gICAgY29uc3QgZ2FwID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgaW5pdGlhbCA9IGluaXRpYWxTaXplU3RhdGUoKTtcbiAgICBjb25zdCBzaXplcyA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKHNpemVSYW5nZXMsIHdpdGhMYXRlc3RGcm9tKGdyb3VwSW5kaWNlcywgbG9nLCBnYXApLCBzY2FuKHNpemVTdGF0ZVJlZHVjZXIsIGluaXRpYWwpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKSxcbiAgICAgIGluaXRpYWxcbiAgICApO1xuICAgIGNvbnN0IHByZXZHcm91cEluZGljZXMgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgZ3JvdXBJbmRpY2VzLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgICBzY2FuKChwcmV2LCBjdXJyKSA9PiAoeyBwcmV2OiBwcmV2LmN1cnJlbnQsIGN1cnJlbnQ6IGN1cnIgfSksIHtcbiAgICAgICAgICBwcmV2OiBbXSxcbiAgICAgICAgICBjdXJyZW50OiBbXVxuICAgICAgICB9KSxcbiAgICAgICAgbWFwKCh7IHByZXYgfSkgPT4gcHJldilcbiAgICAgICksXG4gICAgICBbXVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGdyb3VwSW5kaWNlcyxcbiAgICAgICAgZmlsdGVyKChpbmRleGVzKSA9PiBpbmRleGVzLmxlbmd0aCA+IDApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgZ2FwKSxcbiAgICAgICAgbWFwKChbZ3JvdXBJbmRpY2VzMiwgc2l6ZXMyLCBnYXAyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGdyb3VwT2Zmc2V0VHJlZSA9IGdyb3VwSW5kaWNlczIucmVkdWNlKCh0cmVlLCBpbmRleCwgaWR4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0KHRyZWUsIGluZGV4LCBvZmZzZXRPZihpbmRleCwgc2l6ZXMyLm9mZnNldFRyZWUsIGdhcDIpIHx8IGlkeCk7XG4gICAgICAgICAgfSwgbmV3VHJlZSgpKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc2l6ZXMyLFxuICAgICAgICAgICAgZ3JvdXBJbmRpY2VzOiBncm91cEluZGljZXMyLFxuICAgICAgICAgICAgZ3JvdXBPZmZzZXRUcmVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBzaXplc1xuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHRvdGFsQ291bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNpemVzKSxcbiAgICAgICAgZmlsdGVyKChbdG90YWxDb3VudDIsIHsgbGFzdEluZGV4IH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRvdGFsQ291bnQyIDwgbGFzdEluZGV4O1xuICAgICAgICB9KSxcbiAgICAgICAgbWFwKChbdG90YWxDb3VudDIsIHsgbGFzdEluZGV4LCBsYXN0U2l6ZSB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXg6IHRvdGFsQ291bnQyLFxuICAgICAgICAgICAgICBlbmRJbmRleDogbGFzdEluZGV4LFxuICAgICAgICAgICAgICBzaXplOiBsYXN0U2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2l6ZVJhbmdlc1xuICAgICk7XG4gICAgY29ubmVjdChmaXhlZEl0ZW1TaXplLCBkZWZhdWx0SXRlbVNpemUpO1xuICAgIGNvbnN0IHRyYWNrSXRlbVNpemVzID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGZpeGVkSXRlbVNpemUsXG4gICAgICAgIG1hcCgoc2l6ZSkgPT4gc2l6ZSA9PT0gdm9pZCAwKVxuICAgICAgKSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBkZWZhdWx0SXRlbVNpemUsXG4gICAgICAgIGZpbHRlcigodmFsdWUpID0+IHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCAmJiBlbXB0eShnZXRWYWx1ZShzaXplcykuc2l6ZVRyZWUpO1xuICAgICAgICB9KSxcbiAgICAgICAgbWFwKChzaXplKSA9PiBbeyBzdGFydEluZGV4OiAwLCBlbmRJbmRleDogMCwgc2l6ZSB9XSlcbiAgICAgICksXG4gICAgICBzaXplUmFuZ2VzXG4gICAgKTtcbiAgICBjb25zdCBsaXN0UmVmcmVzaCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgc2l6ZVJhbmdlcyxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMpLFxuICAgICAgICBzY2FuKFxuICAgICAgICAgICh7IHNpemVzOiBvbGRTaXplcyB9LCBbXywgbmV3U2l6ZXNdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjaGFuZ2VkOiBuZXdTaXplcyAhPT0gb2xkU2l6ZXMsXG4gICAgICAgICAgICAgIHNpemVzOiBuZXdTaXplc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgY2hhbmdlZDogZmFsc2UsIHNpemVzOiBpbml0aWFsIH1cbiAgICAgICAgKSxcbiAgICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUuY2hhbmdlZClcbiAgICAgIClcbiAgICApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGZpcnN0SXRlbUluZGV4LFxuICAgICAgICBzY2FuKFxuICAgICAgICAgIChwcmV2LCBuZXh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBkaWZmOiBwcmV2LnByZXYgLSBuZXh0LCBwcmV2OiBuZXh0IH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IGRpZmY6IDAsIHByZXY6IDAgfVxuICAgICAgICApLFxuICAgICAgICBtYXAoKHZhbCkgPT4gdmFsLmRpZmYpXG4gICAgICApLFxuICAgICAgKG9mZnNldCkgPT4ge1xuICAgICAgICBjb25zdCB7IGdyb3VwSW5kaWNlczogZ3JvdXBJbmRpY2VzMiB9ID0gZ2V0VmFsdWUoc2l6ZXMpO1xuICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHB1Ymxpc2gocmVjYWxjSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgICAgICAgcHVibGlzaCh1bnNoaWZ0V2l0aCwgb2Zmc2V0ICsgYWZmZWN0ZWRHcm91cENvdW50KG9mZnNldCwgZ3JvdXBJbmRpY2VzMikpO1xuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBjb25zdCBwcmV2R3JvdXBJbmRpY2VzVmFsdWUgPSBnZXRWYWx1ZShwcmV2R3JvdXBJbmRpY2VzKTtcbiAgICAgICAgICBpZiAocHJldkdyb3VwSW5kaWNlc1ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSBhZmZlY3RlZEdyb3VwQ291bnQoLW9mZnNldCwgcHJldkdyb3VwSW5kaWNlc1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHVibGlzaChzaGlmdFdpdGgsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHN1YnNjcmliZShwaXBlKGZpcnN0SXRlbUluZGV4LCB3aXRoTGF0ZXN0RnJvbShsb2cpKSwgKFtpbmRleCwgbG9nMl0pID0+IHtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgbG9nMihcbiAgICAgICAgICBcImBmaXJzdEl0ZW1JbmRleGAgcHJvcCBzaG91bGQgbm90IGJlIHNldCB0byBsZXNzIHRoYW4gemVyby4gSWYgeW91IGRvbid0IGtub3cgdGhlIHRvdGFsIGNvdW50LCBqdXN0IHVzZSBhIHZlcnkgaGlnaCB2YWx1ZVwiLFxuICAgICAgICAgIHsgZmlyc3RJdGVtSW5kZXggfSxcbiAgICAgICAgICBMb2dMZXZlbC5FUlJPUlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGJlZm9yZVVuc2hpZnRXaXRoID0gc3RyZWFtRnJvbUVtaXR0ZXIodW5zaGlmdFdpdGgpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICB1bnNoaWZ0V2l0aCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMpLFxuICAgICAgICBtYXAoKFt1bnNoaWZ0V2l0aDIsIHNpemVzMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBncm91cGVkTW9kZSA9IHNpemVzMi5ncm91cEluZGljZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICBjb25zdCBpbml0aWFsUmFuZ2VzID0gW107XG4gICAgICAgICAgY29uc3QgZGVmYXVsdFNpemUgPSBzaXplczIubGFzdFNpemU7XG4gICAgICAgICAgaWYgKGdyb3VwZWRNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEdyb3VwU2l6ZSA9IGZpbmQoc2l6ZXMyLnNpemVUcmVlLCAwKTtcbiAgICAgICAgICAgIGxldCBwcmVwZW5kZWRHcm91cEl0ZW1zQ291bnQgPSAwO1xuICAgICAgICAgICAgbGV0IGdyb3VwSW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHByZXBlbmRlZEdyb3VwSXRlbXNDb3VudCA8IHVuc2hpZnRXaXRoMikge1xuICAgICAgICAgICAgICBjb25zdCB0aGVHcm91cEluZGV4ID0gc2l6ZXMyLmdyb3VwSW5kaWNlc1tncm91cEluZGV4XTtcbiAgICAgICAgICAgICAgY29uc3QgZ3JvdXBJdGVtQ291bnQgPSBzaXplczIuZ3JvdXBJbmRpY2VzLmxlbmd0aCA9PT0gZ3JvdXBJbmRleCArIDEgPyBJbmZpbml0eSA6IHNpemVzMi5ncm91cEluZGljZXNbZ3JvdXBJbmRleCArIDFdIC0gdGhlR3JvdXBJbmRleCAtIDE7XG4gICAgICAgICAgICAgIGluaXRpYWxSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleDogdGhlR3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBlbmRJbmRleDogdGhlR3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBzaXplOiBmaXJzdEdyb3VwU2l6ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaW5pdGlhbFJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4OiB0aGVHcm91cEluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICBlbmRJbmRleDogdGhlR3JvdXBJbmRleCArIDEgKyBncm91cEl0ZW1Db3VudCAtIDEsXG4gICAgICAgICAgICAgICAgc2l6ZTogZGVmYXVsdFNpemVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGdyb3VwSW5kZXgrKztcbiAgICAgICAgICAgICAgcHJlcGVuZGVkR3JvdXBJdGVtc0NvdW50ICs9IGdyb3VwSXRlbUNvdW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpemVUcmVlS1YgPSB3YWxrKHNpemVzMi5zaXplVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEdyb3VwSXNFeHBhbmRlZCA9IHByZXBlbmRlZEdyb3VwSXRlbXNDb3VudCAhPT0gdW5zaGlmdFdpdGgyO1xuICAgICAgICAgICAgaWYgKGZpcnN0R3JvdXBJc0V4cGFuZGVkKSB7XG4gICAgICAgICAgICAgIHNpemVUcmVlS1Yuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaXplVHJlZUtWLnJlZHVjZShcbiAgICAgICAgICAgICAgKGFjYywgeyBrOiBpbmRleCwgdjogc2l6ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IGFjYy5yYW5nZXM7XG4gICAgICAgICAgICAgICAgaWYgKGFjYy5wcmV2U2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgcmFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MucmFuZ2VzLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleDogYWNjLnByZXZJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmRJbmRleDogaW5kZXggKyB1bnNoaWZ0V2l0aDIgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGFjYy5wcmV2U2l6ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcmFuZ2VzLFxuICAgICAgICAgICAgICAgICAgcHJldkluZGV4OiBpbmRleCArIHVuc2hpZnRXaXRoMixcbiAgICAgICAgICAgICAgICAgIHByZXZTaXplOiBzaXplXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJhbmdlczogaW5pdGlhbFJhbmdlcyxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXg6IHVuc2hpZnRXaXRoMixcbiAgICAgICAgICAgICAgICBwcmV2U2l6ZTogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLnJhbmdlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdhbGsoc2l6ZXMyLnNpemVUcmVlKS5yZWR1Y2UoXG4gICAgICAgICAgICAoYWNjLCB7IGs6IGluZGV4LCB2OiBzaXplIH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByYW5nZXM6IFsuLi5hY2MucmFuZ2VzLCB7IHN0YXJ0SW5kZXg6IGFjYy5wcmV2SW5kZXgsIGVuZEluZGV4OiBpbmRleCArIHVuc2hpZnRXaXRoMiAtIDEsIHNpemU6IGFjYy5wcmV2U2l6ZSB9XSxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXg6IGluZGV4ICsgdW5zaGlmdFdpdGgyLFxuICAgICAgICAgICAgICAgIHByZXZTaXplOiBzaXplXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByYW5nZXM6IFtdLFxuICAgICAgICAgICAgICBwcmV2SW5kZXg6IDAsXG4gICAgICAgICAgICAgIHByZXZTaXplOiBkZWZhdWx0U2l6ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICkucmFuZ2VzO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNpemVSYW5nZXNcbiAgICApO1xuICAgIGNvbnN0IHNoaWZ0V2l0aE9mZnNldCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgc2hpZnRXaXRoLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgZ2FwKSxcbiAgICAgICAgbWFwKChbc2hpZnRXaXRoMiwgeyBvZmZzZXRUcmVlIH0sIGdhcDJdKSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3Rmlyc3RJdGVtSW5kZXggPSAtc2hpZnRXaXRoMjtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0T2YobmV3Rmlyc3RJdGVtSW5kZXgsIG9mZnNldFRyZWUsIGdhcDIpO1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNoaWZ0V2l0aCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMsIGdhcCksXG4gICAgICAgIG1hcCgoW3NoaWZ0V2l0aDIsIHNpemVzMiwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBncm91cGVkTW9kZSA9IHNpemVzMi5ncm91cEluZGljZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICBpZiAoZ3JvdXBlZE1vZGUpIHtcbiAgICAgICAgICAgIGlmIChlbXB0eShzaXplczIuc2l6ZVRyZWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaXplczI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV3U2l6ZVRyZWUgPSBuZXdUcmVlKCk7XG4gICAgICAgICAgICBjb25zdCBwcmV2R3JvdXBJbmRpY2VzVmFsdWUgPSBnZXRWYWx1ZShwcmV2R3JvdXBJbmRpY2VzKTtcbiAgICAgICAgICAgIGxldCByZW1vdmVkSXRlbXNDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgZ3JvdXBJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgZ3JvdXBPZmZzZXQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlbW92ZWRJdGVtc0NvdW50IDwgLXNoaWZ0V2l0aDIpIHtcbiAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQgPSBwcmV2R3JvdXBJbmRpY2VzVmFsdWVbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICAgIGNvbnN0IGdyb3VwSXRlbUNvdW50ID0gcHJldkdyb3VwSW5kaWNlc1ZhbHVlW2dyb3VwSW5kZXggKyAxXSAtIGdyb3VwT2Zmc2V0IC0gMTtcbiAgICAgICAgICAgICAgZ3JvdXBJbmRleCsrO1xuICAgICAgICAgICAgICByZW1vdmVkSXRlbXNDb3VudCArPSBncm91cEl0ZW1Db3VudCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdTaXplVHJlZSA9IHdhbGsoc2l6ZXMyLnNpemVUcmVlKS5yZWR1Y2UoKGFjYywgeyBrLCB2IH0pID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGluc2VydChhY2MsIE1hdGgubWF4KDAsIGsgKyBzaGlmdFdpdGgyKSwgdik7XG4gICAgICAgICAgICB9LCBuZXdTaXplVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBhR3JvdXBJc1NocnVuayA9IHJlbW92ZWRJdGVtc0NvdW50ICE9PSAtc2hpZnRXaXRoMjtcbiAgICAgICAgICAgIGlmIChhR3JvdXBJc1NocnVuaykge1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdEdyb3VwU2l6ZSA9IGZpbmQoc2l6ZXMyLnNpemVUcmVlLCBncm91cE9mZnNldCk7XG4gICAgICAgICAgICAgIG5ld1NpemVUcmVlID0gaW5zZXJ0KG5ld1NpemVUcmVlLCAwLCBmaXJzdEdyb3VwU2l6ZSk7XG4gICAgICAgICAgICAgIGNvbnN0IG5leHRJdGVtU2l6ZSA9IGZpbmRNYXhLZXlWYWx1ZShzaXplczIuc2l6ZVRyZWUsIC1zaGlmdFdpdGgyICsgMSlbMV07XG4gICAgICAgICAgICAgIG5ld1NpemVUcmVlID0gaW5zZXJ0KG5ld1NpemVUcmVlLCAxLCBuZXh0SXRlbVNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4uc2l6ZXMyLFxuICAgICAgICAgICAgICBzaXplVHJlZTogbmV3U2l6ZVRyZWUsXG4gICAgICAgICAgICAgIC4uLmNyZWF0ZU9mZnNldFRyZWUoc2l6ZXMyLm9mZnNldFRyZWUsIDAsIG5ld1NpemVUcmVlLCBnYXAyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2l6ZVRyZWUgPSB3YWxrKHNpemVzMi5zaXplVHJlZSkucmVkdWNlKChhY2MsIHsgaywgdiB9KSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnNlcnQoYWNjLCBNYXRoLm1heCgwLCBrICsgc2hpZnRXaXRoMiksIHYpO1xuICAgICAgICAgICAgfSwgbmV3VHJlZSgpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnNpemVzMixcbiAgICAgICAgICAgICAgc2l6ZVRyZWU6IG5ld1NpemVUcmVlLFxuICAgICAgICAgICAgICAuLi5jcmVhdGVPZmZzZXRUcmVlKHNpemVzMi5vZmZzZXRUcmVlLCAwLCBuZXdTaXplVHJlZSwgZ2FwMilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNpemVzXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gaW5wdXRcbiAgICAgIGRhdGEsXG4gICAgICB0b3RhbENvdW50LFxuICAgICAgc2l6ZVJhbmdlcyxcbiAgICAgIGdyb3VwSW5kaWNlcyxcbiAgICAgIGRlZmF1bHRJdGVtU2l6ZSxcbiAgICAgIGZpeGVkSXRlbVNpemUsXG4gICAgICB1bnNoaWZ0V2l0aCxcbiAgICAgIHNoaWZ0V2l0aCxcbiAgICAgIHNoaWZ0V2l0aE9mZnNldCxcbiAgICAgIGJlZm9yZVVuc2hpZnRXaXRoLFxuICAgICAgZmlyc3RJdGVtSW5kZXgsXG4gICAgICBnYXAsXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIHNpemVzLFxuICAgICAgbGlzdFJlZnJlc2gsXG4gICAgICBzdGF0ZWZ1bFRvdGFsQ291bnQsXG4gICAgICB0cmFja0l0ZW1TaXplcyxcbiAgICAgIGl0ZW1TaXplXG4gICAgfTtcbiAgfSxcbiAgdHVwKGxvZ2dlclN5c3RlbSwgcmVjYWxjU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmNvbnN0IFNVUFBPUlRTX1NDUk9MTF9UT19PUFRJT05TID0gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIFwic2Nyb2xsQmVoYXZpb3JcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5mdW5jdGlvbiBub3JtYWxpemVJbmRleExvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJudW1iZXJcIiA/IHsgaW5kZXg6IGxvY2F0aW9uIH0gOiBsb2NhdGlvbjtcbiAgaWYgKCFyZXN1bHQuYWxpZ24pIHtcbiAgICByZXN1bHQuYWxpZ24gPSBcInN0YXJ0XCI7XG4gIH1cbiAgaWYgKCFyZXN1bHQuYmVoYXZpb3IgfHwgIVNVUFBPUlRTX1NDUk9MTF9UT19PUFRJT05TKSB7XG4gICAgcmVzdWx0LmJlaGF2aW9yID0gXCJhdXRvXCI7XG4gIH1cbiAgaWYgKCFyZXN1bHQub2Zmc2V0KSB7XG4gICAgcmVzdWx0Lm9mZnNldCA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IHNjcm9sbFRvSW5kZXhTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgeyBzaXplcywgdG90YWxDb3VudCwgbGlzdFJlZnJlc2gsIGdhcCB9LFxuICAgIHtcbiAgICAgIHNjcm9sbGluZ0luUHJvZ3Jlc3MsXG4gICAgICB2aWV3cG9ydEhlaWdodCxcbiAgICAgIHNjcm9sbFRvLFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCxcbiAgICAgIGhlYWRlckhlaWdodCxcbiAgICAgIGZvb3RlckhlaWdodCxcbiAgICAgIGZpeGVkSGVhZGVySGVpZ2h0LFxuICAgICAgZml4ZWRGb290ZXJIZWlnaHRcbiAgICB9LFxuICAgIHsgbG9nIH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbFRvSW5kZXggPSBzdHJlYW0oKTtcbiAgICBjb25zdCBzY3JvbGxUYXJnZXRSZWFjaGVkID0gc3RyZWFtKCk7XG4gICAgY29uc3QgdG9wTGlzdEhlaWdodCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGxldCB1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCA9IG51bGw7XG4gICAgbGV0IGNsZWFydFRpbWVvdXRSZWYgPSBudWxsO1xuICAgIGxldCB1bnN1YnNjcmliZUxpc3RSZWZyZXNoID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgaWYgKHVuc3Vic2NyaWJlTmV4dExpc3RSZWZyZXNoKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlTmV4dExpc3RSZWZyZXNoKCk7XG4gICAgICAgIHVuc3Vic2NyaWJlTmV4dExpc3RSZWZyZXNoID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh1bnN1YnNjcmliZUxpc3RSZWZyZXNoKSB7XG4gICAgICAgIHVuc3Vic2NyaWJlTGlzdFJlZnJlc2goKTtcbiAgICAgICAgdW5zdWJzY3JpYmVMaXN0UmVmcmVzaCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2xlYXJ0VGltZW91dFJlZikge1xuICAgICAgICBjbGVhclRpbWVvdXQoY2xlYXJ0VGltZW91dFJlZik7XG4gICAgICAgIGNsZWFydFRpbWVvdXRSZWYgPSBudWxsO1xuICAgICAgfVxuICAgICAgcHVibGlzaChzY3JvbGxpbmdJblByb2dyZXNzLCBmYWxzZSk7XG4gICAgfVxuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBzY3JvbGxUb0luZGV4LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgdmlld3BvcnRIZWlnaHQsIHRvdGFsQ291bnQsIHRvcExpc3RIZWlnaHQsIGhlYWRlckhlaWdodCwgZm9vdGVySGVpZ2h0LCBsb2cpLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShnYXAsIGZpeGVkSGVhZGVySGVpZ2h0LCBmaXhlZEZvb3RlckhlaWdodCksXG4gICAgICAgIG1hcChcbiAgICAgICAgICAoW1xuICAgICAgICAgICAgW2xvY2F0aW9uLCBzaXplczIsIHZpZXdwb3J0SGVpZ2h0MiwgdG90YWxDb3VudDIsIHRvcExpc3RIZWlnaHQyLCBoZWFkZXJIZWlnaHQyLCBmb290ZXJIZWlnaHQyLCBsb2cyXSxcbiAgICAgICAgICAgIGdhcDIsXG4gICAgICAgICAgICBmaXhlZEhlYWRlckhlaWdodDIsXG4gICAgICAgICAgICBmaXhlZEZvb3RlckhlaWdodDJcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxMb2NhdGlvbiA9IG5vcm1hbGl6ZUluZGV4TG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgeyBhbGlnbiwgYmVoYXZpb3IsIG9mZnNldCB9ID0gbm9ybWFsTG9jYXRpb247XG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0b3RhbENvdW50MiAtIDE7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG9yaWdpbmFsSW5kZXhGcm9tTG9jYXRpb24obm9ybWFsTG9jYXRpb24sIHNpemVzMiwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIGxldCB0b3AgPSBvZmZzZXRPZihpbmRleCwgc2l6ZXMyLm9mZnNldFRyZWUsIGdhcDIpICsgaGVhZGVySGVpZ2h0MjtcbiAgICAgICAgICAgIGlmIChhbGlnbiA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICB0b3AgKz0gZml4ZWRIZWFkZXJIZWlnaHQyICsgZmluZE1heEtleVZhbHVlKHNpemVzMi5zaXplVHJlZSwgaW5kZXgpWzFdIC0gdmlld3BvcnRIZWlnaHQyICsgZml4ZWRGb290ZXJIZWlnaHQyO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgIHRvcCArPSBmb290ZXJIZWlnaHQyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgICAgIHRvcCArPSAoZml4ZWRIZWFkZXJIZWlnaHQyICsgZmluZE1heEtleVZhbHVlKHNpemVzMi5zaXplVHJlZSwgaW5kZXgpWzFdIC0gdmlld3BvcnRIZWlnaHQyICsgZml4ZWRGb290ZXJIZWlnaHQyKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b3AgLT0gdG9wTGlzdEhlaWdodDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHRvcCArPSBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXRyeSA9IChsaXN0Q2hhbmdlZCkgPT4ge1xuICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgIGlmIChsaXN0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGxvZzIoXCJyZXRyeWluZyB0byBzY3JvbGwgdG9cIiwgeyBsb2NhdGlvbiB9LCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgICAgICAgICAgICAgcHVibGlzaChzY3JvbGxUb0luZGV4LCBsb2NhdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVibGlzaChzY3JvbGxUYXJnZXRSZWFjaGVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsb2cyKFwibGlzdCBkaWQgbm90IGNoYW5nZSwgc2Nyb2xsIHN1Y2Nlc3NmdWxcIiwge30sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIikge1xuICAgICAgICAgICAgICBsZXQgbGlzdENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgdW5zdWJzY3JpYmVMaXN0UmVmcmVzaCA9IHN1YnNjcmliZShsaXN0UmVmcmVzaCwgKGNoYW5nZWQpID0+IHtcbiAgICAgICAgICAgICAgICBsaXN0Q2hhbmdlZCA9IGxpc3RDaGFuZ2VkIHx8IGNoYW5nZWQ7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCA9IGhhbmRsZU5leHQoc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHJ5KGxpc3RDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bnN1YnNjcmliZU5leHRMaXN0UmVmcmVzaCA9IGhhbmRsZU5leHQocGlwZShsaXN0UmVmcmVzaCwgd2F0Y2hDaGFuZ2VzRm9yKDE1MCkpLCByZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhcnRUaW1lb3V0UmVmID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIH0sIDEyMDApO1xuICAgICAgICAgICAgcHVibGlzaChzY3JvbGxpbmdJblByb2dyZXNzLCB0cnVlKTtcbiAgICAgICAgICAgIGxvZzIoXCJzY3JvbGxpbmcgZnJvbSBpbmRleCB0b1wiLCB7IGluZGV4LCB0b3AsIGJlaGF2aW9yIH0sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICAgIHJldHVybiB7IHRvcCwgYmVoYXZpb3IgfTtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICksXG4gICAgICBzY3JvbGxUb1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbFRvSW5kZXgsXG4gICAgICBzY3JvbGxUYXJnZXRSZWFjaGVkLFxuICAgICAgdG9wTGlzdEhlaWdodFxuICAgIH07XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBkb21JT1N5c3RlbSwgbG9nZ2VyU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHdhdGNoQ2hhbmdlc0ZvcihsaW1pdCkge1xuICByZXR1cm4gKGRvbmUpID0+IHtcbiAgICBjb25zdCB0aW1lb3V0UmVmID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb25lKGZhbHNlKTtcbiAgICB9LCBsaW1pdCk7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvbmUodHJ1ZSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuY29uc3QgVVAgPSBcInVwXCI7XG5jb25zdCBET1dOID0gXCJkb3duXCI7XG5jb25zdCBOT05FJDEgPSBcIm5vbmVcIjtcbmNvbnN0IElOSVRJQUxfQk9UVE9NX1NUQVRFID0ge1xuICBhdEJvdHRvbTogZmFsc2UsXG4gIG5vdEF0Qm90dG9tQmVjYXVzZTogXCJOT1RfU0hPV0lOR19MQVNUX0lURU1cIixcbiAgc3RhdGU6IHtcbiAgICBvZmZzZXRCb3R0b206IDAsXG4gICAgc2Nyb2xsVG9wOiAwLFxuICAgIHZpZXdwb3J0SGVpZ2h0OiAwLFxuICAgIHNjcm9sbEhlaWdodDogMFxuICB9XG59O1xuY29uc3QgREVGQVVMVF9BVF9UT1BfVEhSRVNIT0xEID0gMDtcbmNvbnN0IHN0YXRlRmxhZ3NTeXN0ZW0gPSBzeXN0ZW0oKFt7IHNjcm9sbENvbnRhaW5lclN0YXRlLCBzY3JvbGxUb3AsIHZpZXdwb3J0SGVpZ2h0LCBoZWFkZXJIZWlnaHQsIGZvb3RlckhlaWdodCwgc2Nyb2xsQnkgfV0pID0+IHtcbiAgY29uc3QgaXNBdEJvdHRvbSA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgY29uc3QgaXNBdFRvcCA9IHN0YXRlZnVsU3RyZWFtKHRydWUpO1xuICBjb25zdCBhdEJvdHRvbVN0YXRlQ2hhbmdlID0gc3RyZWFtKCk7XG4gIGNvbnN0IGF0VG9wU3RhdGVDaGFuZ2UgPSBzdHJlYW0oKTtcbiAgY29uc3QgYXRCb3R0b21UaHJlc2hvbGQgPSBzdGF0ZWZ1bFN0cmVhbSg0KTtcbiAgY29uc3QgYXRUb3BUaHJlc2hvbGQgPSBzdGF0ZWZ1bFN0cmVhbShERUZBVUxUX0FUX1RPUF9USFJFU0hPTEQpO1xuICBjb25zdCBpc1Njcm9sbGluZyA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgcGlwZShcbiAgICAgIG1lcmdlKHBpcGUoZHVjKHNjcm9sbFRvcCksIHNraXAoMSksIG1hcFRvKHRydWUpKSwgcGlwZShkdWMoc2Nyb2xsVG9wKSwgc2tpcCgxKSwgbWFwVG8oZmFsc2UpLCBkZWJvdW5jZVRpbWUoMTAwKSkpLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICksXG4gICAgZmFsc2VcbiAgKTtcbiAgY29uc3QgaXNTY3JvbGxpbmdCeSA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgcGlwZShtZXJnZShwaXBlKHNjcm9sbEJ5LCBtYXBUbyh0cnVlKSksIHBpcGUoc2Nyb2xsQnksIG1hcFRvKGZhbHNlKSwgZGVib3VuY2VUaW1lKDIwMCkpKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSksXG4gICAgZmFsc2VcbiAgKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgY29tYmluZUxhdGVzdChkdWMoc2Nyb2xsVG9wKSwgZHVjKGF0VG9wVGhyZXNob2xkKSksXG4gICAgICBtYXAoKFt0b3AsIGF0VG9wVGhyZXNob2xkMl0pID0+IHRvcCA8PSBhdFRvcFRocmVzaG9sZDIpLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICksXG4gICAgaXNBdFRvcFxuICApO1xuICBjb25uZWN0KHBpcGUoaXNBdFRvcCwgdGhyb3R0bGVUaW1lKDUwKSksIGF0VG9wU3RhdGVDaGFuZ2UpO1xuICBjb25zdCBhdEJvdHRvbVN0YXRlID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgcGlwZShcbiAgICAgIGNvbWJpbmVMYXRlc3Qoc2Nyb2xsQ29udGFpbmVyU3RhdGUsIGR1Yyh2aWV3cG9ydEhlaWdodCksIGR1YyhoZWFkZXJIZWlnaHQpLCBkdWMoZm9vdGVySGVpZ2h0KSwgZHVjKGF0Qm90dG9tVGhyZXNob2xkKSksXG4gICAgICBzY2FuKChjdXJyZW50LCBbeyBzY3JvbGxUb3A6IHNjcm9sbFRvcDIsIHNjcm9sbEhlaWdodCB9LCB2aWV3cG9ydEhlaWdodDIsIF9oZWFkZXJIZWlnaHQsIF9mb290ZXJIZWlnaHQsIGF0Qm90dG9tVGhyZXNob2xkMl0pID0+IHtcbiAgICAgICAgY29uc3QgaXNBdEJvdHRvbTIgPSBzY3JvbGxUb3AyICsgdmlld3BvcnRIZWlnaHQyIC0gc2Nyb2xsSGVpZ2h0ID4gLWF0Qm90dG9tVGhyZXNob2xkMjtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0MixcbiAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcDIsXG4gICAgICAgICAgc2Nyb2xsSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc0F0Qm90dG9tMikge1xuICAgICAgICAgIGxldCBhdEJvdHRvbUJlY2F1c2U7XG4gICAgICAgICAgbGV0IHNjcm9sbFRvcERlbHRhO1xuICAgICAgICAgIGlmIChzY3JvbGxUb3AyID4gY3VycmVudC5zdGF0ZS5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIGF0Qm90dG9tQmVjYXVzZSA9IFwiU0NST0xMRURfRE9XTlwiO1xuICAgICAgICAgICAgc2Nyb2xsVG9wRGVsdGEgPSBjdXJyZW50LnN0YXRlLnNjcm9sbFRvcCAtIHNjcm9sbFRvcDI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF0Qm90dG9tQmVjYXVzZSA9IFwiU0laRV9ERUNSRUFTRURcIjtcbiAgICAgICAgICAgIHNjcm9sbFRvcERlbHRhID0gY3VycmVudC5zdGF0ZS5zY3JvbGxUb3AgLSBzY3JvbGxUb3AyIHx8IGN1cnJlbnQuc2Nyb2xsVG9wRGVsdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdEJvdHRvbTogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgYXRCb3R0b21CZWNhdXNlLFxuICAgICAgICAgICAgc2Nyb2xsVG9wRGVsdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBub3RBdEJvdHRvbUJlY2F1c2U7XG4gICAgICAgIGlmIChzdGF0ZS5zY3JvbGxIZWlnaHQgPiBjdXJyZW50LnN0YXRlLnNjcm9sbEhlaWdodCkge1xuICAgICAgICAgIG5vdEF0Qm90dG9tQmVjYXVzZSA9IFwiU0laRV9JTkNSRUFTRURcIjtcbiAgICAgICAgfSBlbHNlIGlmICh2aWV3cG9ydEhlaWdodDIgPCBjdXJyZW50LnN0YXRlLnZpZXdwb3J0SGVpZ2h0KSB7XG4gICAgICAgICAgbm90QXRCb3R0b21CZWNhdXNlID0gXCJWSUVXUE9SVF9IRUlHSFRfREVDUkVBU0lOR1wiO1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbFRvcDIgPCBjdXJyZW50LnN0YXRlLnNjcm9sbFRvcCkge1xuICAgICAgICAgIG5vdEF0Qm90dG9tQmVjYXVzZSA9IFwiU0NST0xMSU5HX1VQV0FSRFNcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3RBdEJvdHRvbUJlY2F1c2UgPSBcIk5PVF9GVUxMWV9TQ1JPTExFRF9UT19MQVNUX0lURU1fQk9UVE9NXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhdEJvdHRvbTogZmFsc2UsXG4gICAgICAgICAgbm90QXRCb3R0b21CZWNhdXNlLFxuICAgICAgICAgIHN0YXRlXG4gICAgICAgIH07XG4gICAgICB9LCBJTklUSUFMX0JPVFRPTV9TVEFURSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgocHJldiwgbmV4dCkgPT4ge1xuICAgICAgICByZXR1cm4gcHJldiAmJiBwcmV2LmF0Qm90dG9tID09PSBuZXh0LmF0Qm90dG9tO1xuICAgICAgfSlcbiAgICApXG4gICk7XG4gIGNvbnN0IGxhc3RKdW1wRHVlVG9JdGVtUmVzaXplID0gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICBwaXBlKFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgICBzY2FuKFxuICAgICAgICAoY3VycmVudCwgeyBzY3JvbGxUb3A6IHNjcm9sbFRvcDIsIHNjcm9sbEhlaWdodCwgdmlld3BvcnRIZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0MiB9KSA9PiB7XG4gICAgICAgICAgaWYgKCFhcHByb3hpbWF0ZWx5RXF1YWwoY3VycmVudC5zY3JvbGxIZWlnaHQsIHNjcm9sbEhlaWdodCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0Qm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gKHNjcm9sbFRvcDIgKyB2aWV3cG9ydEhlaWdodDIpIDwgMTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnNjcm9sbFRvcCAhPT0gc2Nyb2xsVG9wMiAmJiBhdEJvdHRvbSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcDIsXG4gICAgICAgICAgICAgICAganVtcDogY3VycmVudC5zY3JvbGxUb3AgLSBzY3JvbGxUb3AyLFxuICAgICAgICAgICAgICAgIGNoYW5nZWQ6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wMixcbiAgICAgICAgICAgICAgICBqdW1wOiAwLFxuICAgICAgICAgICAgICAgIGNoYW5nZWQ6IHRydWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyLFxuICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICAgIGp1bXA6IDAsXG4gICAgICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgeyBzY3JvbGxIZWlnaHQ6IDAsIGp1bXA6IDAsIHNjcm9sbFRvcDogMCwgY2hhbmdlZDogZmFsc2UgfVxuICAgICAgKSxcbiAgICAgIGZpbHRlcigodmFsdWUpID0+IHZhbHVlLmNoYW5nZWQpLFxuICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUuanVtcClcbiAgICApLFxuICAgIDBcbiAgKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgYXRCb3R0b21TdGF0ZSxcbiAgICAgIG1hcCgoc3RhdGUpID0+IHN0YXRlLmF0Qm90dG9tKVxuICAgICksXG4gICAgaXNBdEJvdHRvbVxuICApO1xuICBjb25uZWN0KHBpcGUoaXNBdEJvdHRvbSwgdGhyb3R0bGVUaW1lKDUwKSksIGF0Qm90dG9tU3RhdGVDaGFuZ2UpO1xuICBjb25zdCBzY3JvbGxEaXJlY3Rpb24gPSBzdGF0ZWZ1bFN0cmVhbShET1dOKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgICBtYXAoKHsgc2Nyb2xsVG9wOiBzY3JvbGxUb3AyIH0pID0+IHNjcm9sbFRvcDIpLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIHNjYW4oXG4gICAgICAgIChhY2MsIHNjcm9sbFRvcDIpID0+IHtcbiAgICAgICAgICBpZiAoZ2V0VmFsdWUoaXNTY3JvbGxpbmdCeSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRpcmVjdGlvbjogYWNjLmRpcmVjdGlvbiwgcHJldlNjcm9sbFRvcDogc2Nyb2xsVG9wMiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkaXJlY3Rpb246IHNjcm9sbFRvcDIgPCBhY2MucHJldlNjcm9sbFRvcCA/IFVQIDogRE9XTiwgcHJldlNjcm9sbFRvcDogc2Nyb2xsVG9wMiB9O1xuICAgICAgICB9LFxuICAgICAgICB7IGRpcmVjdGlvbjogRE9XTiwgcHJldlNjcm9sbFRvcDogMCB9XG4gICAgICApLFxuICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUuZGlyZWN0aW9uKVxuICAgICksXG4gICAgc2Nyb2xsRGlyZWN0aW9uXG4gICk7XG4gIGNvbm5lY3QocGlwZShzY3JvbGxDb250YWluZXJTdGF0ZSwgdGhyb3R0bGVUaW1lKDUwKSwgbWFwVG8oTk9ORSQxKSksIHNjcm9sbERpcmVjdGlvbik7XG4gIGNvbnN0IHNjcm9sbFZlbG9jaXR5ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGlzU2Nyb2xsaW5nLFxuICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gIXZhbHVlKSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICBtYXBUbygwKVxuICAgICksXG4gICAgc2Nyb2xsVmVsb2NpdHlcbiAgKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgc2Nyb2xsVG9wLFxuICAgICAgdGhyb3R0bGVUaW1lKDEwMCksXG4gICAgICB3aXRoTGF0ZXN0RnJvbShpc1Njcm9sbGluZyksXG4gICAgICBmaWx0ZXIoKFtfLCBpc1Njcm9sbGluZzJdKSA9PiAhIWlzU2Nyb2xsaW5nMiksXG4gICAgICBzY2FuKChbXywgcHJldl0sIFtuZXh0XSkgPT4gW3ByZXYsIG5leHRdLCBbMCwgMF0pLFxuICAgICAgbWFwKChbcHJldiwgbmV4dF0pID0+IG5leHQgLSBwcmV2KVxuICAgICksXG4gICAgc2Nyb2xsVmVsb2NpdHlcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBpc1Njcm9sbGluZyxcbiAgICBpc0F0VG9wLFxuICAgIGlzQXRCb3R0b20sXG4gICAgYXRCb3R0b21TdGF0ZSxcbiAgICBhdFRvcFN0YXRlQ2hhbmdlLFxuICAgIGF0Qm90dG9tU3RhdGVDaGFuZ2UsXG4gICAgc2Nyb2xsRGlyZWN0aW9uLFxuICAgIGF0Qm90dG9tVGhyZXNob2xkLFxuICAgIGF0VG9wVGhyZXNob2xkLFxuICAgIHNjcm9sbFZlbG9jaXR5LFxuICAgIGxhc3RKdW1wRHVlVG9JdGVtUmVzaXplXG4gIH07XG59LCB0dXAoZG9tSU9TeXN0ZW0pKTtcbmNvbnN0IHByb3BzUmVhZHlTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBsb2cgfV0pID0+IHtcbiAgICBjb25zdCBwcm9wc1JlYWR5ID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbnN0IGRpZE1vdW50ID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBwcm9wc1JlYWR5LFxuICAgICAgICBmaWx0ZXIoKHJlYWR5KSA9PiByZWFkeSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgIClcbiAgICApO1xuICAgIHN1YnNjcmliZShwcm9wc1JlYWR5LCAodmFsdWUpID0+IHtcbiAgICAgIHZhbHVlICYmIGdldFZhbHVlKGxvZykoXCJwcm9wcyB1cGRhdGVkXCIsIHt9LCBMb2dMZXZlbC5ERUJVRyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvcHNSZWFkeSwgZGlkTW91bnQgfTtcbiAgfSxcbiAgdHVwKGxvZ2dlclN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiBza2lwRnJhbWVzKGZyYW1lQ291bnQsIGNhbGxiYWNrKSB7XG4gIGlmIChmcmFtZUNvdW50ID09IDApIHtcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBza2lwRnJhbWVzKGZyYW1lQ291bnQgLSAxLCBjYWxsYmFjaykpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbml0aWFsVG9wTW9zdEl0ZW1JbmRleE51bWJlcihsb2NhdGlvbiwgdG90YWxDb3VudCkge1xuICBjb25zdCBsYXN0SW5kZXggPSB0b3RhbENvdW50IC0gMTtcbiAgY29uc3QgaW5kZXggPSB0eXBlb2YgbG9jYXRpb24gPT09IFwibnVtYmVyXCIgPyBsb2NhdGlvbiA6IGxvY2F0aW9uLmluZGV4ID09PSBcIkxBU1RcIiA/IGxhc3RJbmRleCA6IGxvY2F0aW9uLmluZGV4O1xuICByZXR1cm4gaW5kZXg7XG59XG5jb25zdCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IHNpemVzLCBsaXN0UmVmcmVzaCwgZGVmYXVsdEl0ZW1TaXplIH0sIHsgc2Nyb2xsVG9wIH0sIHsgc2Nyb2xsVG9JbmRleCwgc2Nyb2xsVGFyZ2V0UmVhY2hlZCB9LCB7IGRpZE1vdW50IH1dKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsZWRUb0luaXRpYWxJdGVtID0gc3RhdGVmdWxTdHJlYW0odHJ1ZSk7XG4gICAgY29uc3QgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXggPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBpbml0aWFsSXRlbUZpbmFsTG9jYXRpb25SZWFjaGVkID0gc3RhdGVmdWxTdHJlYW0odHJ1ZSk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCksXG4gICAgICAgIGZpbHRlcigoW18sIGxvY2F0aW9uXSkgPT4gISFsb2NhdGlvbiksXG4gICAgICAgIG1hcFRvKGZhbHNlKVxuICAgICAgKSxcbiAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCksXG4gICAgICAgIGZpbHRlcigoW18sIGxvY2F0aW9uXSkgPT4gISFsb2NhdGlvbiksXG4gICAgICAgIG1hcFRvKGZhbHNlKVxuICAgICAgKSxcbiAgICAgIGluaXRpYWxJdGVtRmluYWxMb2NhdGlvblJlYWNoZWRcbiAgICApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QobGlzdFJlZnJlc2gsIGRpZE1vdW50KSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCBzaXplcywgZGVmYXVsdEl0ZW1TaXplLCBpbml0aWFsSXRlbUZpbmFsTG9jYXRpb25SZWFjaGVkKSxcbiAgICAgICAgZmlsdGVyKChbWywgZGlkTW91bnQyXSwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMiwgeyBzaXplVHJlZSB9LCBkZWZhdWx0SXRlbVNpemUyLCBzY3JvbGxTY2hlZHVsZWRdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGRpZE1vdW50MiAmJiAoIWVtcHR5KHNpemVUcmVlKSB8fCBpc0RlZmluZWQoZGVmYXVsdEl0ZW1TaXplMikpICYmICFzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yICYmICFzY3JvbGxTY2hlZHVsZWQ7XG4gICAgICAgIH0pLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShpbml0aWFsVG9wTW9zdEl0ZW1JbmRleClcbiAgICAgICksXG4gICAgICAoWywgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyXSkgPT4ge1xuICAgICAgICBoYW5kbGVOZXh0KHNjcm9sbFRhcmdldFJlYWNoZWQsICgpID0+IHtcbiAgICAgICAgICBwdWJsaXNoKGluaXRpYWxJdGVtRmluYWxMb2NhdGlvblJlYWNoZWQsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2tpcEZyYW1lcyg0LCAoKSA9PiB7XG4gICAgICAgICAgaGFuZGxlTmV4dChzY3JvbGxUb3AsICgpID0+IHtcbiAgICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCB0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwdWJsaXNoKHNjcm9sbFRvSW5kZXgsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4Mik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSxcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LFxuICAgICAgaW5pdGlhbEl0ZW1GaW5hbExvY2F0aW9uUmVhY2hlZFxuICAgIH07XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBkb21JT1N5c3RlbSwgc2Nyb2xsVG9JbmRleFN5c3RlbSwgcHJvcHNSZWFkeVN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiBub3JtYWxpemVGb2xsb3dPdXRwdXQoZm9sbG93KSB7XG4gIGlmICghZm9sbG93KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmb2xsb3cgPT09IFwic21vb3RoXCIgPyBcInNtb290aFwiIDogXCJhdXRvXCI7XG59XG5jb25zdCBiZWhhdmlvckZyb21Gb2xsb3dPdXRwdXQgPSAoZm9sbG93LCBpc0F0Qm90dG9tKSA9PiB7XG4gIGlmICh0eXBlb2YgZm9sbG93ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRm9sbG93T3V0cHV0KGZvbGxvdyhpc0F0Qm90dG9tKSk7XG4gIH1cbiAgcmV0dXJuIGlzQXRCb3R0b20gJiYgbm9ybWFsaXplRm9sbG93T3V0cHV0KGZvbGxvdyk7XG59O1xuY29uc3QgZm9sbG93T3V0cHV0U3lzdGVtID0gc3lzdGVtKFxuICAoW1xuICAgIHsgdG90YWxDb3VudCwgbGlzdFJlZnJlc2ggfSxcbiAgICB7IGlzQXRCb3R0b20sIGF0Qm90dG9tU3RhdGUgfSxcbiAgICB7IHNjcm9sbFRvSW5kZXggfSxcbiAgICB7IHNjcm9sbGVkVG9Jbml0aWFsSXRlbSB9LFxuICAgIHsgcHJvcHNSZWFkeSwgZGlkTW91bnQgfSxcbiAgICB7IGxvZyB9LFxuICAgIHsgc2Nyb2xsaW5nSW5Qcm9ncmVzcyB9XG4gIF0pID0+IHtcbiAgICBjb25zdCBmb2xsb3dPdXRwdXQgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgYXV0b3Njcm9sbFRvQm90dG9tID0gc3RyZWFtKCk7XG4gICAgbGV0IHBlbmRpbmdTY3JvbGxIYW5kbGUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHNjcm9sbFRvQm90dG9tKGZvbGxvd091dHB1dEJlaGF2aW9yKSB7XG4gICAgICBwdWJsaXNoKHNjcm9sbFRvSW5kZXgsIHtcbiAgICAgICAgaW5kZXg6IFwiTEFTVFwiLFxuICAgICAgICBhbGlnbjogXCJlbmRcIixcbiAgICAgICAgYmVoYXZpb3I6IGZvbGxvd091dHB1dEJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChwaXBlKGR1Yyh0b3RhbENvdW50KSwgc2tpcCgxKSksIGRpZE1vdW50KSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oZHVjKGZvbGxvd091dHB1dCksIGlzQXRCb3R0b20sIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSwgc2Nyb2xsaW5nSW5Qcm9ncmVzcyksXG4gICAgICAgIG1hcCgoW1t0b3RhbENvdW50MiwgZGlkTW91bnQyXSwgZm9sbG93T3V0cHV0MiwgaXNBdEJvdHRvbTIsIHNjcm9sbGVkVG9Jbml0aWFsSXRlbTIsIHNjcm9sbGluZ0luUHJvZ3Jlc3MyXSkgPT4ge1xuICAgICAgICAgIGxldCBzaG91bGRGb2xsb3cgPSBkaWRNb3VudDIgJiYgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMjtcbiAgICAgICAgICBsZXQgZm9sbG93T3V0cHV0QmVoYXZpb3IgPSBcImF1dG9cIjtcbiAgICAgICAgICBpZiAoc2hvdWxkRm9sbG93KSB7XG4gICAgICAgICAgICBmb2xsb3dPdXRwdXRCZWhhdmlvciA9IGJlaGF2aW9yRnJvbUZvbGxvd091dHB1dChmb2xsb3dPdXRwdXQyLCBpc0F0Qm90dG9tMiB8fCBzY3JvbGxpbmdJblByb2dyZXNzMik7XG4gICAgICAgICAgICBzaG91bGRGb2xsb3cgPSBzaG91bGRGb2xsb3cgJiYgISFmb2xsb3dPdXRwdXRCZWhhdmlvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgdG90YWxDb3VudDogdG90YWxDb3VudDIsIHNob3VsZEZvbGxvdywgZm9sbG93T3V0cHV0QmVoYXZpb3IgfTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlcigoeyBzaG91bGRGb2xsb3cgfSkgPT4gc2hvdWxkRm9sbG93KVxuICAgICAgKSxcbiAgICAgICh7IHRvdGFsQ291bnQ6IHRvdGFsQ291bnQyLCBmb2xsb3dPdXRwdXRCZWhhdmlvciB9KSA9PiB7XG4gICAgICAgIGlmIChwZW5kaW5nU2Nyb2xsSGFuZGxlKSB7XG4gICAgICAgICAgcGVuZGluZ1Njcm9sbEhhbmRsZSgpO1xuICAgICAgICAgIHBlbmRpbmdTY3JvbGxIYW5kbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdTY3JvbGxIYW5kbGUgPSBoYW5kbGVOZXh0KGxpc3RSZWZyZXNoLCAoKSA9PiB7XG4gICAgICAgICAgZ2V0VmFsdWUobG9nKShcImZvbGxvd2luZyBvdXRwdXQgdG8gXCIsIHsgdG90YWxDb3VudDogdG90YWxDb3VudDIgfSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgICAgIHNjcm9sbFRvQm90dG9tKGZvbGxvd091dHB1dEJlaGF2aW9yKTtcbiAgICAgICAgICBwZW5kaW5nU2Nyb2xsSGFuZGxlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBmdW5jdGlvbiB0cmFwTmV4dFNpemVJbmNyZWFzZShmb2xsb3dPdXRwdXQyKSB7XG4gICAgICBjb25zdCBjYW5jZWwgPSBoYW5kbGVOZXh0KGF0Qm90dG9tU3RhdGUsIChzdGF0ZSkgPT4ge1xuICAgICAgICBpZiAoZm9sbG93T3V0cHV0MiAmJiAhc3RhdGUuYXRCb3R0b20gJiYgc3RhdGUubm90QXRCb3R0b21CZWNhdXNlID09PSBcIlNJWkVfSU5DUkVBU0VEXCIgJiYgIXBlbmRpbmdTY3JvbGxIYW5kbGUpIHtcbiAgICAgICAgICBnZXRWYWx1ZShsb2cpKFwic2Nyb2xsaW5nIHRvIGJvdHRvbSBkdWUgdG8gaW5jcmVhc2VkIHNpemVcIiwge30sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICBzY3JvbGxUb0JvdHRvbShcImF1dG9cIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChjYW5jZWwsIDEwMCk7XG4gICAgfVxuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3QoZHVjKGZvbGxvd091dHB1dCksIHRvdGFsQ291bnQsIHByb3BzUmVhZHkpLFxuICAgICAgICBmaWx0ZXIoKFtmb2xsb3csICwgcmVhZHldKSA9PiBmb2xsb3cgJiYgcmVhZHkpLFxuICAgICAgICBzY2FuKFxuICAgICAgICAgICh7IHZhbHVlIH0sIFssIG5leHRdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyByZWZyZXNoZWQ6IHZhbHVlID09PSBuZXh0LCB2YWx1ZTogbmV4dCB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeyByZWZyZXNoZWQ6IGZhbHNlLCB2YWx1ZTogMCB9XG4gICAgICAgICksXG4gICAgICAgIGZpbHRlcigoeyByZWZyZXNoZWQgfSkgPT4gcmVmcmVzaGVkKSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oZm9sbG93T3V0cHV0LCB0b3RhbENvdW50KVxuICAgICAgKSxcbiAgICAgIChbLCBmb2xsb3dPdXRwdXQyXSkgPT4ge1xuICAgICAgICBpZiAoZ2V0VmFsdWUoc2Nyb2xsZWRUb0luaXRpYWxJdGVtKSkge1xuICAgICAgICAgIHRyYXBOZXh0U2l6ZUluY3JlYXNlKGZvbGxvd091dHB1dDIgIT09IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgc3Vic2NyaWJlKGF1dG9zY3JvbGxUb0JvdHRvbSwgKCkgPT4ge1xuICAgICAgdHJhcE5leHRTaXplSW5jcmVhc2UoZ2V0VmFsdWUoZm9sbG93T3V0cHV0KSAhPT0gZmFsc2UpO1xuICAgIH0pO1xuICAgIHN1YnNjcmliZShjb21iaW5lTGF0ZXN0KGR1Yyhmb2xsb3dPdXRwdXQpLCBhdEJvdHRvbVN0YXRlKSwgKFtmb2xsb3dPdXRwdXQyLCBzdGF0ZV0pID0+IHtcbiAgICAgIGlmIChmb2xsb3dPdXRwdXQyICYmICFzdGF0ZS5hdEJvdHRvbSAmJiBzdGF0ZS5ub3RBdEJvdHRvbUJlY2F1c2UgPT09IFwiVklFV1BPUlRfSEVJR0hUX0RFQ1JFQVNJTkdcIikge1xuICAgICAgICBzY3JvbGxUb0JvdHRvbShcImF1dG9cIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgZm9sbG93T3V0cHV0LCBhdXRvc2Nyb2xsVG9Cb3R0b20gfTtcbiAgfSxcbiAgdHVwKHNpemVTeXN0ZW0sIHN0YXRlRmxhZ3NTeXN0ZW0sIHNjcm9sbFRvSW5kZXhTeXN0ZW0sIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4U3lzdGVtLCBwcm9wc1JlYWR5U3lzdGVtLCBsb2dnZXJTeXN0ZW0sIGRvbUlPU3lzdGVtKVxuKTtcbmZ1bmN0aW9uIGdyb3VwQ291bnRzVG9JbmRpY2VzQW5kQ291bnQoY291bnRzKSB7XG4gIHJldHVybiBjb3VudHMucmVkdWNlKFxuICAgIChhY2MsIGdyb3VwQ291bnQpID0+IHtcbiAgICAgIGFjYy5ncm91cEluZGljZXMucHVzaChhY2MudG90YWxDb3VudCk7XG4gICAgICBhY2MudG90YWxDb3VudCArPSBncm91cENvdW50ICsgMTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSxcbiAgICB7XG4gICAgICB0b3RhbENvdW50OiAwLFxuICAgICAgZ3JvdXBJbmRpY2VzOiBbXVxuICAgIH1cbiAgKTtcbn1cbmNvbnN0IGdyb3VwZWRMaXN0U3lzdGVtID0gc3lzdGVtKChbeyB0b3RhbENvdW50LCBncm91cEluZGljZXMsIHNpemVzIH0sIHsgc2Nyb2xsVG9wLCBoZWFkZXJIZWlnaHQgfV0pID0+IHtcbiAgY29uc3QgZ3JvdXBDb3VudHMgPSBzdHJlYW0oKTtcbiAgY29uc3QgdG9wSXRlbXNJbmRleGVzID0gc3RyZWFtKCk7XG4gIGNvbnN0IGdyb3VwSW5kaWNlc0FuZENvdW50ID0gc3RyZWFtRnJvbUVtaXR0ZXIocGlwZShncm91cENvdW50cywgbWFwKGdyb3VwQ291bnRzVG9JbmRpY2VzQW5kQ291bnQpKSk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGdyb3VwSW5kaWNlc0FuZENvdW50LFxuICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUudG90YWxDb3VudClcbiAgICApLFxuICAgIHRvdGFsQ291bnRcbiAgKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgZ3JvdXBJbmRpY2VzQW5kQ291bnQsXG4gICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS5ncm91cEluZGljZXMpXG4gICAgKSxcbiAgICBncm91cEluZGljZXNcbiAgKTtcbiAgY29ubmVjdChcbiAgICBwaXBlKFxuICAgICAgY29tYmluZUxhdGVzdChzY3JvbGxUb3AsIHNpemVzLCBoZWFkZXJIZWlnaHQpLFxuICAgICAgZmlsdGVyKChbXywgc2l6ZXMyXSkgPT4gaGFzR3JvdXBzKHNpemVzMikpLFxuICAgICAgbWFwKChbc2Nyb2xsVG9wMiwgc3RhdGUsIGhlYWRlckhlaWdodDJdKSA9PiBmaW5kTWF4S2V5VmFsdWUoc3RhdGUuZ3JvdXBPZmZzZXRUcmVlLCBNYXRoLm1heChzY3JvbGxUb3AyIC0gaGVhZGVySGVpZ2h0MiwgMCksIFwidlwiKVswXSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgbWFwKChpbmRleCkgPT4gW2luZGV4XSlcbiAgICApLFxuICAgIHRvcEl0ZW1zSW5kZXhlc1xuICApO1xuICByZXR1cm4geyBncm91cENvdW50cywgdG9wSXRlbXNJbmRleGVzIH07XG59LCB0dXAoc2l6ZVN5c3RlbSwgZG9tSU9TeXN0ZW0pKTtcbmZ1bmN0aW9uIHR1cGxlQ29tcGFyYXRvcihwcmV2LCBjdXJyZW50KSB7XG4gIHJldHVybiAhIShwcmV2ICYmIHByZXZbMF0gPT09IGN1cnJlbnRbMF0gJiYgcHJldlsxXSA9PT0gY3VycmVudFsxXSk7XG59XG5mdW5jdGlvbiByYW5nZUNvbXBhcmF0b3IocHJldiwgbmV4dCkge1xuICByZXR1cm4gISEocHJldiAmJiBwcmV2LnN0YXJ0SW5kZXggPT09IG5leHQuc3RhcnRJbmRleCAmJiBwcmV2LmVuZEluZGV4ID09PSBuZXh0LmVuZEluZGV4KTtcbn1cbmNvbnN0IFRPUCA9IFwidG9wXCI7XG5jb25zdCBCT1RUT00gPSBcImJvdHRvbVwiO1xuY29uc3QgTk9ORSA9IFwibm9uZVwiO1xuZnVuY3Rpb24gZ2V0T3ZlcnNjYW4ob3ZlcnNjYW4sIGVuZCwgZGlyZWN0aW9uKSB7XG4gIGlmICh0eXBlb2Ygb3ZlcnNjYW4gPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09PSBVUCAmJiBlbmQgPT09IFRPUCB8fCBkaXJlY3Rpb24gPT09IERPV04gJiYgZW5kID09PSBCT1RUT00gPyBvdmVyc2NhbiA6IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgIHJldHVybiBlbmQgPT09IFRPUCA/IG92ZXJzY2FuLm1haW4gOiBvdmVyc2Nhbi5yZXZlcnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZW5kID09PSBCT1RUT00gPyBvdmVyc2Nhbi5tYWluIDogb3ZlcnNjYW4ucmV2ZXJzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZpZXdwb3J0SW5jcmVhc2UodmFsdWUsIGVuZCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZVtlbmRdIHx8IDA7XG59XG5jb25zdCBzaXplUmFuZ2VTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBzY3JvbGxUb3AsIHZpZXdwb3J0SGVpZ2h0LCBkZXZpYXRpb24sIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQgfV0pID0+IHtcbiAgICBjb25zdCBsaXN0Qm91bmRhcnkgPSBzdHJlYW0oKTtcbiAgICBjb25zdCB0b3BMaXN0SGVpZ2h0ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgaW5jcmVhc2VWaWV3cG9ydEJ5ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3Qgb3ZlcnNjYW4gPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCB2aXNpYmxlUmFuZ2UgPSBzdGF0ZWZ1bFN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChcbiAgICAgICAgICBkdWMoc2Nyb2xsVG9wKSxcbiAgICAgICAgICBkdWModmlld3BvcnRIZWlnaHQpLFxuICAgICAgICAgIGR1YyhoZWFkZXJIZWlnaHQpLFxuICAgICAgICAgIGR1YyhsaXN0Qm91bmRhcnksIHR1cGxlQ29tcGFyYXRvciksXG4gICAgICAgICAgZHVjKG92ZXJzY2FuKSxcbiAgICAgICAgICBkdWModG9wTGlzdEhlaWdodCksXG4gICAgICAgICAgZHVjKGZpeGVkSGVhZGVySGVpZ2h0KSxcbiAgICAgICAgICBkdWMoZGV2aWF0aW9uKSxcbiAgICAgICAgICBkdWMoaW5jcmVhc2VWaWV3cG9ydEJ5KVxuICAgICAgICApLFxuICAgICAgICBtYXAoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgIHNjcm9sbFRvcDIsXG4gICAgICAgICAgICB2aWV3cG9ydEhlaWdodDIsXG4gICAgICAgICAgICBoZWFkZXJIZWlnaHQyLFxuICAgICAgICAgICAgW2xpc3RUb3AsIGxpc3RCb3R0b21dLFxuICAgICAgICAgICAgb3ZlcnNjYW4yLFxuICAgICAgICAgICAgdG9wTGlzdEhlaWdodDIsXG4gICAgICAgICAgICBmaXhlZEhlYWRlckhlaWdodDIsXG4gICAgICAgICAgICBkZXZpYXRpb24yLFxuICAgICAgICAgICAgaW5jcmVhc2VWaWV3cG9ydEJ5MlxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHNjcm9sbFRvcDIgLSBkZXZpYXRpb24yO1xuICAgICAgICAgICAgY29uc3Qgc3RpY2t5SGVhZGVySGVpZ2h0ID0gdG9wTGlzdEhlaWdodDIgKyBmaXhlZEhlYWRlckhlaWdodDI7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJWaXNpYmxlID0gTWF0aC5tYXgoaGVhZGVySGVpZ2h0MiAtIHRvcCwgMCk7XG4gICAgICAgICAgICBsZXQgZGlyZWN0aW9uID0gTk9ORTtcbiAgICAgICAgICAgIGNvbnN0IHRvcFZpZXdwb3J0QWRkaXRpb24gPSBnZXRWaWV3cG9ydEluY3JlYXNlKGluY3JlYXNlVmlld3BvcnRCeTIsIFRPUCk7XG4gICAgICAgICAgICBjb25zdCBib3R0b21WaWV3cG9ydEFkZGl0aW9uID0gZ2V0Vmlld3BvcnRJbmNyZWFzZShpbmNyZWFzZVZpZXdwb3J0QnkyLCBCT1RUT00pO1xuICAgICAgICAgICAgbGlzdFRvcCAtPSBkZXZpYXRpb24yO1xuICAgICAgICAgICAgbGlzdFRvcCArPSBoZWFkZXJIZWlnaHQyICsgZml4ZWRIZWFkZXJIZWlnaHQyO1xuICAgICAgICAgICAgbGlzdEJvdHRvbSArPSBoZWFkZXJIZWlnaHQyICsgZml4ZWRIZWFkZXJIZWlnaHQyO1xuICAgICAgICAgICAgbGlzdEJvdHRvbSAtPSBkZXZpYXRpb24yO1xuICAgICAgICAgICAgaWYgKGxpc3RUb3AgPiBzY3JvbGxUb3AyICsgc3RpY2t5SGVhZGVySGVpZ2h0IC0gdG9wVmlld3BvcnRBZGRpdGlvbikge1xuICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBVUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaXN0Qm90dG9tIDwgc2Nyb2xsVG9wMiAtIGhlYWRlclZpc2libGUgKyB2aWV3cG9ydEhlaWdodDIgKyBib3R0b21WaWV3cG9ydEFkZGl0aW9uKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGlvbiA9IERPV047XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSBOT05FKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgodG9wIC0gaGVhZGVySGVpZ2h0MiAtIGdldE92ZXJzY2FuKG92ZXJzY2FuMiwgVE9QLCBkaXJlY3Rpb24pIC0gdG9wVmlld3BvcnRBZGRpdGlvbiwgMCksXG4gICAgICAgICAgICAgICAgdG9wIC0gaGVhZGVyVmlzaWJsZSAtIGZpeGVkSGVhZGVySGVpZ2h0MiArIHZpZXdwb3J0SGVpZ2h0MiArIGdldE92ZXJzY2FuKG92ZXJzY2FuMiwgQk9UVE9NLCBkaXJlY3Rpb24pICsgYm90dG9tVmlld3BvcnRBZGRpdGlvblxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBmaWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSAhPSBudWxsKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQodHVwbGVDb21wYXJhdG9yKVxuICAgICAgKSxcbiAgICAgIFswLCAwXVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGlucHV0XG4gICAgICBsaXN0Qm91bmRhcnksXG4gICAgICBvdmVyc2NhbixcbiAgICAgIHRvcExpc3RIZWlnaHQsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0QnksXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIHZpc2libGVSYW5nZVxuICAgIH07XG4gIH0sXG4gIHR1cChkb21JT1N5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5mdW5jdGlvbiBwcm9iZUl0ZW1TZXQoaW5kZXgsIHNpemVzLCBkYXRhKSB7XG4gIGlmIChoYXNHcm91cHMoc2l6ZXMpKSB7XG4gICAgY29uc3QgaXRlbUluZGV4ID0gb3JpZ2luYWxJbmRleEZyb21JdGVtSW5kZXgoaW5kZXgsIHNpemVzKTtcbiAgICBjb25zdCBncm91cEluZGV4ID0gZmluZE1heEtleVZhbHVlKHNpemVzLmdyb3VwT2Zmc2V0VHJlZSwgaXRlbUluZGV4KVswXTtcbiAgICByZXR1cm4gW1xuICAgICAgeyBpbmRleDogZ3JvdXBJbmRleCwgc2l6ZTogMCwgb2Zmc2V0OiAwIH0sXG4gICAgICB7IGluZGV4OiBpdGVtSW5kZXgsIHNpemU6IDAsIG9mZnNldDogMCwgZGF0YTogZGF0YSAmJiBkYXRhWzBdIH1cbiAgICBdO1xuICB9XG4gIHJldHVybiBbeyBpbmRleCwgc2l6ZTogMCwgb2Zmc2V0OiAwLCBkYXRhOiBkYXRhICYmIGRhdGFbMF0gfV07XG59XG5jb25zdCBFTVBUWV9MSVNUX1NUQVRFID0ge1xuICBpdGVtczogW10sXG4gIHRvcEl0ZW1zOiBbXSxcbiAgb2Zmc2V0VG9wOiAwLFxuICBvZmZzZXRCb3R0b206IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICB0b3BMaXN0SGVpZ2h0OiAwLFxuICB0b3RhbENvdW50OiAwLFxuICBmaXJzdEl0ZW1JbmRleDogMFxufTtcbmZ1bmN0aW9uIHRyYW5zcG9zZUl0ZW1zKGl0ZW1zLCBzaXplcywgZmlyc3RJdGVtSW5kZXgpIHtcbiAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAoIWhhc0dyb3VwcyhzaXplcykpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtKSA9PiAoeyAuLi5pdGVtLCBpbmRleDogaXRlbS5pbmRleCArIGZpcnN0SXRlbUluZGV4LCBvcmlnaW5hbEluZGV4OiBpdGVtLmluZGV4IH0pKTtcbiAgfVxuICBjb25zdCBzdGFydEluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gIGNvbnN0IGVuZEluZGV4ID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0uaW5kZXg7XG4gIGNvbnN0IHRyYW5zcG9zZWRJdGVtcyA9IFtdO1xuICBjb25zdCBncm91cFJhbmdlcyA9IHJhbmdlc1dpdGhpbihzaXplcy5ncm91cE9mZnNldFRyZWUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgbGV0IGN1cnJlbnRSYW5nZSA9IHZvaWQgMDtcbiAgbGV0IGN1cnJlbnRHcm91cEluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgaWYgKCFjdXJyZW50UmFuZ2UgfHwgY3VycmVudFJhbmdlLmVuZCA8IGl0ZW0uaW5kZXgpIHtcbiAgICAgIGN1cnJlbnRSYW5nZSA9IGdyb3VwUmFuZ2VzLnNoaWZ0KCk7XG4gICAgICBjdXJyZW50R3JvdXBJbmRleCA9IHNpemVzLmdyb3VwSW5kaWNlcy5pbmRleE9mKGN1cnJlbnRSYW5nZS5zdGFydCk7XG4gICAgfVxuICAgIGxldCB0cmFuc3Bvc2VkSXRlbTtcbiAgICBpZiAoaXRlbS5pbmRleCA9PT0gY3VycmVudFJhbmdlLnN0YXJ0KSB7XG4gICAgICB0cmFuc3Bvc2VkSXRlbSA9IHtcbiAgICAgICAgdHlwZTogXCJncm91cFwiLFxuICAgICAgICBpbmRleDogY3VycmVudEdyb3VwSW5kZXhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zcG9zZWRJdGVtID0ge1xuICAgICAgICBpbmRleDogaXRlbS5pbmRleCAtIChjdXJyZW50R3JvdXBJbmRleCArIDEpICsgZmlyc3RJdGVtSW5kZXgsXG4gICAgICAgIGdyb3VwSW5kZXg6IGN1cnJlbnRHcm91cEluZGV4XG4gICAgICB9O1xuICAgIH1cbiAgICB0cmFuc3Bvc2VkSXRlbXMucHVzaCh7XG4gICAgICAuLi50cmFuc3Bvc2VkSXRlbSxcbiAgICAgIHNpemU6IGl0ZW0uc2l6ZSxcbiAgICAgIG9mZnNldDogaXRlbS5vZmZzZXQsXG4gICAgICBvcmlnaW5hbEluZGV4OiBpdGVtLmluZGV4LFxuICAgICAgZGF0YTogaXRlbS5kYXRhXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRyYW5zcG9zZWRJdGVtcztcbn1cbmZ1bmN0aW9uIGJ1aWxkTGlzdFN0YXRlKGl0ZW1zLCB0b3BJdGVtcywgdG90YWxDb3VudCwgZ2FwLCBzaXplcywgZmlyc3RJdGVtSW5kZXgpIHtcbiAgY29uc3QgeyBsYXN0U2l6ZSwgbGFzdE9mZnNldCwgbGFzdEluZGV4IH0gPSBzaXplcztcbiAgbGV0IG9mZnNldFRvcCA9IDA7XG4gIGxldCBib3R0b20gPSAwO1xuICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgIG9mZnNldFRvcCA9IGl0ZW1zWzBdLm9mZnNldDtcbiAgICBjb25zdCBsYXN0SXRlbSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIGJvdHRvbSA9IGxhc3RJdGVtLm9mZnNldCArIGxhc3RJdGVtLnNpemU7XG4gIH1cbiAgY29uc3QgaXRlbUNvdW50ID0gdG90YWxDb3VudCAtIGxhc3RJbmRleDtcbiAgY29uc3QgdG90YWwgPSBsYXN0T2Zmc2V0ICsgaXRlbUNvdW50ICogbGFzdFNpemUgKyAoaXRlbUNvdW50IC0gMSkgKiBnYXA7XG4gIGNvbnN0IHRvcCA9IG9mZnNldFRvcDtcbiAgY29uc3Qgb2Zmc2V0Qm90dG9tID0gdG90YWwgLSBib3R0b207XG4gIHJldHVybiB7XG4gICAgaXRlbXM6IHRyYW5zcG9zZUl0ZW1zKGl0ZW1zLCBzaXplcywgZmlyc3RJdGVtSW5kZXgpLFxuICAgIHRvcEl0ZW1zOiB0cmFuc3Bvc2VJdGVtcyh0b3BJdGVtcywgc2l6ZXMsIGZpcnN0SXRlbUluZGV4KSxcbiAgICB0b3BMaXN0SGVpZ2h0OiB0b3BJdGVtcy5yZWR1Y2UoKGhlaWdodCwgaXRlbSkgPT4gaXRlbS5zaXplICsgaGVpZ2h0LCAwKSxcbiAgICBvZmZzZXRUb3AsXG4gICAgb2Zmc2V0Qm90dG9tLFxuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgdG90YWxDb3VudCxcbiAgICBmaXJzdEl0ZW1JbmRleFxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRMaXN0U3RhdGVGcm9tSXRlbUNvdW50KGl0ZW1Db3VudCwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgsIHNpemVzLCBmaXJzdEl0ZW1JbmRleCwgZ2FwLCBkYXRhKSB7XG4gIGxldCBpbmNsdWRlZEdyb3Vwc0NvdW50ID0gMDtcbiAgaWYgKHNpemVzLmdyb3VwSW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBzaXplcy5ncm91cEluZGljZXMpIHtcbiAgICAgIGlmIChpbmRleCAtIGluY2x1ZGVkR3JvdXBzQ291bnQgPj0gaXRlbUNvdW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaW5jbHVkZWRHcm91cHNDb3VudCsrO1xuICAgIH1cbiAgfVxuICBjb25zdCBhZGp1c3RlZENvdW50ID0gaXRlbUNvdW50ICsgaW5jbHVkZWRHcm91cHNDb3VudDtcbiAgY29uc3QgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhOdW1iZXIgPSBnZXRJbml0aWFsVG9wTW9zdEl0ZW1JbmRleE51bWJlcihpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCwgYWRqdXN0ZWRDb3VudCk7XG4gIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogYWRqdXN0ZWRDb3VudCB9KS5tYXAoKF8sIGluZGV4KSA9PiAoe1xuICAgIGluZGV4OiBpbmRleCArIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyLFxuICAgIHNpemU6IDAsXG4gICAgb2Zmc2V0OiAwLFxuICAgIGRhdGE6IGRhdGFbaW5kZXggKyBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleE51bWJlcl1cbiAgfSkpO1xuICByZXR1cm4gYnVpbGRMaXN0U3RhdGUoaXRlbXMsIFtdLCBhZGp1c3RlZENvdW50LCBnYXAsIHNpemVzLCBmaXJzdEl0ZW1JbmRleCk7XG59XG5jb25zdCBsaXN0U3RhdGVTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgeyBzaXplcywgdG90YWxDb3VudCwgZGF0YSwgZmlyc3RJdGVtSW5kZXgsIGdhcCB9LFxuICAgIGdyb3VwZWRMaXN0U3lzdGVtMixcbiAgICB7IHZpc2libGVSYW5nZSwgbGlzdEJvdW5kYXJ5LCB0b3BMaXN0SGVpZ2h0OiByYW5nZVRvcExpc3RIZWlnaHQgfSxcbiAgICB7IHNjcm9sbGVkVG9Jbml0aWFsSXRlbSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXggfSxcbiAgICB7IHRvcExpc3RIZWlnaHQgfSxcbiAgICBzdGF0ZUZsYWdzLFxuICAgIHsgZGlkTW91bnQgfSxcbiAgICB7IHJlY2FsY0luUHJvZ3Jlc3MgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgdG9wSXRlbXNJbmRleGVzID0gc3RhdGVmdWxTdHJlYW0oW10pO1xuICAgIGNvbnN0IGluaXRpYWxJdGVtQ291bnQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBpdGVtc1JlbmRlcmVkID0gc3RyZWFtKCk7XG4gICAgY29ubmVjdChncm91cGVkTGlzdFN5c3RlbTIudG9wSXRlbXNJbmRleGVzLCB0b3BJdGVtc0luZGV4ZXMpO1xuICAgIGNvbnN0IGxpc3RTdGF0ZSA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KFxuICAgICAgICAgIGRpZE1vdW50LFxuICAgICAgICAgIHJlY2FsY0luUHJvZ3Jlc3MsXG4gICAgICAgICAgZHVjKHZpc2libGVSYW5nZSwgdHVwbGVDb21wYXJhdG9yKSxcbiAgICAgICAgICBkdWModG90YWxDb3VudCksXG4gICAgICAgICAgZHVjKHNpemVzKSxcbiAgICAgICAgICBkdWMoaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgpLFxuICAgICAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSxcbiAgICAgICAgICBkdWModG9wSXRlbXNJbmRleGVzKSxcbiAgICAgICAgICBkdWMoZmlyc3RJdGVtSW5kZXgpLFxuICAgICAgICAgIGR1YyhnYXApLFxuICAgICAgICAgIGRhdGFcbiAgICAgICAgKSxcbiAgICAgICAgZmlsdGVyKChbbW91bnQsIHJlY2FsY0luUHJvZ3Jlc3MyLCAsIHRvdGFsQ291bnQyLCAsICwgLCAsICwgLCBkYXRhMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRhQ2hhbmdlSW5Qcm9ncmVzcyA9IGRhdGEyICYmIGRhdGEyLmxlbmd0aCAhPT0gdG90YWxDb3VudDI7XG4gICAgICAgICAgcmV0dXJuIG1vdW50ICYmICFyZWNhbGNJblByb2dyZXNzMiAmJiAhZGF0YUNoYW5nZUluUHJvZ3Jlc3M7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgICxcbiAgICAgICAgICAgIFtzdGFydE9mZnNldCwgZW5kT2Zmc2V0XSxcbiAgICAgICAgICAgIHRvdGFsQ291bnQyLFxuICAgICAgICAgICAgc2l6ZXMyLFxuICAgICAgICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyLFxuICAgICAgICAgICAgc2Nyb2xsZWRUb0luaXRpYWxJdGVtMixcbiAgICAgICAgICAgIHRvcEl0ZW1zSW5kZXhlczIsXG4gICAgICAgICAgICBmaXJzdEl0ZW1JbmRleDIsXG4gICAgICAgICAgICBnYXAyLFxuICAgICAgICAgICAgZGF0YTJcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaXplc1ZhbHVlID0gc2l6ZXMyO1xuICAgICAgICAgICAgY29uc3QgeyBzaXplVHJlZSwgb2Zmc2V0VHJlZSB9ID0gc2l6ZXNWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWxJdGVtQ291bnRWYWx1ZSA9IGdldFZhbHVlKGluaXRpYWxJdGVtQ291bnQpO1xuICAgICAgICAgICAgaWYgKHRvdGFsQ291bnQyID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLkVNUFRZX0xJU1RfU1RBVEUsIHRvdGFsQ291bnQ6IHRvdGFsQ291bnQyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGlmIChpbml0aWFsSXRlbUNvdW50VmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5FTVBUWV9MSVNUX1NUQVRFLCB0b3RhbENvdW50OiB0b3RhbENvdW50MiB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBidWlsZExpc3RTdGF0ZUZyb21JdGVtQ291bnQoaW5pdGlhbEl0ZW1Db3VudFZhbHVlLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDIsIHNpemVzMiwgZmlyc3RJdGVtSW5kZXgyLCBnYXAyLCBkYXRhMiB8fCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbXB0eShzaXplVHJlZSkpIHtcbiAgICAgICAgICAgICAgaWYgKGluaXRpYWxJdGVtQ291bnRWYWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGJ1aWxkTGlzdFN0YXRlKFxuICAgICAgICAgICAgICAgIHByb2JlSXRlbVNldChnZXRJbml0aWFsVG9wTW9zdEl0ZW1JbmRleE51bWJlcihpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDIsIHRvdGFsQ291bnQyKSwgc2l6ZXNWYWx1ZSwgZGF0YTIpLFxuICAgICAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgICAgIHRvdGFsQ291bnQyLFxuICAgICAgICAgICAgICAgIGdhcDIsXG4gICAgICAgICAgICAgICAgc2l6ZXNWYWx1ZSxcbiAgICAgICAgICAgICAgICBmaXJzdEl0ZW1JbmRleDJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9wSXRlbXMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0b3BJdGVtc0luZGV4ZXMyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHRvcEl0ZW1zSW5kZXhlczJbMF07XG4gICAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdG9wSXRlbXNJbmRleGVzMlt0b3BJdGVtc0luZGV4ZXMyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXNXaXRoaW4oc2l6ZVRyZWUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSByYW5nZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZVN0YXJ0SW5kZXggPSBNYXRoLm1heChyYW5nZS5zdGFydCwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VFbmRJbmRleCA9IE1hdGgubWluKHJhbmdlLmVuZCwgZW5kSW5kZXgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSByYW5nZVN0YXJ0SW5kZXg7IGkgPD0gcmFuZ2VFbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB0b3BJdGVtcy5wdXNoKHsgaW5kZXg6IGksIHNpemUsIG9mZnNldCwgZGF0YTogZGF0YTIgJiYgZGF0YTJbaV0gfSk7XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2Nyb2xsZWRUb0luaXRpYWxJdGVtMikge1xuICAgICAgICAgICAgICByZXR1cm4gYnVpbGRMaXN0U3RhdGUoW10sIHRvcEl0ZW1zLCB0b3RhbENvdW50MiwgZ2FwMiwgc2l6ZXNWYWx1ZSwgZmlyc3RJdGVtSW5kZXgyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1pblN0YXJ0SW5kZXggPSB0b3BJdGVtc0luZGV4ZXMyLmxlbmd0aCA+IDAgPyB0b3BJdGVtc0luZGV4ZXMyW3RvcEl0ZW1zSW5kZXhlczIubGVuZ3RoIC0gMV0gKyAxIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFBvaW50UmFuZ2VzID0gcmFuZ2VzV2l0aGluT2Zmc2V0cyhvZmZzZXRUcmVlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBtaW5TdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChvZmZzZXRQb2ludFJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXhJbmRleCA9IHRvdGFsQ291bnQyIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGFwKFtdLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2Ygb2Zmc2V0UG9pbnRSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHJhbmdlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBwb2ludC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlU3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwb2ludC5zaXplO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBzdGFydE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgcmFuZ2VTdGFydEluZGV4ICs9IE1hdGguZmxvb3IoKHN0YXJ0T2Zmc2V0IC0gcG9pbnQub2Zmc2V0ICsgZ2FwMikgLyAoc2l6ZSArIGdhcDIpKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1Db3VudCA9IHJhbmdlU3RhcnRJbmRleCAtIHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGl0ZW1Db3VudCAqIHNpemUgKyBpdGVtQ291bnQgKiBnYXAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VTdGFydEluZGV4IDwgbWluU3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IChtaW5TdGFydEluZGV4IC0gcmFuZ2VTdGFydEluZGV4KSAqIHNpemU7XG4gICAgICAgICAgICAgICAgICByYW5nZVN0YXJ0SW5kZXggPSBtaW5TdGFydEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IE1hdGgubWluKHJhbmdlLmVuZCwgbWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSByYW5nZVN0YXJ0SW5kZXg7IGkgPD0gZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA+PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGluZGV4OiBpLCBzaXplLCBvZmZzZXQsIGRhdGE6IGRhdGEyICYmIGRhdGEyW2ldIH0pO1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHNpemUgKyBnYXAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRMaXN0U3RhdGUoaXRlbXMsIHRvcEl0ZW1zLCB0b3RhbENvdW50MiwgZ2FwMiwgc2l6ZXNWYWx1ZSwgZmlyc3RJdGVtSW5kZXgyKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvciBmaWx0ZXIgbmVlZHMgdG8gYmUgZml4ZWRcbiAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwpLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApLFxuICAgICAgRU1QVFlfTElTVF9TVEFURVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGZpbHRlcihpc0RlZmluZWQpLFxuICAgICAgICBtYXAoKGRhdGEyKSA9PiBkYXRhMiA9PSBudWxsID8gdm9pZCAwIDogZGF0YTIubGVuZ3RoKVxuICAgICAgKSxcbiAgICAgIHRvdGFsQ291bnRcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLnRvcExpc3RIZWlnaHQpXG4gICAgICApLFxuICAgICAgdG9wTGlzdEhlaWdodFxuICAgICk7XG4gICAgY29ubmVjdCh0b3BMaXN0SGVpZ2h0LCByYW5nZVRvcExpc3RIZWlnaHQpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIG1hcCgoc3RhdGUpID0+IFtzdGF0ZS50b3AsIHN0YXRlLmJvdHRvbV0pXG4gICAgICApLFxuICAgICAgbGlzdEJvdW5kYXJ5XG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgbGlzdFN0YXRlLFxuICAgICAgICBtYXAoKHN0YXRlKSA9PiBzdGF0ZS5pdGVtcylcbiAgICAgICksXG4gICAgICBpdGVtc1JlbmRlcmVkXG4gICAgKTtcbiAgICBjb25zdCBlbmRSZWFjaGVkID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIGZpbHRlcigoeyBpdGVtcyB9KSA9PiBpdGVtcy5sZW5ndGggPiAwKSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20odG90YWxDb3VudCwgZGF0YSksXG4gICAgICAgIGZpbHRlcigoW3sgaXRlbXMgfSwgdG90YWxDb3VudDJdKSA9PiBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5vcmlnaW5hbEluZGV4ID09PSB0b3RhbENvdW50MiAtIDEpLFxuICAgICAgICBtYXAoKFssIHRvdGFsQ291bnQyLCBkYXRhMl0pID0+IFt0b3RhbENvdW50MiAtIDEsIGRhdGEyXSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKHR1cGxlQ29tcGFyYXRvciksXG4gICAgICAgIG1hcCgoW2NvdW50XSkgPT4gY291bnQpXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCBzdGFydFJlYWNoZWQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgdGhyb3R0bGVUaW1lKDIwMCksXG4gICAgICAgIGZpbHRlcigoeyBpdGVtcywgdG9wSXRlbXMgfSkgPT4ge1xuICAgICAgICAgIHJldHVybiBpdGVtcy5sZW5ndGggPiAwICYmIGl0ZW1zWzBdLm9yaWdpbmFsSW5kZXggPT09IHRvcEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcCgoeyBpdGVtcyB9KSA9PiBpdGVtc1swXS5pbmRleCksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgIClcbiAgICApO1xuICAgIGNvbnN0IHJhbmdlQ2hhbmdlZCA9IHN0cmVhbUZyb21FbWl0dGVyKFxuICAgICAgcGlwZShcbiAgICAgICAgbGlzdFN0YXRlLFxuICAgICAgICBmaWx0ZXIoKHsgaXRlbXMgfSkgPT4gaXRlbXMubGVuZ3RoID4gMCksXG4gICAgICAgIG1hcCgoeyBpdGVtcyB9KSA9PiB7XG4gICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgIGxldCBlbmRJbmRleCA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGl0ZW1zW3N0YXJ0SW5kZXhdLnR5cGUgPT09IFwiZ3JvdXBcIiAmJiBzdGFydEluZGV4IDwgZW5kSW5kZXgpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGl0ZW1zW2VuZEluZGV4XS50eXBlID09PSBcImdyb3VwXCIgJiYgZW5kSW5kZXggPiBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICBlbmRJbmRleC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnRJbmRleDogaXRlbXNbc3RhcnRJbmRleF0uaW5kZXgsXG4gICAgICAgICAgICBlbmRJbmRleDogaXRlbXNbZW5kSW5kZXhdLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKHJhbmdlQ29tcGFyYXRvcilcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiB7IGxpc3RTdGF0ZSwgdG9wSXRlbXNJbmRleGVzLCBlbmRSZWFjaGVkLCBzdGFydFJlYWNoZWQsIHJhbmdlQ2hhbmdlZCwgaXRlbXNSZW5kZXJlZCwgaW5pdGlhbEl0ZW1Db3VudCwgLi4uc3RhdGVGbGFncyB9O1xuICB9LFxuICB0dXAoXG4gICAgc2l6ZVN5c3RlbSxcbiAgICBncm91cGVkTGlzdFN5c3RlbSxcbiAgICBzaXplUmFuZ2VTeXN0ZW0sXG4gICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0sXG4gICAgc2Nyb2xsVG9JbmRleFN5c3RlbSxcbiAgICBzdGF0ZUZsYWdzU3lzdGVtLFxuICAgIHByb3BzUmVhZHlTeXN0ZW0sXG4gICAgcmVjYWxjU3lzdGVtXG4gICksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCBpbml0aWFsSXRlbUNvdW50U3lzdGVtID0gc3lzdGVtKFxuICAoW3sgc2l6ZXMsIGZpcnN0SXRlbUluZGV4LCBkYXRhLCBnYXAgfSwgeyBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCB9LCB7IGluaXRpYWxJdGVtQ291bnQsIGxpc3RTdGF0ZSB9LCB7IGRpZE1vdW50IH1dKSA9PiB7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShpbml0aWFsSXRlbUNvdW50KSxcbiAgICAgICAgZmlsdGVyKChbLCBjb3VudF0pID0+IGNvdW50ICE9PSAwKSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgsIHNpemVzLCBmaXJzdEl0ZW1JbmRleCwgZ2FwLCBkYXRhKSxcbiAgICAgICAgbWFwKChbWywgY291bnRdLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFZhbHVlLCBzaXplczIsIGZpcnN0SXRlbUluZGV4MiwgZ2FwMiwgZGF0YTIgPSBbXV0pID0+IHtcbiAgICAgICAgICByZXR1cm4gYnVpbGRMaXN0U3RhdGVGcm9tSXRlbUNvdW50KGNvdW50LCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFZhbHVlLCBzaXplczIsIGZpcnN0SXRlbUluZGV4MiwgZ2FwMiwgZGF0YTIpO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIGxpc3RTdGF0ZVxuICAgICk7XG4gICAgcmV0dXJuIHt9O1xuICB9LFxuICB0dXAoc2l6ZVN5c3RlbSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0sIGxpc3RTdGF0ZVN5c3RlbSwgcHJvcHNSZWFkeVN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCBzY3JvbGxTZWVrU3lzdGVtID0gc3lzdGVtKFxuICAoW3sgc2Nyb2xsVmVsb2NpdHkgfV0pID0+IHtcbiAgICBjb25zdCBpc1NlZWtpbmcgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgcmFuZ2VDaGFuZ2VkID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb24gPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbFZlbG9jaXR5LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzY3JvbGxTZWVrQ29uZmlndXJhdGlvbiwgaXNTZWVraW5nLCByYW5nZUNoYW5nZWQpLFxuICAgICAgICBmaWx0ZXIoKFtfLCBjb25maWddKSA9PiAhIWNvbmZpZyksXG4gICAgICAgIG1hcCgoW3NwZWVkLCBjb25maWcsIGlzU2Vla2luZzIsIHJhbmdlXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgZXhpdCwgZW50ZXIgfSA9IGNvbmZpZztcbiAgICAgICAgICBpZiAoaXNTZWVraW5nMikge1xuICAgICAgICAgICAgaWYgKGV4aXQoc3BlZWQsIHJhbmdlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlbnRlcihzcGVlZCwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNTZWVraW5nMjtcbiAgICAgICAgfSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICksXG4gICAgICBpc1NlZWtpbmdcbiAgICApO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoY29tYmluZUxhdGVzdChpc1NlZWtpbmcsIHNjcm9sbFZlbG9jaXR5LCByYW5nZUNoYW5nZWQpLCB3aXRoTGF0ZXN0RnJvbShzY3JvbGxTZWVrQ29uZmlndXJhdGlvbikpLFxuICAgICAgKFtbaXNTZWVraW5nMiwgdmVsb2NpdHksIHJhbmdlXSwgY29uZmlnXSkgPT4gaXNTZWVraW5nMiAmJiBjb25maWcgJiYgY29uZmlnLmNoYW5nZSAmJiBjb25maWcuY2hhbmdlKHZlbG9jaXR5LCByYW5nZSlcbiAgICApO1xuICAgIHJldHVybiB7IGlzU2Vla2luZywgc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb24sIHNjcm9sbFZlbG9jaXR5LCBzY3JvbGxTZWVrUmFuZ2VDaGFuZ2VkOiByYW5nZUNoYW5nZWQgfTtcbiAgfSxcbiAgdHVwKHN0YXRlRmxhZ3NTeXN0ZW0pLFxuICB7IHNpbmdsZXRvbjogdHJ1ZSB9XG4pO1xuY29uc3QgdG9wSXRlbUNvdW50U3lzdGVtID0gc3lzdGVtKChbeyB0b3BJdGVtc0luZGV4ZXMgfV0pID0+IHtcbiAgY29uc3QgdG9wSXRlbUNvdW50ID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIHRvcEl0ZW1Db3VudCxcbiAgICAgIGZpbHRlcigobGVuZ3RoKSA9PiBsZW5ndGggPj0gMCksXG4gICAgICBtYXAoKGxlbmd0aCkgPT4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5tYXAoKF8sIGluZGV4KSA9PiBpbmRleCkpXG4gICAgKSxcbiAgICB0b3BJdGVtc0luZGV4ZXNcbiAgKTtcbiAgcmV0dXJuIHsgdG9wSXRlbUNvdW50IH07XG59LCB0dXAobGlzdFN0YXRlU3lzdGVtKSk7XG5jb25zdCB0b3RhbExpc3RIZWlnaHRTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbeyBmb290ZXJIZWlnaHQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0IH0sIHsgbGlzdFN0YXRlIH1dKSA9PiB7XG4gICAgY29uc3QgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZCA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHRvdGFsTGlzdEhlaWdodCA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KGZvb3RlckhlaWdodCwgZml4ZWRGb290ZXJIZWlnaHQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGxpc3RTdGF0ZSksXG4gICAgICAgIG1hcCgoW2Zvb3RlckhlaWdodDIsIGZpeGVkRm9vdGVySGVpZ2h0MiwgaGVhZGVySGVpZ2h0MiwgZml4ZWRIZWFkZXJIZWlnaHQyLCBsaXN0U3RhdGUyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBmb290ZXJIZWlnaHQyICsgZml4ZWRGb290ZXJIZWlnaHQyICsgaGVhZGVySGVpZ2h0MiArIGZpeGVkSGVhZGVySGVpZ2h0MiArIGxpc3RTdGF0ZTIub2Zmc2V0Qm90dG9tICsgbGlzdFN0YXRlMi5ib3R0b207XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgMFxuICAgICk7XG4gICAgY29ubmVjdChkdWModG90YWxMaXN0SGVpZ2h0KSwgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZCk7XG4gICAgcmV0dXJuIHsgdG90YWxMaXN0SGVpZ2h0LCB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkIH07XG4gIH0sXG4gIHR1cChkb21JT1N5c3RlbSwgbGlzdFN0YXRlU3lzdGVtKSxcbiAgeyBzaW5nbGV0b246IHRydWUgfVxuKTtcbmZ1bmN0aW9uIHNpbXBsZU1lbW9pemUoZnVuYykge1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIGxldCByZXN1bHQ7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICByZXN1bHQgPSBmdW5jKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5jb25zdCBpc01vYmlsZVNhZmFyaSA9IHNpbXBsZU1lbW9pemUoKCkgPT4ge1xuICByZXR1cm4gL2lQKGFkfG9kfGhvbmUpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvV2ViS2l0L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn0pO1xuY29uc3QgdXB3YXJkU2Nyb2xsRml4U3lzdGVtID0gc3lzdGVtKFxuICAoW1xuICAgIHsgc2Nyb2xsQnksIHNjcm9sbFRvcCwgZGV2aWF0aW9uLCBzY3JvbGxpbmdJblByb2dyZXNzIH0sXG4gICAgeyBpc1Njcm9sbGluZywgaXNBdEJvdHRvbSwgc2Nyb2xsRGlyZWN0aW9uLCBsYXN0SnVtcER1ZVRvSXRlbVJlc2l6ZSB9LFxuICAgIHsgbGlzdFN0YXRlIH0sXG4gICAgeyBiZWZvcmVVbnNoaWZ0V2l0aCwgc2hpZnRXaXRoT2Zmc2V0LCBzaXplcywgZ2FwIH0sXG4gICAgeyBsb2cgfSxcbiAgICB7IHJlY2FsY0luUHJvZ3Jlc3MgfVxuICBdKSA9PiB7XG4gICAgY29uc3QgZGV2aWF0aW9uT2Zmc2V0ID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBsaXN0U3RhdGUsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGxhc3RKdW1wRHVlVG9JdGVtUmVzaXplKSxcbiAgICAgICAgc2NhbihcbiAgICAgICAgICAoWywgcHJldkl0ZW1zLCBwcmV2VG90YWxDb3VudCwgcHJldlRvdGFsSGVpZ2h0XSwgW3sgaXRlbXMsIHRvdGFsQ291bnQsIGJvdHRvbSwgb2Zmc2V0Qm90dG9tIH0sIGxhc3RKdW1wRHVlVG9JdGVtUmVzaXplMl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gYm90dG9tICsgb2Zmc2V0Qm90dG9tO1xuICAgICAgICAgICAgbGV0IG5ld0RldiA9IDA7XG4gICAgICAgICAgICBpZiAocHJldlRvdGFsQ291bnQgPT09IHRvdGFsQ291bnQpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZJdGVtcy5sZW5ndGggPiAwICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdFN0YXJ0ID0gaXRlbXNbMF0ub3JpZ2luYWxJbmRleCA9PT0gMCAmJiBwcmV2SXRlbXNbMF0ub3JpZ2luYWxJbmRleCA9PT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWF0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0RldiA9IHRvdGFsSGVpZ2h0IC0gcHJldlRvdGFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgaWYgKG5ld0RldiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdEZXYgKz0gbGFzdEp1bXBEdWVUb0l0ZW1SZXNpemUyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtuZXdEZXYsIGl0ZW1zLCB0b3RhbENvdW50LCB0b3RhbEhlaWdodF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbMCwgW10sIDAsIDBdXG4gICAgICAgICksXG4gICAgICAgIGZpbHRlcigoW2Ftb3VudF0pID0+IGFtb3VudCAhPT0gMCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHNjcm9sbFRvcCwgc2Nyb2xsRGlyZWN0aW9uLCBzY3JvbGxpbmdJblByb2dyZXNzLCBpc0F0Qm90dG9tLCBsb2csIHJlY2FsY0luUHJvZ3Jlc3MpLFxuICAgICAgICBmaWx0ZXIoKFssIHNjcm9sbFRvcDIsIHNjcm9sbERpcmVjdGlvbjIsIHNjcm9sbGluZ0luUHJvZ3Jlc3MyLCAsICwgcmVjYWxjSW5Qcm9ncmVzczJdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICFyZWNhbGNJblByb2dyZXNzMiAmJiAhc2Nyb2xsaW5nSW5Qcm9ncmVzczIgJiYgc2Nyb2xsVG9wMiAhPT0gMCAmJiBzY3JvbGxEaXJlY3Rpb24yID09PSBVUDtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcCgoW1thbW91bnRdLCAsICwgLCAsIGxvZzJdKSA9PiB7XG4gICAgICAgICAgbG9nMihcIlVwd2FyZCBzY3JvbGxpbmcgY29tcGVuc2F0aW9uXCIsIHsgYW1vdW50IH0sIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICk7XG4gICAgZnVuY3Rpb24gc2Nyb2xsQnlXaXRoKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgcHVibGlzaChzY3JvbGxCeSwgeyB0b3A6IC1vZmZzZXQsIGJlaGF2aW9yOiBcImF1dG9cIiB9KTtcbiAgICAgICAgcHVibGlzaChkZXZpYXRpb24sIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGlzaChkZXZpYXRpb24sIDApO1xuICAgICAgICBwdWJsaXNoKHNjcm9sbEJ5LCB7IHRvcDogLW9mZnNldCwgYmVoYXZpb3I6IFwiYXV0b1wiIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUocGlwZShkZXZpYXRpb25PZmZzZXQsIHdpdGhMYXRlc3RGcm9tKGRldmlhdGlvbiwgaXNTY3JvbGxpbmcpKSwgKFtvZmZzZXQsIGRldmlhdGlvbkFtb3VudCwgaXNTY3JvbGxpbmcyXSkgPT4ge1xuICAgICAgaWYgKGlzU2Nyb2xsaW5nMiAmJiBpc01vYmlsZVNhZmFyaSgpKSB7XG4gICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCBkZXZpYXRpb25BbW91bnQgLSBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsQnlXaXRoKC1vZmZzZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN1YnNjcmliZShcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbWJpbmVMYXRlc3Qoc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihpc1Njcm9sbGluZywgZmFsc2UpLCBkZXZpYXRpb24sIHJlY2FsY0luUHJvZ3Jlc3MpLFxuICAgICAgICBmaWx0ZXIoKFtpcywgZGV2aWF0aW9uMiwgcmVjYWxjXSkgPT4gIWlzICYmICFyZWNhbGMgJiYgZGV2aWF0aW9uMiAhPT0gMCksXG4gICAgICAgIG1hcCgoW18sIGRldmlhdGlvbjJdKSA9PiBkZXZpYXRpb24yKSxcbiAgICAgICAgdGhyb3R0bGVUaW1lKDEpXG4gICAgICApLFxuICAgICAgc2Nyb2xsQnlXaXRoXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2hpZnRXaXRoT2Zmc2V0LFxuICAgICAgICBtYXAoKG9mZnNldCkgPT4ge1xuICAgICAgICAgIHJldHVybiB7IHRvcDogLW9mZnNldCB9O1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIHNjcm9sbEJ5XG4gICAgKTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBiZWZvcmVVbnNoaWZ0V2l0aCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMsIGdhcCksXG4gICAgICAgIG1hcCgoW29mZnNldCwgeyBsYXN0U2l6ZTogZGVmYXVsdEl0ZW1TaXplLCBncm91cEluZGljZXMsIHNpemVUcmVlIH0sIGdhcDJdKSA9PiB7XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0SXRlbU9mZnNldChpdGVtQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtQ291bnQgKiAoZGVmYXVsdEl0ZW1TaXplICsgZ2FwMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChncm91cEluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SXRlbU9mZnNldChvZmZzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRHcm91cFNpemUgPSBmaW5kKHNpemVUcmVlLCAwKTtcbiAgICAgICAgICAgIGxldCByZWNvZ25pemVkT2Zmc2V0SXRlbXMgPSAwO1xuICAgICAgICAgICAgbGV0IGdyb3VwSW5kZXggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHJlY29nbml6ZWRPZmZzZXRJdGVtcyA8IG9mZnNldCkge1xuICAgICAgICAgICAgICByZWNvZ25pemVkT2Zmc2V0SXRlbXMrKztcbiAgICAgICAgICAgICAgYW1vdW50ICs9IGRlZmF1bHRHcm91cFNpemU7XG4gICAgICAgICAgICAgIGxldCBncm91cEl0ZW1Db3VudCA9IGdyb3VwSW5kaWNlcy5sZW5ndGggPT09IGdyb3VwSW5kZXggKyAxID8gSW5maW5pdHkgOiBncm91cEluZGljZXNbZ3JvdXBJbmRleCArIDFdIC0gZ3JvdXBJbmRpY2VzW2dyb3VwSW5kZXhdIC0gMTtcbiAgICAgICAgICAgICAgaWYgKHJlY29nbml6ZWRPZmZzZXRJdGVtcyArIGdyb3VwSXRlbUNvdW50ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYW1vdW50IC09IGRlZmF1bHRHcm91cFNpemU7XG4gICAgICAgICAgICAgICAgZ3JvdXBJdGVtQ291bnQgPSBvZmZzZXQgLSByZWNvZ25pemVkT2Zmc2V0SXRlbXMgKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlY29nbml6ZWRPZmZzZXRJdGVtcyArPSBncm91cEl0ZW1Db3VudDtcbiAgICAgICAgICAgICAgYW1vdW50ICs9IGdldEl0ZW1PZmZzZXQoZ3JvdXBJdGVtQ291bnQpO1xuICAgICAgICAgICAgICBncm91cEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICAob2Zmc2V0KSA9PiB7XG4gICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCBvZmZzZXQpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsQnksIHsgdG9wOiBvZmZzZXQgfSk7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHB1Ymxpc2goZGV2aWF0aW9uLCAwKTtcbiAgICAgICAgICAgIHB1Ymxpc2gocmVjYWxjSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiB7IGRldmlhdGlvbiB9O1xuICB9LFxuICB0dXAoZG9tSU9TeXN0ZW0sIHN0YXRlRmxhZ3NTeXN0ZW0sIGxpc3RTdGF0ZVN5c3RlbSwgc2l6ZVN5c3RlbSwgbG9nZ2VyU3lzdGVtLCByZWNhbGNTeXN0ZW0pXG4pO1xuY29uc3QgaW5pdGlhbFNjcm9sbFRvcFN5c3RlbSA9IHN5c3RlbShcbiAgKFt7IGRpZE1vdW50IH0sIHsgc2Nyb2xsVG8gfSwgeyBsaXN0U3RhdGUgfV0pID0+IHtcbiAgICBjb25zdCBpbml0aWFsU2Nyb2xsVG9wID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgZGlkTW91bnQsXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKGluaXRpYWxTY3JvbGxUb3ApLFxuICAgICAgICBmaWx0ZXIoKFssIG9mZnNldF0pID0+IG9mZnNldCAhPT0gMCksXG4gICAgICAgIG1hcCgoWywgb2Zmc2V0XSkgPT4gKHsgdG9wOiBvZmZzZXQgfSkpXG4gICAgICApLFxuICAgICAgKGxvY2F0aW9uKSA9PiB7XG4gICAgICAgIGhhbmRsZU5leHQoXG4gICAgICAgICAgcGlwZShcbiAgICAgICAgICAgIGxpc3RTdGF0ZSxcbiAgICAgICAgICAgIHNraXAoMSksXG4gICAgICAgICAgICBmaWx0ZXIoKHN0YXRlKSA9PiBzdGF0ZS5pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICksXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgcHVibGlzaChzY3JvbGxUbywgbG9jYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXRpYWxTY3JvbGxUb3BcbiAgICB9O1xuICB9LFxuICB0dXAocHJvcHNSZWFkeVN5c3RlbSwgZG9tSU9TeXN0ZW0sIGxpc3RTdGF0ZVN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCBhbGlnblRvQm90dG9tU3lzdGVtID0gc3lzdGVtKFxuICAoW3sgdmlld3BvcnRIZWlnaHQgfSwgeyB0b3RhbExpc3RIZWlnaHQgfV0pID0+IHtcbiAgICBjb25zdCBhbGlnblRvQm90dG9tID0gc3RhdGVmdWxTdHJlYW0oZmFsc2UpO1xuICAgIGNvbnN0IHBhZGRpbmdUb3BBZGRpdGlvbiA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KGFsaWduVG9Cb3R0b20sIHZpZXdwb3J0SGVpZ2h0LCB0b3RhbExpc3RIZWlnaHQpLFxuICAgICAgICBmaWx0ZXIoKFtlbmFibGVkXSkgPT4gZW5hYmxlZCksXG4gICAgICAgIG1hcCgoWywgdmlld3BvcnRIZWlnaHQyLCB0b3RhbExpc3RIZWlnaHQyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCB2aWV3cG9ydEhlaWdodDIgLSB0b3RhbExpc3RIZWlnaHQyKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRocm90dGxlVGltZSgwKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKSxcbiAgICAgIDBcbiAgICApO1xuICAgIHJldHVybiB7IGFsaWduVG9Cb3R0b20sIHBhZGRpbmdUb3BBZGRpdGlvbiB9O1xuICB9LFxuICB0dXAoZG9tSU9TeXN0ZW0sIHRvdGFsTGlzdEhlaWdodFN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCB3aW5kb3dTY3JvbGxlclN5c3RlbSA9IHN5c3RlbSgoW3sgc2Nyb2xsVG8sIHNjcm9sbENvbnRhaW5lclN0YXRlIH1dKSA9PiB7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlID0gc3RyZWFtKCk7XG4gIGNvbnN0IHdpbmRvd1ZpZXdwb3J0UmVjdCA9IHN0cmVhbSgpO1xuICBjb25zdCB3aW5kb3dTY3JvbGxUbyA9IHN0cmVhbSgpO1xuICBjb25zdCB1c2VXaW5kb3dTY3JvbGwgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gIGNvbnN0IGN1c3RvbVNjcm9sbFBhcmVudCA9IHN0YXRlZnVsU3RyZWFtKHZvaWQgMCk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIGNvbWJpbmVMYXRlc3Qod2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUsIHdpbmRvd1ZpZXdwb3J0UmVjdCksXG4gICAgICBtYXAoKFt7IHZpZXdwb3J0SGVpZ2h0LCBzY3JvbGxUb3A6IHdpbmRvd1Njcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0IH0sIHsgb2Zmc2V0VG9wIH1dKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2Nyb2xsVG9wOiBNYXRoLm1heCgwLCB3aW5kb3dTY3JvbGxUb3AgLSBvZmZzZXRUb3ApLFxuICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgICB2aWV3cG9ydEhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApLFxuICAgIHNjcm9sbENvbnRhaW5lclN0YXRlXG4gICk7XG4gIGNvbm5lY3QoXG4gICAgcGlwZShcbiAgICAgIHNjcm9sbFRvLFxuICAgICAgd2l0aExhdGVzdEZyb20od2luZG93Vmlld3BvcnRSZWN0KSxcbiAgICAgIG1hcCgoW3Njcm9sbFRvMiwgeyBvZmZzZXRUb3AgfV0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zY3JvbGxUbzIsXG4gICAgICAgICAgdG9wOiBzY3JvbGxUbzIudG9wICsgb2Zmc2V0VG9wXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICksXG4gICAgd2luZG93U2Nyb2xsVG9cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBjb25maWdcbiAgICB1c2VXaW5kb3dTY3JvbGwsXG4gICAgY3VzdG9tU2Nyb2xsUGFyZW50LFxuICAgIC8vIGlucHV0XG4gICAgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUsXG4gICAgd2luZG93Vmlld3BvcnRSZWN0LFxuICAgIC8vIHNpZ25hbHNcbiAgICB3aW5kb3dTY3JvbGxUb1xuICB9O1xufSwgdHVwKGRvbUlPU3lzdGVtKSk7XG5jb25zdCBkZWZhdWx0Q2FsY3VsYXRlVmlld0xvY2F0aW9uID0gKHtcbiAgaXRlbVRvcDogaXRlbVRvcDIsXG4gIGl0ZW1Cb3R0b20sXG4gIHZpZXdwb3J0VG9wLFxuICB2aWV3cG9ydEJvdHRvbSxcbiAgbG9jYXRpb25QYXJhbXM6IHsgYmVoYXZpb3IsIGFsaWduLCAuLi5yZXN0IH1cbn0pID0+IHtcbiAgaWYgKGl0ZW1Ub3AyIDwgdmlld3BvcnRUb3ApIHtcbiAgICByZXR1cm4geyAuLi5yZXN0LCBiZWhhdmlvciwgYWxpZ246IGFsaWduICE9IG51bGwgPyBhbGlnbiA6IFwic3RhcnRcIiB9O1xuICB9XG4gIGlmIChpdGVtQm90dG9tID4gdmlld3BvcnRCb3R0b20pIHtcbiAgICByZXR1cm4geyAuLi5yZXN0LCBiZWhhdmlvciwgYWxpZ246IGFsaWduICE9IG51bGwgPyBhbGlnbiA6IFwiZW5kXCIgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5jb25zdCBzY3JvbGxJbnRvVmlld1N5c3RlbSA9IHN5c3RlbShcbiAgKFtcbiAgICB7IHNpemVzLCB0b3RhbENvdW50LCBnYXAgfSxcbiAgICB7IHNjcm9sbFRvcCwgdmlld3BvcnRIZWlnaHQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0LCBzY3JvbGxpbmdJblByb2dyZXNzIH0sXG4gICAgeyBzY3JvbGxUb0luZGV4IH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbEludG9WaWV3ID0gc3RyZWFtKCk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIHNjcm9sbEludG9WaWV3LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzaXplcywgdmlld3BvcnRIZWlnaHQsIHRvdGFsQ291bnQsIGhlYWRlckhlaWdodCwgZml4ZWRIZWFkZXJIZWlnaHQsIGZpeGVkRm9vdGVySGVpZ2h0LCBzY3JvbGxUb3ApLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShnYXApLFxuICAgICAgICBtYXAoKFtbdmlld0xvY2F0aW9uLCBzaXplczIsIHZpZXdwb3J0SGVpZ2h0MiwgdG90YWxDb3VudDIsIGhlYWRlckhlaWdodDIsIGZpeGVkSGVhZGVySGVpZ2h0MiwgZml4ZWRGb290ZXJIZWlnaHQyLCBzY3JvbGxUb3AyXSwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIGJlaGF2aW9yLCBhbGlnbiwgY2FsY3VsYXRlVmlld0xvY2F0aW9uID0gZGVmYXVsdENhbGN1bGF0ZVZpZXdMb2NhdGlvbiwgLi4ucmVzdCB9ID0gdmlld0xvY2F0aW9uO1xuICAgICAgICAgIGNvbnN0IGFjdHVhbEluZGV4ID0gb3JpZ2luYWxJbmRleEZyb21Mb2NhdGlvbih2aWV3TG9jYXRpb24sIHNpemVzMiwgdG90YWxDb3VudDIgLSAxKTtcbiAgICAgICAgICBjb25zdCBpdGVtVG9wMiA9IG9mZnNldE9mKGFjdHVhbEluZGV4LCBzaXplczIub2Zmc2V0VHJlZSwgZ2FwMikgKyBoZWFkZXJIZWlnaHQyICsgZml4ZWRIZWFkZXJIZWlnaHQyO1xuICAgICAgICAgIGNvbnN0IGl0ZW1Cb3R0b20gPSBpdGVtVG9wMiArIGZpbmRNYXhLZXlWYWx1ZShzaXplczIuc2l6ZVRyZWUsIGFjdHVhbEluZGV4KVsxXTtcbiAgICAgICAgICBjb25zdCB2aWV3cG9ydFRvcCA9IHNjcm9sbFRvcDIgKyBmaXhlZEhlYWRlckhlaWdodDI7XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSBzY3JvbGxUb3AyICsgdmlld3BvcnRIZWlnaHQyIC0gZml4ZWRGb290ZXJIZWlnaHQyO1xuICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gY2FsY3VsYXRlVmlld0xvY2F0aW9uKHtcbiAgICAgICAgICAgIGl0ZW1Ub3A6IGl0ZW1Ub3AyLFxuICAgICAgICAgICAgaXRlbUJvdHRvbSxcbiAgICAgICAgICAgIHZpZXdwb3J0VG9wLFxuICAgICAgICAgICAgdmlld3BvcnRCb3R0b20sXG4gICAgICAgICAgICBsb2NhdGlvblBhcmFtczogeyBiZWhhdmlvciwgYWxpZ24sIC4uLnJlc3QgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgICAgICAgZG9uZSAmJiBoYW5kbGVOZXh0KFxuICAgICAgICAgICAgICBwaXBlKFxuICAgICAgICAgICAgICAgIHNjcm9sbGluZ0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgPT09IGZhbHNlKSxcbiAgICAgICAgICAgICAgICAvLyBza2lwcyB0aGUgaW5pdGlhbCBwdWJsaXNoIG9mIGZhbHNlLCBhbmQgdGhlIGNsZWFudXAgY2FsbC5cbiAgICAgICAgICAgICAgICAvLyBidXQgaWYgc2Nyb2xsaW5nSW5Qcm9ncmVzcyBpcyB0cnVlLCB3ZSBza2lwIHRoZSBpbml0aWFsIHB1Ymxpc2guXG4gICAgICAgICAgICAgICAgc2tpcChnZXRWYWx1ZShzY3JvbGxpbmdJblByb2dyZXNzKSA/IDEgOiAyKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBkb25lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgICB9KSxcbiAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGwpXG4gICAgICApLFxuICAgICAgc2Nyb2xsVG9JbmRleFxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbEludG9WaWV3XG4gICAgfTtcbiAgfSxcbiAgdHVwKHNpemVTeXN0ZW0sIGRvbUlPU3lzdGVtLCBzY3JvbGxUb0luZGV4U3lzdGVtLCBsaXN0U3RhdGVTeXN0ZW0sIGxvZ2dlclN5c3RlbSksXG4gIHsgc2luZ2xldG9uOiB0cnVlIH1cbik7XG5jb25zdCBzdGF0ZUxvYWRTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAgeyBzaXplcywgc2l6ZVJhbmdlcyB9LFxuICAgIHsgc2Nyb2xsVG9wLCBoZWFkZXJIZWlnaHQgfSxcbiAgICB7IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4IH0sXG4gICAgeyBkaWRNb3VudCB9LFxuICAgIHsgdXNlV2luZG93U2Nyb2xsLCB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSwgd2luZG93Vmlld3BvcnRSZWN0IH1cbiAgXSkgPT4ge1xuICAgIGNvbnN0IGdldFN0YXRlID0gc3RyZWFtKCk7XG4gICAgY29uc3QgcmVzdG9yZVN0YXRlRnJvbSA9IHN0YXRlZnVsU3RyZWFtKHZvaWQgMCk7XG4gICAgY29uc3Qgc3RhdGVmdWxXaW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICAgIGNvbnN0IHN0YXRlZnVsV2luZG93Vmlld3BvcnRSZWN0ID0gc3RhdGVmdWxTdHJlYW0obnVsbCk7XG4gICAgY29ubmVjdCh3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSwgc3RhdGVmdWxXaW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSk7XG4gICAgY29ubmVjdCh3aW5kb3dWaWV3cG9ydFJlY3QsIHN0YXRlZnVsV2luZG93Vmlld3BvcnRSZWN0KTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oc2l6ZXMsIHNjcm9sbFRvcCwgdXNlV2luZG93U2Nyb2xsLCBzdGF0ZWZ1bFdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLCBzdGF0ZWZ1bFdpbmRvd1ZpZXdwb3J0UmVjdCwgaGVhZGVySGVpZ2h0KVxuICAgICAgKSxcbiAgICAgIChbY2FsbGJhY2ssIHNpemVzMiwgc2Nyb2xsVG9wMiwgdXNlV2luZG93U2Nyb2xsMiwgd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGUyLCB3aW5kb3dWaWV3cG9ydFJlY3QyLCBoZWFkZXJIZWlnaHQyXSkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZXMgPSBzaXplVHJlZVRvUmFuZ2VzKHNpemVzMi5zaXplVHJlZSk7XG4gICAgICAgIGlmICh1c2VXaW5kb3dTY3JvbGwyICYmIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlMiAhPT0gbnVsbCAmJiB3aW5kb3dWaWV3cG9ydFJlY3QyICE9PSBudWxsKSB7XG4gICAgICAgICAgc2Nyb2xsVG9wMiA9IHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlMi5zY3JvbGxUb3AgLSB3aW5kb3dWaWV3cG9ydFJlY3QyLm9mZnNldFRvcDtcbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxUb3AyIC09IGhlYWRlckhlaWdodDI7XG4gICAgICAgIGNhbGxiYWNrKHsgcmFuZ2VzLCBzY3JvbGxUb3A6IHNjcm9sbFRvcDIgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25uZWN0KHBpcGUocmVzdG9yZVN0YXRlRnJvbSwgZmlsdGVyKGlzRGVmaW5lZCksIG1hcChsb2NhdGlvbkZyb21TbmFwc2hvdCkpLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRpZE1vdW50LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShyZXN0b3JlU3RhdGVGcm9tKSxcbiAgICAgICAgZmlsdGVyKChbLCBzdGF0ZV0pID0+IHN0YXRlICE9PSB2b2lkIDApLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgICBtYXAoKFssIHNuYXBzaG90XSkgPT4ge1xuICAgICAgICAgIHJldHVybiBzbmFwc2hvdC5yYW5nZXM7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2l6ZVJhbmdlc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFN0YXRlLFxuICAgICAgcmVzdG9yZVN0YXRlRnJvbVxuICAgIH07XG4gIH0sXG4gIHR1cChzaXplU3lzdGVtLCBkb21JT1N5c3RlbSwgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhTeXN0ZW0sIHByb3BzUmVhZHlTeXN0ZW0sIHdpbmRvd1Njcm9sbGVyU3lzdGVtKVxuKTtcbmZ1bmN0aW9uIGxvY2F0aW9uRnJvbVNuYXBzaG90KHNuYXBzaG90KSB7XG4gIHJldHVybiB7IG9mZnNldDogc25hcHNob3Quc2Nyb2xsVG9wLCBpbmRleDogMCwgYWxpZ246IFwic3RhcnRcIiB9O1xufVxuY29uc3QgZmVhdHVyZUdyb3VwMVN5c3RlbSA9IHN5c3RlbShcbiAgKFtcbiAgICBzaXplUmFuZ2UsXG4gICAgaW5pdGlhbEl0ZW1Db3VudCxcbiAgICBwcm9wc1JlYWR5LFxuICAgIHNjcm9sbFNlZWssXG4gICAgdG90YWxMaXN0SGVpZ2h0LFxuICAgIGluaXRpYWxTY3JvbGxUb3BTeXN0ZW0yLFxuICAgIGFsaWduVG9Cb3R0b20sXG4gICAgd2luZG93U2Nyb2xsZXIsXG4gICAgc2Nyb2xsSW50b1ZpZXcsXG4gICAgbG9nZ2VyXG4gIF0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2l6ZVJhbmdlLFxuICAgICAgLi4uaW5pdGlhbEl0ZW1Db3VudCxcbiAgICAgIC4uLnByb3BzUmVhZHksXG4gICAgICAuLi5zY3JvbGxTZWVrLFxuICAgICAgLi4udG90YWxMaXN0SGVpZ2h0LFxuICAgICAgLi4uaW5pdGlhbFNjcm9sbFRvcFN5c3RlbTIsXG4gICAgICAuLi5hbGlnblRvQm90dG9tLFxuICAgICAgLi4ud2luZG93U2Nyb2xsZXIsXG4gICAgICAuLi5zY3JvbGxJbnRvVmlldyxcbiAgICAgIC4uLmxvZ2dlclxuICAgIH07XG4gIH0sXG4gIHR1cChcbiAgICBzaXplUmFuZ2VTeXN0ZW0sXG4gICAgaW5pdGlhbEl0ZW1Db3VudFN5c3RlbSxcbiAgICBwcm9wc1JlYWR5U3lzdGVtLFxuICAgIHNjcm9sbFNlZWtTeXN0ZW0sXG4gICAgdG90YWxMaXN0SGVpZ2h0U3lzdGVtLFxuICAgIGluaXRpYWxTY3JvbGxUb3BTeXN0ZW0sXG4gICAgYWxpZ25Ub0JvdHRvbVN5c3RlbSxcbiAgICB3aW5kb3dTY3JvbGxlclN5c3RlbSxcbiAgICBzY3JvbGxJbnRvVmlld1N5c3RlbSxcbiAgICBsb2dnZXJTeXN0ZW1cbiAgKVxuKTtcbmNvbnN0IGxpc3RTeXN0ZW0gPSBzeXN0ZW0oXG4gIChbXG4gICAge1xuICAgICAgdG90YWxDb3VudCxcbiAgICAgIHNpemVSYW5nZXMsXG4gICAgICBmaXhlZEl0ZW1TaXplLFxuICAgICAgZGVmYXVsdEl0ZW1TaXplLFxuICAgICAgdHJhY2tJdGVtU2l6ZXMsXG4gICAgICBpdGVtU2l6ZSxcbiAgICAgIGRhdGEsXG4gICAgICBmaXJzdEl0ZW1JbmRleCxcbiAgICAgIGdyb3VwSW5kaWNlcyxcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudCxcbiAgICAgIGdhcCxcbiAgICAgIHNpemVzXG4gICAgfSxcbiAgICB7IGluaXRpYWxUb3BNb3N0SXRlbUluZGV4LCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0sIGluaXRpYWxJdGVtRmluYWxMb2NhdGlvblJlYWNoZWQgfSxcbiAgICBkb21JTyxcbiAgICBzdGF0ZUxvYWQsXG4gICAgZm9sbG93T3V0cHV0LFxuICAgIHsgbGlzdFN0YXRlLCB0b3BJdGVtc0luZGV4ZXMsIC4uLmZsYWdzIH0sXG4gICAgeyBzY3JvbGxUb0luZGV4IH0sXG4gICAgXyxcbiAgICB7IHRvcEl0ZW1Db3VudCB9LFxuICAgIHsgZ3JvdXBDb3VudHMgfSxcbiAgICBmZWF0dXJlR3JvdXAxXG4gIF0pID0+IHtcbiAgICBjb25uZWN0KGZsYWdzLnJhbmdlQ2hhbmdlZCwgZmVhdHVyZUdyb3VwMS5zY3JvbGxTZWVrUmFuZ2VDaGFuZ2VkKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgZmVhdHVyZUdyb3VwMS53aW5kb3dWaWV3cG9ydFJlY3QsXG4gICAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLnZpc2libGVIZWlnaHQpXG4gICAgICApLFxuICAgICAgZG9tSU8udmlld3BvcnRIZWlnaHRcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgdG90YWxDb3VudCxcbiAgICAgIGRhdGEsXG4gICAgICBmaXJzdEl0ZW1JbmRleCxcbiAgICAgIHNpemVSYW5nZXMsXG4gICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCxcbiAgICAgIHNjcm9sbGVkVG9Jbml0aWFsSXRlbSxcbiAgICAgIGluaXRpYWxJdGVtRmluYWxMb2NhdGlvblJlYWNoZWQsXG4gICAgICB0b3BJdGVtc0luZGV4ZXMsXG4gICAgICB0b3BJdGVtQ291bnQsXG4gICAgICBncm91cENvdW50cyxcbiAgICAgIGZpeGVkSXRlbUhlaWdodDogZml4ZWRJdGVtU2l6ZSxcbiAgICAgIGRlZmF1bHRJdGVtSGVpZ2h0OiBkZWZhdWx0SXRlbVNpemUsXG4gICAgICBnYXAsXG4gICAgICAuLi5mb2xsb3dPdXRwdXQsXG4gICAgICAvLyBvdXRwdXRcbiAgICAgIHN0YXRlZnVsVG90YWxDb3VudCxcbiAgICAgIGxpc3RTdGF0ZSxcbiAgICAgIHNjcm9sbFRvSW5kZXgsXG4gICAgICB0cmFja0l0ZW1TaXplcyxcbiAgICAgIGl0ZW1TaXplLFxuICAgICAgZ3JvdXBJbmRpY2VzLFxuICAgICAgLy8gZXhwb3J0ZWQgZnJvbSBzdGF0ZUZsYWdzU3lzdGVtXG4gICAgICAuLi5mbGFncyxcbiAgICAgIC8vIHRoZSBiYWcgb2YgSU8gZnJvbSBmZWF0dXJlR3JvdXAxU3lzdGVtXG4gICAgICAuLi5mZWF0dXJlR3JvdXAxLFxuICAgICAgLi4uZG9tSU8sXG4gICAgICBzaXplcyxcbiAgICAgIC4uLnN0YXRlTG9hZFxuICAgIH07XG4gIH0sXG4gIHR1cChcbiAgICBzaXplU3lzdGVtLFxuICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4U3lzdGVtLFxuICAgIGRvbUlPU3lzdGVtLFxuICAgIHN0YXRlTG9hZFN5c3RlbSxcbiAgICBmb2xsb3dPdXRwdXRTeXN0ZW0sXG4gICAgbGlzdFN0YXRlU3lzdGVtLFxuICAgIHNjcm9sbFRvSW5kZXhTeXN0ZW0sXG4gICAgdXB3YXJkU2Nyb2xsRml4U3lzdGVtLFxuICAgIHRvcEl0ZW1Db3VudFN5c3RlbSxcbiAgICBncm91cGVkTGlzdFN5c3RlbSxcbiAgICBmZWF0dXJlR3JvdXAxU3lzdGVtXG4gIClcbik7XG5jb25zdCBXRUJLSVRfU1RJQ0tZID0gXCItd2Via2l0LXN0aWNreVwiO1xuY29uc3QgU1RJQ0tZID0gXCJzdGlja3lcIjtcbmNvbnN0IHBvc2l0aW9uU3RpY2t5Q3NzVmFsdWUgPSBzaW1wbGVNZW1vaXplKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBTVElDS1k7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG5vZGUuc3R5bGUucG9zaXRpb24gPSBXRUJLSVRfU1RJQ0tZO1xuICByZXR1cm4gbm9kZS5zdHlsZS5wb3NpdGlvbiA9PT0gV0VCS0lUX1NUSUNLWSA/IFdFQktJVF9TVElDS1kgOiBTVElDS1k7XG59KTtcbmZ1bmN0aW9uIHVzZVdpbmRvd1ZpZXdwb3J0UmVjdFJlZihjYWxsYmFjaywgY3VzdG9tU2Nyb2xsUGFyZW50LCBza2lwQW5pbWF0aW9uRnJhbWUpIHtcbiAgY29uc3Qgdmlld3BvcnRJbmZvID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBjYWxjdWxhdGVJbmZvID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50ID09PSBudWxsIHx8ICFlbGVtZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHZpc2libGVXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICBsZXQgdmlzaWJsZUhlaWdodCwgb2Zmc2V0VG9wO1xuICAgICAgaWYgKGN1c3RvbVNjcm9sbFBhcmVudCkge1xuICAgICAgICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnRSZWN0ID0gY3VzdG9tU2Nyb2xsUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBkZWx0YVRvcCA9IHJlY3QudG9wIC0gY3VzdG9tU2Nyb2xsUGFyZW50UmVjdC50b3A7XG4gICAgICAgIHZpc2libGVIZWlnaHQgPSBjdXN0b21TY3JvbGxQYXJlbnRSZWN0LmhlaWdodCAtIE1hdGgubWF4KDAsIGRlbHRhVG9wKTtcbiAgICAgICAgb2Zmc2V0VG9wID0gZGVsdGFUb3AgKyBjdXN0b21TY3JvbGxQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaWJsZUhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIE1hdGgubWF4KDAsIHJlY3QudG9wKTtcbiAgICAgICAgb2Zmc2V0VG9wID0gcmVjdC50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICB9XG4gICAgICB2aWV3cG9ydEluZm8uY3VycmVudCA9IHtcbiAgICAgICAgb2Zmc2V0VG9wLFxuICAgICAgICB2aXNpYmxlSGVpZ2h0LFxuICAgICAgICB2aXNpYmxlV2lkdGhcbiAgICAgIH07XG4gICAgICBjYWxsYmFjayh2aWV3cG9ydEluZm8uY3VycmVudCk7XG4gICAgfSxcbiAgICBbY2FsbGJhY2ssIGN1c3RvbVNjcm9sbFBhcmVudF1cbiAgKTtcbiAgY29uc3QgeyBjYWxsYmFja1JlZiwgcmVmIH0gPSB1c2VTaXplV2l0aEVsUmVmKGNhbGN1bGF0ZUluZm8sIHRydWUsIHNraXBBbmltYXRpb25GcmFtZSk7XG4gIGNvbnN0IHNjcm9sbEFuZFJlc2l6ZUV2ZW50SGFuZGxlciA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjYWxjdWxhdGVJbmZvKHJlZi5jdXJyZW50KTtcbiAgfSwgW2NhbGN1bGF0ZUluZm8sIHJlZl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdXN0b21TY3JvbGxQYXJlbnQpIHtcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEFuZFJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGN1c3RvbVNjcm9sbFBhcmVudCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjdXN0b21TY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoY3VzdG9tU2Nyb2xsUGFyZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEFuZFJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBzY3JvbGxBbmRSZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbc2Nyb2xsQW5kUmVzaXplRXZlbnRIYW5kbGVyLCBjdXN0b21TY3JvbGxQYXJlbnRdKTtcbiAgcmV0dXJuIGNhbGxiYWNrUmVmO1xufVxuY29uc3QgVmlydHVvc29Nb2NrQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmNvbnN0IFZpcnR1b3NvR3JpZE1vY2tDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgbGlzdENvbXBvbmVudFByb3BzU3lzdGVtID0gLyogQF9fUFVSRV9fICovIHN5c3RlbSgoKSA9PiB7XG4gIGNvbnN0IGl0ZW1Db250ZW50ID0gc3RhdGVmdWxTdHJlYW0oKGluZGV4KSA9PiBgSXRlbSAke2luZGV4fWApO1xuICBjb25zdCBjb250ZXh0ID0gc3RhdGVmdWxTdHJlYW0obnVsbCk7XG4gIGNvbnN0IGdyb3VwQ29udGVudCA9IHN0YXRlZnVsU3RyZWFtKChpbmRleCkgPT4gYEdyb3VwICR7aW5kZXh9YCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzdGF0ZWZ1bFN0cmVhbSh7fSk7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gc3RhdGVmdWxTdHJlYW0oaWRlbnRpdHkpO1xuICBjb25zdCBIZWFkZXJGb290ZXJUYWcgPSBzdGF0ZWZ1bFN0cmVhbShcImRpdlwiKTtcbiAgY29uc3Qgc2Nyb2xsZXJSZWYgPSBzdGF0ZWZ1bFN0cmVhbShub29wKTtcbiAgY29uc3QgZGlzdGluY3RQcm9wID0gKHByb3BOYW1lLCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21wb25lbnRzLFxuICAgICAgICBtYXAoKGNvbXBvbmVudHMyKSA9PiBjb21wb25lbnRzMltwcm9wTmFtZV0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApLFxuICAgICAgZGVmYXVsdFZhbHVlXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb250ZXh0LFxuICAgIGl0ZW1Db250ZW50LFxuICAgIGdyb3VwQ29udGVudCxcbiAgICBjb21wb25lbnRzLFxuICAgIGNvbXB1dGVJdGVtS2V5LFxuICAgIEhlYWRlckZvb3RlclRhZyxcbiAgICBzY3JvbGxlclJlZixcbiAgICBGb290ZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkZvb3RlclwiKSxcbiAgICBIZWFkZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkhlYWRlclwiKSxcbiAgICBUb3BJdGVtTGlzdENvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVG9wSXRlbUxpc3RcIiksXG4gICAgTGlzdENvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiTGlzdFwiLCBcImRpdlwiKSxcbiAgICBJdGVtQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJJdGVtXCIsIFwiZGl2XCIpLFxuICAgIEdyb3VwQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJHcm91cFwiLCBcImRpdlwiKSxcbiAgICBTY3JvbGxlckNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiU2Nyb2xsZXJcIiwgXCJkaXZcIiksXG4gICAgRW1wdHlQbGFjZWhvbGRlcjogZGlzdGluY3RQcm9wKFwiRW1wdHlQbGFjZWhvbGRlclwiKSxcbiAgICBTY3JvbGxTZWVrUGxhY2Vob2xkZXI6IGRpc3RpbmN0UHJvcChcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKVxuICB9O1xufSk7XG5jb25zdCBjb21iaW5lZFN5c3RlbSQyID0gLyogQF9fUFVSRV9fICovIHN5c3RlbSgoW2xpc3RTeXN0ZW0yLCBwcm9wc1N5c3RlbV0pID0+IHtcbiAgcmV0dXJuIHsgLi4ubGlzdFN5c3RlbTIsIC4uLnByb3BzU3lzdGVtIH07XG59LCB0dXAobGlzdFN5c3RlbSwgbGlzdENvbXBvbmVudFByb3BzU3lzdGVtKSk7XG5jb25zdCBEZWZhdWx0U2Nyb2xsU2Vla1BsYWNlaG9sZGVyJDEgPSAoeyBoZWlnaHQgfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHN0eWxlOiB7IGhlaWdodCB9IH0pO1xuY29uc3QgR1JPVVBfU1RZTEUgPSB7IHBvc2l0aW9uOiBwb3NpdGlvblN0aWNreUNzc1ZhbHVlKCksIHpJbmRleDogMSwgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH07XG5jb25zdCBJVEVNX1NUWUxFJDEgPSB7IG92ZXJmbG93QW5jaG9yOiBcIm5vbmVcIiB9O1xuY29uc3QgSE9SSVpPTlRBTF9JVEVNX1NUWUxFID0geyAuLi5JVEVNX1NUWUxFJDEsIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsIGhlaWdodDogXCIxMDAlXCIgfTtcbmNvbnN0IEl0ZW1zJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb0l0ZW1zKHsgc2hvd1RvcExpc3QgPSBmYWxzZSB9KSB7XG4gIGNvbnN0IGxpc3RTdGF0ZSA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwibGlzdFN0YXRlXCIpO1xuICBjb25zdCBzaXplUmFuZ2VzID0gdXNlUHVibGlzaGVyJDIoXCJzaXplUmFuZ2VzXCIpO1xuICBjb25zdCB1c2VXaW5kb3dTY3JvbGwgPSB1c2VFbWl0dGVyVmFsdWUkMihcInVzZVdpbmRvd1Njcm9sbFwiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSB1c2VQdWJsaXNoZXIkMihcIndpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlXCIpO1xuICBjb25zdCBfc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA9IHVzZVB1Ymxpc2hlciQyKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSBjdXN0b21TY3JvbGxQYXJlbnQgfHwgdXNlV2luZG93U2Nyb2xsID8gd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA6IF9zY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrO1xuICBjb25zdCBpdGVtQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiaXRlbUNvbnRlbnRcIik7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImNvbnRleHRcIik7XG4gIGNvbnN0IGdyb3VwQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiZ3JvdXBDb250ZW50XCIpO1xuICBjb25zdCB0cmFja0l0ZW1TaXplcyA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwidHJhY2tJdGVtU2l6ZXNcIik7XG4gIGNvbnN0IGl0ZW1TaXplID0gdXNlRW1pdHRlclZhbHVlJDIoXCJpdGVtU2l6ZVwiKTtcbiAgY29uc3QgbG9nID0gdXNlRW1pdHRlclZhbHVlJDIoXCJsb2dcIik7XG4gIGNvbnN0IGxpc3RHYXAgPSB1c2VQdWJsaXNoZXIkMihcImdhcFwiKTtcbiAgY29uc3QgaG9yaXpvbnRhbERpcmVjdGlvbiA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiaG9yaXpvbnRhbERpcmVjdGlvblwiKTtcbiAgY29uc3QgeyBjYWxsYmFja1JlZiB9ID0gdXNlQ2hhbmdlZExpc3RDb250ZW50c1NpemVzKFxuICAgIHNpemVSYW5nZXMsXG4gICAgaXRlbVNpemUsXG4gICAgdHJhY2tJdGVtU2l6ZXMsXG4gICAgc2hvd1RvcExpc3QgPyBub29wIDogc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayxcbiAgICBsb2csXG4gICAgbGlzdEdhcCxcbiAgICBjdXN0b21TY3JvbGxQYXJlbnQsXG4gICAgaG9yaXpvbnRhbERpcmVjdGlvbixcbiAgICB1c2VFbWl0dGVyVmFsdWUkMihcInNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXJcIilcbiAgKTtcbiAgY29uc3QgW2RldmlhdGlvbiwgc2V0RGV2aWF0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICB1c2VFbWl0dGVyJDIoXCJkZXZpYXRpb25cIiwgKHZhbHVlKSA9PiB7XG4gICAgaWYgKGRldmlhdGlvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHNldERldmlhdGlvbih2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgRW1wdHlQbGFjZWhvbGRlciA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiRW1wdHlQbGFjZWhvbGRlclwiKTtcbiAgY29uc3QgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyID0gdXNlRW1pdHRlclZhbHVlJDIoXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIikgfHwgRGVmYXVsdFNjcm9sbFNlZWtQbGFjZWhvbGRlciQxO1xuICBjb25zdCBMaXN0Q29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJMaXN0Q29tcG9uZW50XCIpO1xuICBjb25zdCBJdGVtQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJJdGVtQ29tcG9uZW50XCIpO1xuICBjb25zdCBHcm91cENvbXBvbmVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiR3JvdXBDb21wb25lbnRcIik7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjb21wdXRlSXRlbUtleVwiKTtcbiAgY29uc3QgaXNTZWVraW5nID0gdXNlRW1pdHRlclZhbHVlJDIoXCJpc1NlZWtpbmdcIik7XG4gIGNvbnN0IGhhc0dyb3VwczIgPSB1c2VFbWl0dGVyVmFsdWUkMihcImdyb3VwSW5kaWNlc1wiKS5sZW5ndGggPiAwO1xuICBjb25zdCBhbGlnblRvQm90dG9tID0gdXNlRW1pdHRlclZhbHVlJDIoXCJhbGlnblRvQm90dG9tXCIpO1xuICBjb25zdCBpbml0aWFsSXRlbUZpbmFsTG9jYXRpb25SZWFjaGVkID0gdXNlRW1pdHRlclZhbHVlJDIoXCJpbml0aWFsSXRlbUZpbmFsTG9jYXRpb25SZWFjaGVkXCIpO1xuICBjb25zdCBjb250YWluZXJTdHlsZSA9IHNob3dUb3BMaXN0ID8ge30gOiB7XG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICAuLi5ob3Jpem9udGFsRGlyZWN0aW9uID8ge1xuICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgcGFkZGluZ0xlZnQ6IGxpc3RTdGF0ZS5vZmZzZXRUb3AsXG4gICAgICBwYWRkaW5nUmlnaHQ6IGxpc3RTdGF0ZS5vZmZzZXRCb3R0b20sXG4gICAgICBtYXJnaW5MZWZ0OiBkZXZpYXRpb24gIT09IDAgPyBkZXZpYXRpb24gOiBhbGlnblRvQm90dG9tID8gXCJhdXRvXCIgOiAwXG4gICAgfSA6IHtcbiAgICAgIG1hcmdpblRvcDogZGV2aWF0aW9uICE9PSAwID8gZGV2aWF0aW9uIDogYWxpZ25Ub0JvdHRvbSA/IFwiYXV0b1wiIDogMCxcbiAgICAgIHBhZGRpbmdUb3A6IGxpc3RTdGF0ZS5vZmZzZXRUb3AsXG4gICAgICBwYWRkaW5nQm90dG9tOiBsaXN0U3RhdGUub2Zmc2V0Qm90dG9tXG4gICAgfSxcbiAgICAuLi5pbml0aWFsSXRlbUZpbmFsTG9jYXRpb25SZWFjaGVkID8ge30gOiB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfVxuICB9O1xuICBpZiAoIXNob3dUb3BMaXN0ICYmIGxpc3RTdGF0ZS50b3RhbENvdW50ID09PSAwICYmIEVtcHR5UGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChFbXB0eVBsYWNlaG9sZGVyLCB7IC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEVtcHR5UGxhY2Vob2xkZXIsIGNvbnRleHQpIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIExpc3RDb21wb25lbnQsXG4gICAge1xuICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoTGlzdENvbXBvbmVudCwgY29udGV4dCksXG4gICAgICByZWY6IGNhbGxiYWNrUmVmLFxuICAgICAgc3R5bGU6IGNvbnRhaW5lclN0eWxlLFxuICAgICAgXCJkYXRhLXRlc3RpZFwiOiBzaG93VG9wTGlzdCA/IFwidmlydHVvc28tdG9wLWl0ZW0tbGlzdFwiIDogXCJ2aXJ0dW9zby1pdGVtLWxpc3RcIixcbiAgICAgIGNoaWxkcmVuOiAoc2hvd1RvcExpc3QgPyBsaXN0U3RhdGUudG9wSXRlbXMgOiBsaXN0U3RhdGUuaXRlbXMpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW0ub3JpZ2luYWxJbmRleDtcbiAgICAgICAgY29uc3Qga2V5ID0gY29tcHV0ZUl0ZW1LZXkoaW5kZXggKyBsaXN0U3RhdGUuZmlyc3RJdGVtSW5kZXgsIGl0ZW0uZGF0YSwgY29udGV4dCk7XG4gICAgICAgIGlmIChpc1NlZWtpbmcpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBTY3JvbGxTZWVrUGxhY2Vob2xkZXIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFNjcm9sbFNlZWtQbGFjZWhvbGRlciwgY29udGV4dCksXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgaW5kZXg6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICAgIGhlaWdodDogaXRlbS5zaXplLFxuICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUgfHwgXCJpdGVtXCIsXG4gICAgICAgICAgICAgIC4uLml0ZW0udHlwZSA9PT0gXCJncm91cFwiID8ge30gOiB7IGdyb3VwSW5kZXg6IGl0ZW0uZ3JvdXBJbmRleCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICBHcm91cENvbXBvbmVudCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoR3JvdXBDb21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleCxcbiAgICAgICAgICAgICAgXCJkYXRhLWtub3duLXNpemVcIjogaXRlbS5zaXplLFxuICAgICAgICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBpdGVtLmluZGV4LFxuICAgICAgICAgICAgICBzdHlsZTogR1JPVVBfU1RZTEVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBncm91cENvbnRlbnQoaXRlbS5pbmRleCwgY29udGV4dClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgIEl0ZW1Db21wb25lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEl0ZW1Db21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgICAgICAgICAuLi5pdGVtUHJvcElmTm90RG9tRWxlbWVudChJdGVtQ29tcG9uZW50LCBpdGVtLmRhdGEpLFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleCxcbiAgICAgICAgICAgICAgXCJkYXRhLWtub3duLXNpemVcIjogaXRlbS5zaXplLFxuICAgICAgICAgICAgICBcImRhdGEtaXRlbS1pbmRleFwiOiBpdGVtLmluZGV4LFxuICAgICAgICAgICAgICBcImRhdGEtaXRlbS1ncm91cC1pbmRleFwiOiBpdGVtLmdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgIHN0eWxlOiBob3Jpem9udGFsRGlyZWN0aW9uID8gSE9SSVpPTlRBTF9JVEVNX1NUWUxFIDogSVRFTV9TVFlMRSQxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzR3JvdXBzMiA/IGl0ZW1Db250ZW50KGl0ZW0uaW5kZXgsIGl0ZW0uZ3JvdXBJbmRleCwgaXRlbS5kYXRhLCBjb250ZXh0KSA6IGl0ZW1Db250ZW50KGl0ZW0uaW5kZXgsIGl0ZW0uZGF0YSwgY29udGV4dClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgKTtcbn0pO1xuY29uc3Qgc2Nyb2xsZXJTdHlsZSA9IHtcbiAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgb3V0bGluZTogXCJub25lXCIsXG4gIG92ZXJmbG93WTogXCJhdXRvXCIsXG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gIFdlYmtpdE92ZXJmbG93U2Nyb2xsaW5nOiBcInRvdWNoXCJcbn07XG5jb25zdCBob3Jpem9udGFsU2Nyb2xsZXJTdHlsZSA9IHtcbiAgb3V0bGluZTogXCJub25lXCIsXG4gIG92ZXJmbG93WDogXCJhdXRvXCIsXG4gIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbn07XG5jb25zdCB2aWV3cG9ydFN0eWxlID0gKGFsaWduVG9Cb3R0b20pID0+ICh7XG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgdG9wOiAwLFxuICAuLi5hbGlnblRvQm90dG9tID8geyBkaXNwbGF5OiBcImZsZXhcIiwgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIiB9IDoge31cbn0pO1xuY29uc3QgdG9wSXRlbUxpc3RTdHlsZSA9IHtcbiAgd2lkdGg6IFwiMTAwJVwiLFxuICBwb3NpdGlvbjogcG9zaXRpb25TdGlja3lDc3NWYWx1ZSgpLFxuICB0b3A6IDAsXG4gIHpJbmRleDogMVxufTtcbmZ1bmN0aW9uIGNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4geyBjb250ZXh0IH07XG59XG5mdW5jdGlvbiBpdGVtUHJvcElmTm90RG9tRWxlbWVudChlbGVtZW50LCBpdGVtKSB7XG4gIHJldHVybiB7IGl0ZW06IHR5cGVvZiBlbGVtZW50ID09PSBcInN0cmluZ1wiID8gdm9pZCAwIDogaXRlbSB9O1xufVxuY29uc3QgSGVhZGVyJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb0hlYWRlcigpIHtcbiAgY29uc3QgSGVhZGVyMiA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiSGVhZGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCBoZWFkZXJIZWlnaHQgPSB1c2VQdWJsaXNoZXIkMihcImhlYWRlckhlaWdodFwiKTtcbiAgY29uc3QgSGVhZGVyRm9vdGVyVGFnID0gdXNlRW1pdHRlclZhbHVlJDIoXCJIZWFkZXJGb290ZXJUYWdcIik7XG4gIGNvbnN0IHJlZiA9IHVzZVNpemUoXG4gICAgUmVhY3QudXNlTWVtbygoKSA9PiAoZWwpID0+IGhlYWRlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSwgW2hlYWRlckhlaWdodF0pLFxuICAgIHRydWUsXG4gICAgdXNlRW1pdHRlclZhbHVlJDIoXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImNvbnRleHRcIik7XG4gIHJldHVybiBIZWFkZXIyID8gLyogQF9fUFVSRV9fICovIGpzeChIZWFkZXJGb290ZXJUYWcsIHsgcmVmLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChIZWFkZXIyLCB7IC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEhlYWRlcjIsIGNvbnRleHQpIH0pIH0pIDogbnVsbDtcbn0pO1xuY29uc3QgRm9vdGVyJDEgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb0Zvb3RlcigpIHtcbiAgY29uc3QgRm9vdGVyMiA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiRm9vdGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCBmb290ZXJIZWlnaHQgPSB1c2VQdWJsaXNoZXIkMihcImZvb3RlckhlaWdodFwiKTtcbiAgY29uc3QgSGVhZGVyRm9vdGVyVGFnID0gdXNlRW1pdHRlclZhbHVlJDIoXCJIZWFkZXJGb290ZXJUYWdcIik7XG4gIGNvbnN0IHJlZiA9IHVzZVNpemUoXG4gICAgUmVhY3QudXNlTWVtbygoKSA9PiAoZWwpID0+IGZvb3RlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSwgW2Zvb3RlckhlaWdodF0pLFxuICAgIHRydWUsXG4gICAgdXNlRW1pdHRlclZhbHVlJDIoXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUkMihcImNvbnRleHRcIik7XG4gIHJldHVybiBGb290ZXIyID8gLyogQF9fUFVSRV9fICovIGpzeChIZWFkZXJGb290ZXJUYWcsIHsgcmVmLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChGb290ZXIyLCB7IC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEZvb3RlcjIsIGNvbnRleHQpIH0pIH0pIDogbnVsbDtcbn0pO1xuZnVuY3Rpb24gYnVpbGRTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyMiwgdXNlRW1pdHRlcjogdXNlRW1pdHRlcjIsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlMiB9KSB7XG4gIGNvbnN0IFNjcm9sbGVyMiA9IFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29TY3JvbGxlcih7IHN0eWxlLCBjaGlsZHJlbiwgLi4ucHJvcHMgfSkge1xuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSB1c2VQdWJsaXNoZXIyKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gICAgY29uc3QgU2Nyb2xsZXJDb21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUyKFwiU2Nyb2xsZXJDb21wb25lbnRcIik7XG4gICAgY29uc3Qgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCA9IHVzZVB1Ymxpc2hlcjIoXCJzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkXCIpO1xuICAgIGNvbnN0IHNjcm9sbGVyUmVmQ2FsbGJhY2sgPSB1c2VFbWl0dGVyVmFsdWUyKFwic2Nyb2xsZXJSZWZcIik7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZTIoXCJjb250ZXh0XCIpO1xuICAgIGNvbnN0IGhvcml6b250YWxEaXJlY3Rpb24gPSB1c2VFbWl0dGVyVmFsdWUyKFwiaG9yaXpvbnRhbERpcmVjdGlvblwiKSB8fCBmYWxzZTtcbiAgICBjb25zdCB7IHNjcm9sbGVyUmVmLCBzY3JvbGxCeUNhbGxiYWNrLCBzY3JvbGxUb0NhbGxiYWNrIH0gPSB1c2VTY3JvbGxUb3AoXG4gICAgICBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrLFxuICAgICAgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCxcbiAgICAgIFNjcm9sbGVyQ29tcG9uZW50LFxuICAgICAgc2Nyb2xsZXJSZWZDYWxsYmFjayxcbiAgICAgIHZvaWQgMCxcbiAgICAgIGhvcml6b250YWxEaXJlY3Rpb25cbiAgICApO1xuICAgIHVzZUVtaXR0ZXIyKFwic2Nyb2xsVG9cIiwgc2Nyb2xsVG9DYWxsYmFjayk7XG4gICAgdXNlRW1pdHRlcjIoXCJzY3JvbGxCeVwiLCBzY3JvbGxCeUNhbGxiYWNrKTtcbiAgICBjb25zdCBkZWZhdWx0U3R5bGUgPSBob3Jpem9udGFsRGlyZWN0aW9uID8gaG9yaXpvbnRhbFNjcm9sbGVyU3R5bGUgOiBzY3JvbGxlclN0eWxlO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgU2Nyb2xsZXJDb21wb25lbnQsXG4gICAgICB7XG4gICAgICAgIHJlZjogc2Nyb2xsZXJSZWYsXG4gICAgICAgIHN0eWxlOiB7IC4uLmRlZmF1bHRTdHlsZSwgLi4uc3R5bGUgfSxcbiAgICAgICAgXCJkYXRhLXRlc3RpZFwiOiBcInZpcnR1b3NvLXNjcm9sbGVyXCIsXG4gICAgICAgIFwiZGF0YS12aXJ0dW9zby1zY3JvbGxlclwiOiB0cnVlLFxuICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFNjcm9sbGVyQ29tcG9uZW50LCBjb250ZXh0KSxcbiAgICAgICAgY2hpbGRyZW5cbiAgICAgIH1cbiAgICApO1xuICB9KTtcbiAgcmV0dXJuIFNjcm9sbGVyMjtcbn1cbmZ1bmN0aW9uIGJ1aWxkV2luZG93U2Nyb2xsZXIoeyB1c2VQdWJsaXNoZXI6IHVzZVB1Ymxpc2hlcjIsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIyLCB1c2VFbWl0dGVyVmFsdWU6IHVzZUVtaXR0ZXJWYWx1ZTIgfSkge1xuICBjb25zdCBTY3JvbGxlcjIgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvV2luZG93U2Nyb2xsZXIoeyBzdHlsZSwgY2hpbGRyZW4sIC4uLnByb3BzIH0pIHtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyMihcIndpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlXCIpO1xuICAgIGNvbnN0IFNjcm9sbGVyQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlMihcIlNjcm9sbGVyQ29tcG9uZW50XCIpO1xuICAgIGNvbnN0IHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQgPSB1c2VQdWJsaXNoZXIyKFwic21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZFwiKTtcbiAgICBjb25zdCB0b3RhbExpc3RIZWlnaHQgPSB1c2VFbWl0dGVyVmFsdWUyKFwidG90YWxMaXN0SGVpZ2h0XCIpO1xuICAgIGNvbnN0IGRldmlhdGlvbiA9IHVzZUVtaXR0ZXJWYWx1ZTIoXCJkZXZpYXRpb25cIik7XG4gICAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlMihcImN1c3RvbVNjcm9sbFBhcmVudFwiKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlMihcImNvbnRleHRcIik7XG4gICAgY29uc3QgeyBzY3JvbGxlclJlZiwgc2Nyb2xsQnlDYWxsYmFjaywgc2Nyb2xsVG9DYWxsYmFjayB9ID0gdXNlU2Nyb2xsVG9wKFxuICAgICAgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayxcbiAgICAgIHNtb290aFNjcm9sbFRhcmdldFJlYWNoZWQsXG4gICAgICBTY3JvbGxlckNvbXBvbmVudCxcbiAgICAgIG5vb3AsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnRcbiAgICApO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgc2Nyb2xsZXJSZWYuY3VycmVudCA9IGN1c3RvbVNjcm9sbFBhcmVudCA/IGN1c3RvbVNjcm9sbFBhcmVudCA6IHdpbmRvdztcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNjcm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfTtcbiAgICB9LCBbc2Nyb2xsZXJSZWYsIGN1c3RvbVNjcm9sbFBhcmVudF0pO1xuICAgIHVzZUVtaXR0ZXIyKFwid2luZG93U2Nyb2xsVG9cIiwgc2Nyb2xsVG9DYWxsYmFjayk7XG4gICAgdXNlRW1pdHRlcjIoXCJzY3JvbGxCeVwiLCBzY3JvbGxCeUNhbGxiYWNrKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFNjcm9sbGVyQ29tcG9uZW50LFxuICAgICAge1xuICAgICAgICBzdHlsZTogeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLCAuLi5zdHlsZSwgLi4udG90YWxMaXN0SGVpZ2h0ICE9PSAwID8geyBoZWlnaHQ6IHRvdGFsTGlzdEhlaWdodCArIGRldmlhdGlvbiB9IDoge30gfSxcbiAgICAgICAgXCJkYXRhLXZpcnR1b3NvLXNjcm9sbGVyXCI6IHRydWUsXG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChTY3JvbGxlckNvbXBvbmVudCwgY29udGV4dCksXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICB9XG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBTY3JvbGxlcjI7XG59XG5jb25zdCBWaWV3cG9ydCQyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFZpcnR1b3NvTW9ja0NvbnRleHQpO1xuICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHVzZVB1Ymxpc2hlciQyKFwidmlld3BvcnRIZWlnaHRcIik7XG4gIGNvbnN0IGZpeGVkSXRlbUhlaWdodCA9IHVzZVB1Ymxpc2hlciQyKFwiZml4ZWRJdGVtSGVpZ2h0XCIpO1xuICBjb25zdCBhbGlnblRvQm90dG9tID0gdXNlRW1pdHRlclZhbHVlJDIoXCJhbGlnblRvQm90dG9tXCIpO1xuICBjb25zdCBob3Jpem9udGFsRGlyZWN0aW9uID0gdXNlRW1pdHRlclZhbHVlJDIoXCJob3Jpem9udGFsRGlyZWN0aW9uXCIpO1xuICBjb25zdCB2aWV3cG9ydFNpemVDYWxsYmFja01lbW8gPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IGNvbXBvc2Uodmlld3BvcnRIZWlnaHQsIChlbCkgPT4gY29ycmVjdEl0ZW1TaXplKGVsLCBob3Jpem9udGFsRGlyZWN0aW9uID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIikpLFxuICAgIFt2aWV3cG9ydEhlaWdodCwgaG9yaXpvbnRhbERpcmVjdGlvbl1cbiAgKTtcbiAgY29uc3Qgdmlld3BvcnRSZWYgPSB1c2VTaXplKHZpZXdwb3J0U2l6ZUNhbGxiYWNrTWVtbywgdHJ1ZSwgdXNlRW1pdHRlclZhbHVlJDIoXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3R4KSB7XG4gICAgICB2aWV3cG9ydEhlaWdodChjdHgudmlld3BvcnRIZWlnaHQpO1xuICAgICAgZml4ZWRJdGVtSGVpZ2h0KGN0eC5pdGVtSGVpZ2h0KTtcbiAgICB9XG4gIH0sIFtjdHgsIHZpZXdwb3J0SGVpZ2h0LCBmaXhlZEl0ZW1IZWlnaHRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBzdHlsZTogdmlld3BvcnRTdHlsZShhbGlnblRvQm90dG9tKSwgcmVmOiB2aWV3cG9ydFJlZiwgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJlbGVtZW50XCIsIGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IFdpbmRvd1ZpZXdwb3J0JDIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVmlydHVvc29Nb2NrQ29udGV4dCk7XG4gIGNvbnN0IHdpbmRvd1ZpZXdwb3J0UmVjdCA9IHVzZVB1Ymxpc2hlciQyKFwid2luZG93Vmlld3BvcnRSZWN0XCIpO1xuICBjb25zdCBmaXhlZEl0ZW1IZWlnaHQgPSB1c2VQdWJsaXNoZXIkMihcImZpeGVkSXRlbUhlaWdodFwiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IHZpZXdwb3J0UmVmID0gdXNlV2luZG93Vmlld3BvcnRSZWN0UmVmKFxuICAgIHdpbmRvd1ZpZXdwb3J0UmVjdCxcbiAgICBjdXN0b21TY3JvbGxQYXJlbnQsXG4gICAgdXNlRW1pdHRlclZhbHVlJDIoXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICk7XG4gIGNvbnN0IGFsaWduVG9Cb3R0b20gPSB1c2VFbWl0dGVyVmFsdWUkMihcImFsaWduVG9Cb3R0b21cIik7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgZml4ZWRJdGVtSGVpZ2h0KGN0eC5pdGVtSGVpZ2h0KTtcbiAgICAgIHdpbmRvd1ZpZXdwb3J0UmVjdCh7IG9mZnNldFRvcDogMCwgdmlzaWJsZUhlaWdodDogY3R4LnZpZXdwb3J0SGVpZ2h0LCB2aXNpYmxlV2lkdGg6IDEwMCB9KTtcbiAgICB9XG4gIH0sIFtjdHgsIHdpbmRvd1ZpZXdwb3J0UmVjdCwgZml4ZWRJdGVtSGVpZ2h0XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgcmVmOiB2aWV3cG9ydFJlZiwgc3R5bGU6IHZpZXdwb3J0U3R5bGUoYWxpZ25Ub0JvdHRvbSksIFwiZGF0YS12aWV3cG9ydC10eXBlXCI6IFwid2luZG93XCIsIGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IFRvcEl0ZW1MaXN0Q29udGFpbmVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBUb3BJdGVtTGlzdCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiVG9wSXRlbUxpc3RDb21wb25lbnRcIikgfHwgXCJkaXZcIjtcbiAgY29uc3QgaGVhZGVySGVpZ2h0ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJoZWFkZXJIZWlnaHRcIik7XG4gIGNvbnN0IHN0eWxlID0geyAuLi50b3BJdGVtTGlzdFN0eWxlLCBtYXJnaW5Ub3A6IGAke2hlYWRlckhlaWdodH1weGAgfTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQyKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9wSXRlbUxpc3QsIHsgc3R5bGUsIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFRvcEl0ZW1MaXN0LCBjb250ZXh0KSwgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgTGlzdFJvb3QgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBWaXJ0dW9zb1Jvb3QocHJvcHMpIHtcbiAgY29uc3QgdXNlV2luZG93U2Nyb2xsID0gdXNlRW1pdHRlclZhbHVlJDIoXCJ1c2VXaW5kb3dTY3JvbGxcIik7XG4gIGNvbnN0IHNob3dUb3BMaXN0ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJ0b3BJdGVtc0luZGV4ZXNcIikubGVuZ3RoID4gMDtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlJDIoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IFRoZVNjcm9sbGVyID0gY3VzdG9tU2Nyb2xsUGFyZW50IHx8IHVzZVdpbmRvd1Njcm9sbCA/IFdpbmRvd1Njcm9sbGVyJDIgOiBTY3JvbGxlciQyO1xuICBjb25zdCBUaGVWaWV3cG9ydCA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dWaWV3cG9ydCQyIDogVmlld3BvcnQkMjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFRoZVNjcm9sbGVyLCB7IC4uLnByb3BzLCBjaGlsZHJlbjogW1xuICAgIHNob3dUb3BMaXN0ICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9wSXRlbUxpc3RDb250YWluZXIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goSXRlbXMkMSwgeyBzaG93VG9wTGlzdDogdHJ1ZSB9KSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4cyhUaGVWaWV3cG9ydCwgeyBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChIZWFkZXIkMSwge30pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChJdGVtcyQxLCB7fSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KEZvb3RlciQxLCB7fSlcbiAgICBdIH0pXG4gIF0gfSk7XG59KTtcbmNvbnN0IHtcbiAgQ29tcG9uZW50OiBMaXN0LFxuICB1c2VQdWJsaXNoZXI6IHVzZVB1Ymxpc2hlciQyLFxuICB1c2VFbWl0dGVyVmFsdWU6IHVzZUVtaXR0ZXJWYWx1ZSQyLFxuICB1c2VFbWl0dGVyOiB1c2VFbWl0dGVyJDJcbn0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtVG9Db21wb25lbnQoXG4gIGNvbWJpbmVkU3lzdGVtJDIsXG4gIHtcbiAgICByZXF1aXJlZDoge30sXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHJlc3RvcmVTdGF0ZUZyb206IFwicmVzdG9yZVN0YXRlRnJvbVwiLFxuICAgICAgY29udGV4dDogXCJjb250ZXh0XCIsXG4gICAgICBmb2xsb3dPdXRwdXQ6IFwiZm9sbG93T3V0cHV0XCIsXG4gICAgICBpdGVtQ29udGVudDogXCJpdGVtQ29udGVudFwiLFxuICAgICAgZ3JvdXBDb250ZW50OiBcImdyb3VwQ29udGVudFwiLFxuICAgICAgb3ZlcnNjYW46IFwib3ZlcnNjYW5cIixcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogXCJpbmNyZWFzZVZpZXdwb3J0QnlcIixcbiAgICAgIHRvdGFsQ291bnQ6IFwidG90YWxDb3VudFwiLFxuICAgICAgZ3JvdXBDb3VudHM6IFwiZ3JvdXBDb3VudHNcIixcbiAgICAgIHRvcEl0ZW1Db3VudDogXCJ0b3BJdGVtQ291bnRcIixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBcImZpcnN0SXRlbUluZGV4XCIsXG4gICAgICBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleDogXCJpbml0aWFsVG9wTW9zdEl0ZW1JbmRleFwiLFxuICAgICAgY29tcG9uZW50czogXCJjb21wb25lbnRzXCIsXG4gICAgICBhdEJvdHRvbVRocmVzaG9sZDogXCJhdEJvdHRvbVRocmVzaG9sZFwiLFxuICAgICAgYXRUb3BUaHJlc2hvbGQ6IFwiYXRUb3BUaHJlc2hvbGRcIixcbiAgICAgIGNvbXB1dGVJdGVtS2V5OiBcImNvbXB1dGVJdGVtS2V5XCIsXG4gICAgICBkZWZhdWx0SXRlbUhlaWdodDogXCJkZWZhdWx0SXRlbUhlaWdodFwiLFxuICAgICAgZml4ZWRJdGVtSGVpZ2h0OiBcImZpeGVkSXRlbUhlaWdodFwiLFxuICAgICAgaXRlbVNpemU6IFwiaXRlbVNpemVcIixcbiAgICAgIHNjcm9sbFNlZWtDb25maWd1cmF0aW9uOiBcInNjcm9sbFNlZWtDb25maWd1cmF0aW9uXCIsXG4gICAgICBoZWFkZXJGb290ZXJUYWc6IFwiSGVhZGVyRm9vdGVyVGFnXCIsXG4gICAgICBkYXRhOiBcImRhdGFcIixcbiAgICAgIGluaXRpYWxJdGVtQ291bnQ6IFwiaW5pdGlhbEl0ZW1Db3VudFwiLFxuICAgICAgaW5pdGlhbFNjcm9sbFRvcDogXCJpbml0aWFsU2Nyb2xsVG9wXCIsXG4gICAgICBhbGlnblRvQm90dG9tOiBcImFsaWduVG9Cb3R0b21cIixcbiAgICAgIHVzZVdpbmRvd1Njcm9sbDogXCJ1c2VXaW5kb3dTY3JvbGxcIixcbiAgICAgIGN1c3RvbVNjcm9sbFBhcmVudDogXCJjdXN0b21TY3JvbGxQYXJlbnRcIixcbiAgICAgIHNjcm9sbGVyUmVmOiBcInNjcm9sbGVyUmVmXCIsXG4gICAgICBsb2dMZXZlbDogXCJsb2dMZXZlbFwiLFxuICAgICAgaG9yaXpvbnRhbERpcmVjdGlvbjogXCJob3Jpem9udGFsRGlyZWN0aW9uXCIsXG4gICAgICBza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyOiBcInNraXBBbmltYXRpb25GcmFtZUluUmVzaXplT2JzZXJ2ZXJcIlxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgc2Nyb2xsVG9JbmRleDogXCJzY3JvbGxUb0luZGV4XCIsXG4gICAgICBzY3JvbGxJbnRvVmlldzogXCJzY3JvbGxJbnRvVmlld1wiLFxuICAgICAgc2Nyb2xsVG86IFwic2Nyb2xsVG9cIixcbiAgICAgIHNjcm9sbEJ5OiBcInNjcm9sbEJ5XCIsXG4gICAgICBhdXRvc2Nyb2xsVG9Cb3R0b206IFwiYXV0b3Njcm9sbFRvQm90dG9tXCIsXG4gICAgICBnZXRTdGF0ZTogXCJnZXRTdGF0ZVwiXG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgIGlzU2Nyb2xsaW5nOiBcImlzU2Nyb2xsaW5nXCIsXG4gICAgICBlbmRSZWFjaGVkOiBcImVuZFJlYWNoZWRcIixcbiAgICAgIHN0YXJ0UmVhY2hlZDogXCJzdGFydFJlYWNoZWRcIixcbiAgICAgIHJhbmdlQ2hhbmdlZDogXCJyYW5nZUNoYW5nZWRcIixcbiAgICAgIGF0Qm90dG9tU3RhdGVDaGFuZ2U6IFwiYXRCb3R0b21TdGF0ZUNoYW5nZVwiLFxuICAgICAgYXRUb3BTdGF0ZUNoYW5nZTogXCJhdFRvcFN0YXRlQ2hhbmdlXCIsXG4gICAgICB0b3RhbExpc3RIZWlnaHRDaGFuZ2VkOiBcInRvdGFsTGlzdEhlaWdodENoYW5nZWRcIixcbiAgICAgIGl0ZW1zUmVuZGVyZWQ6IFwiaXRlbXNSZW5kZXJlZFwiLFxuICAgICAgZ3JvdXBJbmRpY2VzOiBcImdyb3VwSW5kaWNlc1wiXG4gICAgfVxuICB9LFxuICBMaXN0Um9vdFxuKTtcbmNvbnN0IFNjcm9sbGVyJDIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyJDIsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlJDIsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIkMiB9KTtcbmNvbnN0IFdpbmRvd1Njcm9sbGVyJDIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRXaW5kb3dTY3JvbGxlcih7IHVzZVB1Ymxpc2hlcjogdXNlUHVibGlzaGVyJDIsIHVzZUVtaXR0ZXJWYWx1ZTogdXNlRW1pdHRlclZhbHVlJDIsIHVzZUVtaXR0ZXI6IHVzZUVtaXR0ZXIkMiB9KTtcbmNvbnN0IFZpcnR1b3NvID0gTGlzdDtcbmNvbnN0IEdyb3VwZWRWaXJ0dW9zbyA9IExpc3Q7XG5jb25zdCBJTklUSUFMX0dSSURfU1RBVEUgPSB7XG4gIGl0ZW1zOiBbXSxcbiAgb2Zmc2V0Qm90dG9tOiAwLFxuICBvZmZzZXRUb3A6IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICBpdGVtSGVpZ2h0OiAwLFxuICBpdGVtV2lkdGg6IDBcbn07XG5jb25zdCBQUk9CRV9HUklEX1NUQVRFID0ge1xuICBpdGVtczogW3sgaW5kZXg6IDAgfV0sXG4gIG9mZnNldEJvdHRvbTogMCxcbiAgb2Zmc2V0VG9wOiAwLFxuICB0b3A6IDAsXG4gIGJvdHRvbTogMCxcbiAgaXRlbUhlaWdodDogMCxcbiAgaXRlbVdpZHRoOiAwXG59O1xuY29uc3QgeyByb3VuZCwgY2VpbCwgZmxvb3IsIG1pbiwgbWF4IH0gPSBNYXRoO1xuZnVuY3Rpb24gYnVpbGRQcm9iZUdyaWRTdGF0ZShpdGVtcykge1xuICByZXR1cm4ge1xuICAgIC4uLlBST0JFX0dSSURfU1RBVEUsXG4gICAgaXRlbXNcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkSXRlbXMoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRhdGEpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGVuZEluZGV4IC0gc3RhcnRJbmRleCArIDEgfSkubWFwKChfLCBpKSA9PiB7XG4gICAgY29uc3QgZGF0YUl0ZW0gPSBkYXRhID09PSBudWxsID8gbnVsbCA6IGRhdGFbaSArIHN0YXJ0SW5kZXhdO1xuICAgIHJldHVybiB7IGluZGV4OiBpICsgc3RhcnRJbmRleCwgZGF0YTogZGF0YUl0ZW0gfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnYXBDb21wYXJhdG9yKHByZXYsIG5leHQpIHtcbiAgcmV0dXJuIHByZXYgJiYgcHJldi5jb2x1bW4gPT09IG5leHQuY29sdW1uICYmIHByZXYucm93ID09PSBuZXh0LnJvdztcbn1cbmZ1bmN0aW9uIGRpbWVuc2lvbkNvbXBhcmF0b3IocHJldiwgbmV4dCkge1xuICByZXR1cm4gcHJldiAmJiBwcmV2LndpZHRoID09PSBuZXh0LndpZHRoICYmIHByZXYuaGVpZ2h0ID09PSBuZXh0LmhlaWdodDtcbn1cbmNvbnN0IGdyaWRTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKFxuICAoW1xuICAgIHsgb3ZlcnNjYW4sIHZpc2libGVSYW5nZSwgbGlzdEJvdW5kYXJ5LCBpbmNyZWFzZVZpZXdwb3J0QnkgfSxcbiAgICB7IHNjcm9sbFRvcCwgdmlld3BvcnRIZWlnaHQsIHNjcm9sbEJ5LCBzY3JvbGxUbywgc21vb3RoU2Nyb2xsVGFyZ2V0UmVhY2hlZCwgc2Nyb2xsQ29udGFpbmVyU3RhdGUsIGZvb3RlckhlaWdodCwgaGVhZGVySGVpZ2h0IH0sXG4gICAgc3RhdGVGbGFncyxcbiAgICBzY3JvbGxTZWVrLFxuICAgIHsgcHJvcHNSZWFkeSwgZGlkTW91bnQgfSxcbiAgICB7IHdpbmRvd1ZpZXdwb3J0UmVjdCwgdXNlV2luZG93U2Nyb2xsLCBjdXN0b21TY3JvbGxQYXJlbnQsIHdpbmRvd1Njcm9sbENvbnRhaW5lclN0YXRlLCB3aW5kb3dTY3JvbGxUbyB9LFxuICAgIGxvZ1xuICBdKSA9PiB7XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHN0YXRlZnVsU3RyZWFtKDApO1xuICAgIGNvbnN0IGluaXRpYWxJdGVtQ291bnQgPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBncmlkU3RhdGUgPSBzdGF0ZWZ1bFN0cmVhbShJTklUSUFMX0dSSURfU1RBVEUpO1xuICAgIGNvbnN0IHZpZXdwb3J0RGltZW5zaW9ucyA9IHN0YXRlZnVsU3RyZWFtKHsgaGVpZ2h0OiAwLCB3aWR0aDogMCB9KTtcbiAgICBjb25zdCBpdGVtRGltZW5zaW9ucyA9IHN0YXRlZnVsU3RyZWFtKHsgaGVpZ2h0OiAwLCB3aWR0aDogMCB9KTtcbiAgICBjb25zdCBzY3JvbGxUb0luZGV4ID0gc3RyZWFtKCk7XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gc3RyZWFtKCk7XG4gICAgY29uc3QgZGV2aWF0aW9uID0gc3RhdGVmdWxTdHJlYW0oMCk7XG4gICAgY29uc3QgZGF0YSA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICAgIGNvbnN0IGdhcCA9IHN0YXRlZnVsU3RyZWFtKHsgcm93OiAwLCBjb2x1bW46IDAgfSk7XG4gICAgY29uc3Qgc3RhdGVDaGFuZ2VkID0gc3RyZWFtKCk7XG4gICAgY29uc3QgcmVzdG9yZVN0YXRlRnJvbSA9IHN0cmVhbSgpO1xuICAgIGNvbnN0IHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXggPSBzdGF0ZWZ1bFN0cmVhbSgwKTtcbiAgICBjb25zdCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0gPSBzdGF0ZWZ1bFN0cmVhbSh0cnVlKTtcbiAgICBjb25zdCBzY3JvbGxTY2hlZHVsZWQgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gICAgY29uc3QgaG9yaXpvbnRhbERpcmVjdGlvbiA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBkaWRNb3VudCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20oaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgpLFxuICAgICAgICBmaWx0ZXIoKFtfLCBsb2NhdGlvbl0pID0+ICEhbG9jYXRpb24pXG4gICAgICApLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBwdWJsaXNoKHNjcm9sbGVkVG9Jbml0aWFsSXRlbSwgZmFsc2UpO1xuICAgICAgfVxuICAgICk7XG4gICAgc3Vic2NyaWJlKFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChkaWRNb3VudCwgc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCBpdGVtRGltZW5zaW9ucywgdmlld3BvcnREaW1lbnNpb25zLCBpbml0aWFsVG9wTW9zdEl0ZW1JbmRleCwgc2Nyb2xsU2NoZWR1bGVkKSxcbiAgICAgICAgZmlsdGVyKChbZGlkTW91bnQyLCBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yLCBpdGVtRGltZW5zaW9uczIsIHZpZXdwb3J0RGltZW5zaW9uczIsICwgc2Nyb2xsU2NoZWR1bGVkMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gZGlkTW91bnQyICYmICFzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yICYmIGl0ZW1EaW1lbnNpb25zMi5oZWlnaHQgIT09IDAgJiYgdmlld3BvcnREaW1lbnNpb25zMi5oZWlnaHQgIT09IDAgJiYgIXNjcm9sbFNjaGVkdWxlZDI7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgKFssICwgLCAsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4Ml0pID0+IHtcbiAgICAgICAgcHVibGlzaChzY3JvbGxTY2hlZHVsZWQsIHRydWUpO1xuICAgICAgICBza2lwRnJhbWVzKDEsICgpID0+IHtcbiAgICAgICAgICBwdWJsaXNoKHNjcm9sbFRvSW5kZXgsIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4Mik7XG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVOZXh0KHBpcGUoc2Nyb2xsVG9wKSwgKCkgPT4ge1xuICAgICAgICAgIHB1Ymxpc2gobGlzdEJvdW5kYXJ5LCBbMCwgMF0pO1xuICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsZWRUb0luaXRpYWxJdGVtLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgcmVzdG9yZVN0YXRlRnJvbSxcbiAgICAgICAgZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUgIT09IHZvaWQgMCAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zY3JvbGxUb3AgPiAwKSxcbiAgICAgICAgbWFwVG8oMClcbiAgICAgICksXG4gICAgICBpbml0aWFsSXRlbUNvdW50XG4gICAgKTtcbiAgICBzdWJzY3JpYmUoXG4gICAgICBwaXBlKFxuICAgICAgICBkaWRNb3VudCxcbiAgICAgICAgd2l0aExhdGVzdEZyb20ocmVzdG9yZVN0YXRlRnJvbSksXG4gICAgICAgIGZpbHRlcigoWywgc25hcHNob3RdKSA9PiBzbmFwc2hvdCAhPT0gdm9pZCAwICYmIHNuYXBzaG90ICE9PSBudWxsKVxuICAgICAgKSxcbiAgICAgIChbLCBzbmFwc2hvdF0pID0+IHtcbiAgICAgICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwdWJsaXNoKHZpZXdwb3J0RGltZW5zaW9ucywgc25hcHNob3Qudmlld3BvcnQpLCBwdWJsaXNoKGl0ZW1EaW1lbnNpb25zLCBzbmFwc2hvdCA9PSBudWxsID8gdm9pZCAwIDogc25hcHNob3QuaXRlbSk7XG4gICAgICAgIHB1Ymxpc2goZ2FwLCBzbmFwc2hvdC5nYXApO1xuICAgICAgICBpZiAoc25hcHNob3Quc2Nyb2xsVG9wID4gMCkge1xuICAgICAgICAgIHB1Ymxpc2goc3RhdGVSZXN0b3JlSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgICAgICAgaGFuZGxlTmV4dChwaXBlKHNjcm9sbFRvcCwgc2tpcCgxKSksIChfdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHB1Ymxpc2goc3RhdGVSZXN0b3JlSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHB1Ymxpc2goc2Nyb2xsVG8sIHsgdG9wOiBzbmFwc2hvdC5zY3JvbGxUb3AgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICB2aWV3cG9ydERpbWVuc2lvbnMsXG4gICAgICAgIG1hcCgoeyBoZWlnaHQgfSkgPT4gaGVpZ2h0KVxuICAgICAgKSxcbiAgICAgIHZpZXdwb3J0SGVpZ2h0XG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChcbiAgICAgICAgICBkdWModmlld3BvcnREaW1lbnNpb25zLCBkaW1lbnNpb25Db21wYXJhdG9yKSxcbiAgICAgICAgICBkdWMoaXRlbURpbWVuc2lvbnMsIGRpbWVuc2lvbkNvbXBhcmF0b3IpLFxuICAgICAgICAgIGR1YyhnYXAsIChwcmV2LCBuZXh0KSA9PiBwcmV2ICYmIHByZXYuY29sdW1uID09PSBuZXh0LmNvbHVtbiAmJiBwcmV2LnJvdyA9PT0gbmV4dC5yb3cpLFxuICAgICAgICAgIGR1YyhzY3JvbGxUb3ApXG4gICAgICAgICksXG4gICAgICAgIG1hcCgoW3ZpZXdwb3J0LCBpdGVtLCBnYXAyLCBzY3JvbGxUb3AyXSkgPT4gKHtcbiAgICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIGdhcDogZ2FwMixcbiAgICAgICAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcDJcbiAgICAgICAgfSkpXG4gICAgICApLFxuICAgICAgc3RhdGVDaGFuZ2VkXG4gICAgKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgY29tYmluZUxhdGVzdChcbiAgICAgICAgICBkdWModG90YWxDb3VudCksXG4gICAgICAgICAgdmlzaWJsZVJhbmdlLFxuICAgICAgICAgIGR1YyhnYXAsIGdhcENvbXBhcmF0b3IpLFxuICAgICAgICAgIGR1YyhpdGVtRGltZW5zaW9ucywgZGltZW5zaW9uQ29tcGFyYXRvciksXG4gICAgICAgICAgZHVjKHZpZXdwb3J0RGltZW5zaW9ucywgZGltZW5zaW9uQ29tcGFyYXRvciksXG4gICAgICAgICAgZHVjKGRhdGEpLFxuICAgICAgICAgIGR1Yyhpbml0aWFsSXRlbUNvdW50KSxcbiAgICAgICAgICBkdWMoc3RhdGVSZXN0b3JlSW5Qcm9ncmVzcyksXG4gICAgICAgICAgZHVjKHNjcm9sbGVkVG9Jbml0aWFsSXRlbSksXG4gICAgICAgICAgZHVjKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4KVxuICAgICAgICApLFxuICAgICAgICBmaWx0ZXIoKFssICwgLCAsICwgLCAsIHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MyXSkgPT4ge1xuICAgICAgICAgIHJldHVybiAhc3RhdGVSZXN0b3JlSW5Qcm9ncmVzczI7XG4gICAgICAgIH0pLFxuICAgICAgICBtYXAoXG4gICAgICAgICAgKFtcbiAgICAgICAgICAgIHRvdGFsQ291bnQyLFxuICAgICAgICAgICAgW3N0YXJ0T2Zmc2V0LCBlbmRPZmZzZXRdLFxuICAgICAgICAgICAgZ2FwMixcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICB2aWV3cG9ydCxcbiAgICAgICAgICAgIGRhdGEyLFxuICAgICAgICAgICAgaW5pdGlhbEl0ZW1Db3VudDIsXG4gICAgICAgICAgICAsXG4gICAgICAgICAgICBzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yLFxuICAgICAgICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgyXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyByb3c6IHJvd0dhcCwgY29sdW1uOiBjb2x1bW5HYXAgfSA9IGdhcDI7XG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodDogaXRlbUhlaWdodCwgd2lkdGg6IGl0ZW1XaWR0aCB9ID0gaXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGg6IHZpZXdwb3J0V2lkdGggfSA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgaWYgKGluaXRpYWxJdGVtQ291bnQyID09PSAwICYmICh0b3RhbENvdW50MiA9PT0gMCB8fCB2aWV3cG9ydFdpZHRoID09PSAwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gSU5JVElBTF9HUklEX1NUQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1XaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4MiA9IGdldEluaXRpYWxUb3BNb3N0SXRlbUluZGV4TnVtYmVyKGluaXRpYWxUb3BNb3N0SXRlbUluZGV4MiwgdG90YWxDb3VudDIpO1xuICAgICAgICAgICAgICBjb25zdCBlbmRJbmRleDIgPSBzdGFydEluZGV4MiArIE1hdGgubWF4KGluaXRpYWxJdGVtQ291bnQyIC0gMSwgMCk7XG4gICAgICAgICAgICAgIHJldHVybiBidWlsZFByb2JlR3JpZFN0YXRlKGJ1aWxkSXRlbXMoc3RhcnRJbmRleDIsIGVuZEluZGV4MiwgZGF0YTIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlclJvdyA9IGl0ZW1zUGVyUm93KHZpZXdwb3J0V2lkdGgsIGl0ZW1XaWR0aCwgY29sdW1uR2FwKTtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4O1xuICAgICAgICAgICAgbGV0IGVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKCFzY3JvbGxlZFRvSW5pdGlhbEl0ZW0yKSB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBlbmRJbmRleCA9IC0xO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IDAgJiYgaW5pdGlhbEl0ZW1Db3VudDIgPiAwKSB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgICBlbmRJbmRleCA9IGluaXRpYWxJdGVtQ291bnQyIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBwZXJSb3cgKiBmbG9vcigoc3RhcnRPZmZzZXQgKyByb3dHYXApIC8gKGl0ZW1IZWlnaHQgKyByb3dHYXApKTtcbiAgICAgICAgICAgICAgZW5kSW5kZXggPSBwZXJSb3cgKiBjZWlsKChlbmRPZmZzZXQgKyByb3dHYXApIC8gKGl0ZW1IZWlnaHQgKyByb3dHYXApKSAtIDE7XG4gICAgICAgICAgICAgIGVuZEluZGV4ID0gbWluKHRvdGFsQ291bnQyIC0gMSwgbWF4KGVuZEluZGV4LCBwZXJSb3cgLSAxKSk7XG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBtaW4oZW5kSW5kZXgsIG1heCgwLCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGJ1aWxkSXRlbXMoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRhdGEyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9wLCBib3R0b20gfSA9IGdyaWRMYXlvdXQodmlld3BvcnQsIGdhcDIsIGl0ZW0sIGl0ZW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd0NvdW50ID0gY2VpbCh0b3RhbENvdW50MiAvIHBlclJvdyk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEhlaWdodCA9IHJvd0NvdW50ICogaXRlbUhlaWdodCArIChyb3dDb3VudCAtIDEpICogcm93R2FwO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0Qm90dG9tID0gdG90YWxIZWlnaHQgLSBib3R0b207XG4gICAgICAgICAgICByZXR1cm4geyBpdGVtcywgb2Zmc2V0VG9wOiB0b3AsIG9mZnNldEJvdHRvbSwgdG9wLCBib3R0b20sIGl0ZW1IZWlnaHQsIGl0ZW1XaWR0aCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGdyaWRTdGF0ZVxuICAgICk7XG4gICAgY29ubmVjdChcbiAgICAgIHBpcGUoXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGZpbHRlcigoZGF0YTIpID0+IGRhdGEyICE9PSBudWxsKSxcbiAgICAgICAgbWFwKChkYXRhMikgPT4gZGF0YTIubGVuZ3RoKVxuICAgICAgKSxcbiAgICAgIHRvdGFsQ291bnRcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21iaW5lTGF0ZXN0KHZpZXdwb3J0RGltZW5zaW9ucywgaXRlbURpbWVuc2lvbnMsIGdyaWRTdGF0ZSwgZ2FwKSxcbiAgICAgICAgZmlsdGVyKChbdmlld3BvcnREaW1lbnNpb25zMiwgaXRlbURpbWVuc2lvbnMyLCB7IGl0ZW1zIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCA+IDAgJiYgaXRlbURpbWVuc2lvbnMyLmhlaWdodCAhPT0gMCAmJiB2aWV3cG9ydERpbWVuc2lvbnMyLmhlaWdodCAhPT0gMDtcbiAgICAgICAgfSksXG4gICAgICAgIG1hcCgoW3ZpZXdwb3J0RGltZW5zaW9uczIsIGl0ZW1EaW1lbnNpb25zMiwgeyBpdGVtcyB9LCBnYXAyXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdG9wLCBib3R0b20gfSA9IGdyaWRMYXlvdXQodmlld3BvcnREaW1lbnNpb25zMiwgZ2FwMiwgaXRlbURpbWVuc2lvbnMyLCBpdGVtcyk7XG4gICAgICAgICAgcmV0dXJuIFt0b3AsIGJvdHRvbV07XG4gICAgICAgIH0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCh0dXBsZUNvbXBhcmF0b3IpXG4gICAgICApLFxuICAgICAgbGlzdEJvdW5kYXJ5XG4gICAgKTtcbiAgICBjb25zdCBoYXNTY3JvbGxlZCA9IHN0YXRlZnVsU3RyZWFtKGZhbHNlKTtcbiAgICBjb25uZWN0KFxuICAgICAgcGlwZShcbiAgICAgICAgc2Nyb2xsVG9wLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShoYXNTY3JvbGxlZCksXG4gICAgICAgIG1hcCgoW3Njcm9sbFRvcDIsIGhhc1Njcm9sbGVkMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gaGFzU2Nyb2xsZWQyIHx8IHNjcm9sbFRvcDIgIT09IDA7XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgaGFzU2Nyb2xsZWRcbiAgICApO1xuICAgIGNvbnN0IGVuZFJlYWNoZWQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGR1YyhncmlkU3RhdGUpLFxuICAgICAgICBmaWx0ZXIoKHsgaXRlbXMgfSkgPT4gaXRlbXMubGVuZ3RoID4gMCksXG4gICAgICAgIHdpdGhMYXRlc3RGcm9tKHRvdGFsQ291bnQsIGhhc1Njcm9sbGVkKSxcbiAgICAgICAgZmlsdGVyKChbeyBpdGVtcyB9LCB0b3RhbENvdW50MiwgaGFzU2Nyb2xsZWQyXSkgPT4gaGFzU2Nyb2xsZWQyICYmIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLmluZGV4ID09PSB0b3RhbENvdW50MiAtIDEpLFxuICAgICAgICBtYXAoKFssIHRvdGFsQ291bnQyXSkgPT4gdG90YWxDb3VudDIgLSAxKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3Qgc3RhcnRSZWFjaGVkID0gc3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBkdWMoZ3JpZFN0YXRlKSxcbiAgICAgICAgZmlsdGVyKCh7IGl0ZW1zIH0pID0+IHtcbiAgICAgICAgICByZXR1cm4gaXRlbXMubGVuZ3RoID4gMCAmJiBpdGVtc1swXS5pbmRleCA9PT0gMDtcbiAgICAgICAgfSksXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIG1hcFRvKDApLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCByYW5nZUNoYW5nZWQgPSBzdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGR1YyhncmlkU3RhdGUpLFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbShzdGF0ZVJlc3RvcmVJblByb2dyZXNzKSxcbiAgICAgICAgZmlsdGVyKChbeyBpdGVtcyB9LCBzdGF0ZVJlc3RvcmVJblByb2dyZXNzMl0pID0+IGl0ZW1zLmxlbmd0aCA+IDAgJiYgIXN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MyKSxcbiAgICAgICAgbWFwKChbeyBpdGVtcyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydEluZGV4OiBpdGVtc1swXS5pbmRleCxcbiAgICAgICAgICAgIGVuZEluZGV4OiBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZChyYW5nZUNvbXBhcmF0b3IpLFxuICAgICAgICB0aHJvdHRsZVRpbWUoMClcbiAgICAgIClcbiAgICApO1xuICAgIGNvbm5lY3QocmFuZ2VDaGFuZ2VkLCBzY3JvbGxTZWVrLnNjcm9sbFNlZWtSYW5nZUNoYW5nZWQpO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICBzY3JvbGxUb0luZGV4LFxuICAgICAgICB3aXRoTGF0ZXN0RnJvbSh2aWV3cG9ydERpbWVuc2lvbnMsIGl0ZW1EaW1lbnNpb25zLCB0b3RhbENvdW50LCBnYXApLFxuICAgICAgICBtYXAoKFtsb2NhdGlvbiwgdmlld3BvcnREaW1lbnNpb25zMiwgaXRlbURpbWVuc2lvbnMyLCB0b3RhbENvdW50MiwgZ2FwMl0pID0+IHtcbiAgICAgICAgICBjb25zdCBub3JtYWxMb2NhdGlvbiA9IG5vcm1hbGl6ZUluZGV4TG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgICAgIGNvbnN0IHsgYWxpZ24sIGJlaGF2aW9yLCBvZmZzZXQgfSA9IG5vcm1hbExvY2F0aW9uO1xuICAgICAgICAgIGxldCBpbmRleCA9IG5vcm1hbExvY2F0aW9uLmluZGV4O1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gXCJMQVNUXCIpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdG90YWxDb3VudDIgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbmRleCA9IG1heCgwLCBpbmRleCwgbWluKHRvdGFsQ291bnQyIC0gMSwgaW5kZXgpKTtcbiAgICAgICAgICBsZXQgdG9wID0gaXRlbVRvcCh2aWV3cG9ydERpbWVuc2lvbnMyLCBnYXAyLCBpdGVtRGltZW5zaW9uczIsIGluZGV4KTtcbiAgICAgICAgICBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgIHRvcCA9IHJvdW5kKHRvcCAtIHZpZXdwb3J0RGltZW5zaW9uczIuaGVpZ2h0ICsgaXRlbURpbWVuc2lvbnMyLmhlaWdodCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgdG9wID0gcm91bmQodG9wIC0gdmlld3BvcnREaW1lbnNpb25zMi5oZWlnaHQgLyAyICsgaXRlbURpbWVuc2lvbnMyLmhlaWdodCAvIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICB0b3AgKz0gb2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyB0b3AsIGJlaGF2aW9yIH07XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgc2Nyb2xsVG9cbiAgICApO1xuICAgIGNvbnN0IHRvdGFsTGlzdEhlaWdodCA9IHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBncmlkU3RhdGUsXG4gICAgICAgIG1hcCgoZ3JpZFN0YXRlMikgPT4ge1xuICAgICAgICAgIHJldHVybiBncmlkU3RhdGUyLm9mZnNldEJvdHRvbSArIGdyaWRTdGF0ZTIuYm90dG9tO1xuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbm5lY3QoXG4gICAgICBwaXBlKFxuICAgICAgICB3aW5kb3dWaWV3cG9ydFJlY3QsXG4gICAgICAgIG1hcCgodmlld3BvcnRJbmZvKSA9PiAoeyB3aWR0aDogdmlld3BvcnRJbmZvLnZpc2libGVXaWR0aCwgaGVpZ2h0OiB2aWV3cG9ydEluZm8udmlzaWJsZUhlaWdodCB9KSlcbiAgICAgICksXG4gICAgICB2aWV3cG9ydERpbWVuc2lvbnNcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBpbnB1dFxuICAgICAgZGF0YSxcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgICB2aWV3cG9ydERpbWVuc2lvbnMsXG4gICAgICBpdGVtRGltZW5zaW9ucyxcbiAgICAgIHNjcm9sbFRvcCxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIG92ZXJzY2FuLFxuICAgICAgaW5jcmVhc2VWaWV3cG9ydEJ5LFxuICAgICAgc2Nyb2xsQnksXG4gICAgICBzY3JvbGxUbyxcbiAgICAgIHNjcm9sbFRvSW5kZXgsXG4gICAgICBzbW9vdGhTY3JvbGxUYXJnZXRSZWFjaGVkLFxuICAgICAgd2luZG93Vmlld3BvcnRSZWN0LFxuICAgICAgd2luZG93U2Nyb2xsVG8sXG4gICAgICB1c2VXaW5kb3dTY3JvbGwsXG4gICAgICBjdXN0b21TY3JvbGxQYXJlbnQsXG4gICAgICB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZSxcbiAgICAgIGRldmlhdGlvbixcbiAgICAgIHNjcm9sbENvbnRhaW5lclN0YXRlLFxuICAgICAgZm9vdGVySGVpZ2h0LFxuICAgICAgaGVhZGVySGVpZ2h0LFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudCxcbiAgICAgIGdhcCxcbiAgICAgIHJlc3RvcmVTdGF0ZUZyb20sXG4gICAgICAuLi5zY3JvbGxTZWVrLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXgsXG4gICAgICBob3Jpem9udGFsRGlyZWN0aW9uLFxuICAgICAgLy8gb3V0cHV0XG4gICAgICBncmlkU3RhdGUsXG4gICAgICB0b3RhbExpc3RIZWlnaHQsXG4gICAgICAuLi5zdGF0ZUZsYWdzLFxuICAgICAgc3RhcnRSZWFjaGVkLFxuICAgICAgZW5kUmVhY2hlZCxcbiAgICAgIHJhbmdlQ2hhbmdlZCxcbiAgICAgIHN0YXRlQ2hhbmdlZCxcbiAgICAgIHByb3BzUmVhZHksXG4gICAgICBzdGF0ZVJlc3RvcmVJblByb2dyZXNzLFxuICAgICAgLi4ubG9nXG4gICAgfTtcbiAgfSxcbiAgdHVwKHNpemVSYW5nZVN5c3RlbSwgZG9tSU9TeXN0ZW0sIHN0YXRlRmxhZ3NTeXN0ZW0sIHNjcm9sbFNlZWtTeXN0ZW0sIHByb3BzUmVhZHlTeXN0ZW0sIHdpbmRvd1Njcm9sbGVyU3lzdGVtLCBsb2dnZXJTeXN0ZW0pXG4pO1xuZnVuY3Rpb24gZ3JpZExheW91dCh2aWV3cG9ydCwgZ2FwLCBpdGVtLCBpdGVtcykge1xuICBjb25zdCB7IGhlaWdodDogaXRlbUhlaWdodCB9ID0gaXRlbTtcbiAgaWYgKGl0ZW1IZWlnaHQgPT09IHZvaWQgMCB8fCBpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyB0b3A6IDAsIGJvdHRvbTogMCB9O1xuICB9XG4gIGNvbnN0IHRvcCA9IGl0ZW1Ub3Aodmlld3BvcnQsIGdhcCwgaXRlbSwgaXRlbXNbMF0uaW5kZXgpO1xuICBjb25zdCBib3R0b20gPSBpdGVtVG9wKHZpZXdwb3J0LCBnYXAsIGl0ZW0sIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLmluZGV4KSArIGl0ZW1IZWlnaHQ7XG4gIHJldHVybiB7IHRvcCwgYm90dG9tIH07XG59XG5mdW5jdGlvbiBpdGVtVG9wKHZpZXdwb3J0LCBnYXAsIGl0ZW0sIGluZGV4KSB7XG4gIGNvbnN0IHBlclJvdyA9IGl0ZW1zUGVyUm93KHZpZXdwb3J0LndpZHRoLCBpdGVtLndpZHRoLCBnYXAuY29sdW1uKTtcbiAgY29uc3Qgcm93Q291bnQgPSBmbG9vcihpbmRleCAvIHBlclJvdyk7XG4gIGNvbnN0IHRvcCA9IHJvd0NvdW50ICogaXRlbS5oZWlnaHQgKyBtYXgoMCwgcm93Q291bnQgLSAxKSAqIGdhcC5yb3c7XG4gIHJldHVybiB0b3AgPiAwID8gdG9wICsgZ2FwLnJvdyA6IHRvcDtcbn1cbmZ1bmN0aW9uIGl0ZW1zUGVyUm93KHZpZXdwb3J0V2lkdGgsIGl0ZW1XaWR0aCwgZ2FwKSB7XG4gIHJldHVybiBtYXgoMSwgZmxvb3IoKHZpZXdwb3J0V2lkdGggKyBnYXApIC8gKGZsb29yKGl0ZW1XaWR0aCkgKyBnYXApKSk7XG59XG5jb25zdCBncmlkQ29tcG9uZW50UHJvcHNTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKCgpID0+IHtcbiAgY29uc3QgaXRlbUNvbnRlbnQgPSBzdGF0ZWZ1bFN0cmVhbSgoaW5kZXgpID0+IGBJdGVtICR7aW5kZXh9YCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzdGF0ZWZ1bFN0cmVhbSh7fSk7XG4gIGNvbnN0IGNvbnRleHQgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgY29uc3QgaXRlbUNsYXNzTmFtZSA9IHN0YXRlZnVsU3RyZWFtKFwidmlydHVvc28tZ3JpZC1pdGVtXCIpO1xuICBjb25zdCBsaXN0Q2xhc3NOYW1lID0gc3RhdGVmdWxTdHJlYW0oXCJ2aXJ0dW9zby1ncmlkLWxpc3RcIik7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gc3RhdGVmdWxTdHJlYW0oaWRlbnRpdHkpO1xuICBjb25zdCBoZWFkZXJGb290ZXJUYWcgPSBzdGF0ZWZ1bFN0cmVhbShcImRpdlwiKTtcbiAgY29uc3Qgc2Nyb2xsZXJSZWYgPSBzdGF0ZWZ1bFN0cmVhbShub29wKTtcbiAgY29uc3QgZGlzdGluY3RQcm9wID0gKHByb3BOYW1lLCBkZWZhdWx0VmFsdWUgPSBudWxsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlZnVsU3RyZWFtRnJvbUVtaXR0ZXIoXG4gICAgICBwaXBlKFxuICAgICAgICBjb21wb25lbnRzLFxuICAgICAgICBtYXAoKGNvbXBvbmVudHMyKSA9PiBjb21wb25lbnRzMltwcm9wTmFtZV0pLFxuICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICApLFxuICAgICAgZGVmYXVsdFZhbHVlXG4gICAgKTtcbiAgfTtcbiAgY29uc3QgcmVhZHlTdGF0ZUNoYW5nZWQgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gIGNvbnN0IHJlcG9ydFJlYWR5U3RhdGUgPSBzdGF0ZWZ1bFN0cmVhbShmYWxzZSk7XG4gIGNvbm5lY3QoZHVjKHJlcG9ydFJlYWR5U3RhdGUpLCByZWFkeVN0YXRlQ2hhbmdlZCk7XG4gIHJldHVybiB7XG4gICAgcmVhZHlTdGF0ZUNoYW5nZWQsXG4gICAgcmVwb3J0UmVhZHlTdGF0ZSxcbiAgICBjb250ZXh0LFxuICAgIGl0ZW1Db250ZW50LFxuICAgIGNvbXBvbmVudHMsXG4gICAgY29tcHV0ZUl0ZW1LZXksXG4gICAgaXRlbUNsYXNzTmFtZSxcbiAgICBsaXN0Q2xhc3NOYW1lLFxuICAgIGhlYWRlckZvb3RlclRhZyxcbiAgICBzY3JvbGxlclJlZixcbiAgICBGb290ZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkZvb3RlclwiKSxcbiAgICBIZWFkZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkhlYWRlclwiKSxcbiAgICBMaXN0Q29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJMaXN0XCIsIFwiZGl2XCIpLFxuICAgIEl0ZW1Db21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIkl0ZW1cIiwgXCJkaXZcIiksXG4gICAgU2Nyb2xsZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlNjcm9sbGVyXCIsIFwiZGl2XCIpLFxuICAgIFNjcm9sbFNlZWtQbGFjZWhvbGRlcjogZGlzdGluY3RQcm9wKFwiU2Nyb2xsU2Vla1BsYWNlaG9sZGVyXCIsIFwiZGl2XCIpXG4gIH07XG59KTtcbmNvbnN0IGNvbWJpbmVkU3lzdGVtJDEgPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKChbZ3JpZFN5c3RlbTIsIGdyaWRDb21wb25lbnRQcm9wc1N5c3RlbTJdKSA9PiB7XG4gIHJldHVybiB7IC4uLmdyaWRTeXN0ZW0yLCAuLi5ncmlkQ29tcG9uZW50UHJvcHNTeXN0ZW0yIH07XG59LCB0dXAoZ3JpZFN5c3RlbSwgZ3JpZENvbXBvbmVudFByb3BzU3lzdGVtKSk7XG5jb25zdCBHcmlkSXRlbXMgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QubWVtbyhmdW5jdGlvbiBHcmlkSXRlbXMyKCkge1xuICBjb25zdCBncmlkU3RhdGUgPSB1c2VFbWl0dGVyVmFsdWUkMShcImdyaWRTdGF0ZVwiKTtcbiAgY29uc3QgbGlzdENsYXNzTmFtZSA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwibGlzdENsYXNzTmFtZVwiKTtcbiAgY29uc3QgaXRlbUNsYXNzTmFtZSA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiaXRlbUNsYXNzTmFtZVwiKTtcbiAgY29uc3QgaXRlbUNvbnRlbnQgPSB1c2VFbWl0dGVyVmFsdWUkMShcIml0ZW1Db250ZW50XCIpO1xuICBjb25zdCBjb21wdXRlSXRlbUtleSA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY29tcHV0ZUl0ZW1LZXlcIik7XG4gIGNvbnN0IGlzU2Vla2luZyA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiaXNTZWVraW5nXCIpO1xuICBjb25zdCBzY3JvbGxIZWlnaHRDYWxsYmFjayA9IHVzZVB1Ymxpc2hlciQxKFwic2Nyb2xsSGVpZ2h0XCIpO1xuICBjb25zdCBJdGVtQ29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJJdGVtQ29tcG9uZW50XCIpO1xuICBjb25zdCBMaXN0Q29tcG9uZW50ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJMaXN0Q29tcG9uZW50XCIpO1xuICBjb25zdCBTY3JvbGxTZWVrUGxhY2Vob2xkZXIgPSB1c2VFbWl0dGVyVmFsdWUkMShcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY29udGV4dFwiKTtcbiAgY29uc3QgaXRlbURpbWVuc2lvbnMgPSB1c2VQdWJsaXNoZXIkMShcIml0ZW1EaW1lbnNpb25zXCIpO1xuICBjb25zdCBncmlkR2FwID0gdXNlUHVibGlzaGVyJDEoXCJnYXBcIik7XG4gIGNvbnN0IGxvZyA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwibG9nXCIpO1xuICBjb25zdCBzdGF0ZVJlc3RvcmVJblByb2dyZXNzID0gdXNlRW1pdHRlclZhbHVlJDEoXCJzdGF0ZVJlc3RvcmVJblByb2dyZXNzXCIpO1xuICBjb25zdCByZXBvcnRSZWFkeVN0YXRlID0gdXNlUHVibGlzaGVyJDEoXCJyZXBvcnRSZWFkeVN0YXRlXCIpO1xuICBjb25zdCBsaXN0UmVmID0gdXNlU2l6ZShcbiAgICBSZWFjdC51c2VNZW1vKFxuICAgICAgKCkgPT4gKGVsKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IGVsLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIHNjcm9sbEhlaWdodENhbGxiYWNrKHNjcm9sbEhlaWdodCk7XG4gICAgICAgIGNvbnN0IGZpcnN0SXRlbSA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChmaXJzdEl0ZW0pIHtcbiAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGZpcnN0SXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpdGVtRGltZW5zaW9ucyh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZEdhcCh7XG4gICAgICAgICAgcm93OiByZXNvbHZlR2FwVmFsdWUoXCJyb3ctZ2FwXCIsIGdldENvbXB1dGVkU3R5bGUoZWwpLnJvd0dhcCwgbG9nKSxcbiAgICAgICAgICBjb2x1bW46IHJlc29sdmVHYXBWYWx1ZShcImNvbHVtbi1nYXBcIiwgZ2V0Q29tcHV0ZWRTdHlsZShlbCkuY29sdW1uR2FwLCBsb2cpXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIFtzY3JvbGxIZWlnaHRDYWxsYmFjaywgaXRlbURpbWVuc2lvbnMsIGdyaWRHYXAsIGxvZ11cbiAgICApLFxuICAgIHRydWUsXG4gICAgZmFsc2VcbiAgKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdyaWRTdGF0ZS5pdGVtSGVpZ2h0ID4gMCAmJiBncmlkU3RhdGUuaXRlbVdpZHRoID4gMCkge1xuICAgICAgcmVwb3J0UmVhZHlTdGF0ZSh0cnVlKTtcbiAgICB9XG4gIH0sIFtncmlkU3RhdGVdKTtcbiAgaWYgKHN0YXRlUmVzdG9yZUluUHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBMaXN0Q29tcG9uZW50LFxuICAgIHtcbiAgICAgIHJlZjogbGlzdFJlZixcbiAgICAgIGNsYXNzTmFtZTogbGlzdENsYXNzTmFtZSxcbiAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KExpc3RDb21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgc3R5bGU6IHsgcGFkZGluZ1RvcDogZ3JpZFN0YXRlLm9mZnNldFRvcCwgcGFkZGluZ0JvdHRvbTogZ3JpZFN0YXRlLm9mZnNldEJvdHRvbSB9LFxuICAgICAgXCJkYXRhLXRlc3RpZFwiOiBcInZpcnR1b3NvLWl0ZW0tbGlzdFwiLFxuICAgICAgY2hpbGRyZW46IGdyaWRTdGF0ZS5pdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gY29tcHV0ZUl0ZW1LZXkoaXRlbS5pbmRleCwgaXRlbS5kYXRhLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGlzU2Vla2luZyA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFNjcm9sbFNlZWtQbGFjZWhvbGRlciwgY29udGV4dCksXG4gICAgICAgICAgICBpbmRleDogaXRlbS5pbmRleCxcbiAgICAgICAgICAgIGhlaWdodDogZ3JpZFN0YXRlLml0ZW1IZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogZ3JpZFN0YXRlLml0ZW1XaWR0aFxuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5XG4gICAgICAgICkgOiAvKiBAX19QVVJFX18gKi8gY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBJdGVtQ29tcG9uZW50LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEl0ZW1Db21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBpdGVtQ2xhc3NOYW1lLFxuICAgICAgICAgICAgXCJkYXRhLWluZGV4XCI6IGl0ZW0uaW5kZXgsXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGl0ZW1Db250ZW50KGl0ZW0uaW5kZXgsIGl0ZW0uZGF0YSwgY29udGV4dClcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgfVxuICApO1xufSk7XG5jb25zdCBIZWFkZXIgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvSGVhZGVyMigpIHtcbiAgY29uc3QgSGVhZGVyMiA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiSGVhZGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCBoZWFkZXJIZWlnaHQgPSB1c2VQdWJsaXNoZXIkMShcImhlYWRlckhlaWdodFwiKTtcbiAgY29uc3QgSGVhZGVyRm9vdGVyVGFnID0gdXNlRW1pdHRlclZhbHVlJDEoXCJoZWFkZXJGb290ZXJUYWdcIik7XG4gIGNvbnN0IHJlZiA9IHVzZVNpemUoXG4gICAgUmVhY3QudXNlTWVtbygoKSA9PiAoZWwpID0+IGhlYWRlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSwgW2hlYWRlckhlaWdodF0pLFxuICAgIHRydWUsXG4gICAgZmFsc2VcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIEhlYWRlcjIgPyAvKiBAX19QVVJFX18gKi8ganN4KEhlYWRlckZvb3RlclRhZywgeyByZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEhlYWRlcjIsIHsgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoSGVhZGVyMiwgY29udGV4dCkgfSkgfSkgOiBudWxsO1xufSk7XG5jb25zdCBGb290ZXIgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFZpcnR1b3NvR3JpZEZvb3RlcigpIHtcbiAgY29uc3QgRm9vdGVyMiA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiRm9vdGVyQ29tcG9uZW50XCIpO1xuICBjb25zdCBmb290ZXJIZWlnaHQgPSB1c2VQdWJsaXNoZXIkMShcImZvb3RlckhlaWdodFwiKTtcbiAgY29uc3QgSGVhZGVyRm9vdGVyVGFnID0gdXNlRW1pdHRlclZhbHVlJDEoXCJoZWFkZXJGb290ZXJUYWdcIik7XG4gIGNvbnN0IHJlZiA9IHVzZVNpemUoXG4gICAgUmVhY3QudXNlTWVtbygoKSA9PiAoZWwpID0+IGZvb3RlckhlaWdodChjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSwgW2Zvb3RlckhlaWdodF0pLFxuICAgIHRydWUsXG4gICAgZmFsc2VcbiAgKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY29udGV4dFwiKTtcbiAgcmV0dXJuIEZvb3RlcjIgPyAvKiBAX19QVVJFX18gKi8ganN4KEhlYWRlckZvb3RlclRhZywgeyByZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEZvb3RlcjIsIHsgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoRm9vdGVyMiwgY29udGV4dCkgfSkgfSkgOiBudWxsO1xufSk7XG5jb25zdCBWaWV3cG9ydCQxID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBjdHggPSBSZWFjdC51c2VDb250ZXh0KFZpcnR1b3NvR3JpZE1vY2tDb250ZXh0KTtcbiAgY29uc3QgaXRlbURpbWVuc2lvbnMgPSB1c2VQdWJsaXNoZXIkMShcIml0ZW1EaW1lbnNpb25zXCIpO1xuICBjb25zdCB2aWV3cG9ydERpbWVuc2lvbnMgPSB1c2VQdWJsaXNoZXIkMShcInZpZXdwb3J0RGltZW5zaW9uc1wiKTtcbiAgY29uc3Qgdmlld3BvcnRSZWYgPSB1c2VTaXplKFxuICAgIFJlYWN0LnVzZU1lbW8oXG4gICAgICAoKSA9PiAoZWwpID0+IHtcbiAgICAgICAgdmlld3BvcnREaW1lbnNpb25zKGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgIH0sXG4gICAgICBbdmlld3BvcnREaW1lbnNpb25zXVxuICAgICksXG4gICAgdHJ1ZSxcbiAgICBmYWxzZVxuICApO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdHgpIHtcbiAgICAgIHZpZXdwb3J0RGltZW5zaW9ucyh7IGhlaWdodDogY3R4LnZpZXdwb3J0SGVpZ2h0LCB3aWR0aDogY3R4LnZpZXdwb3J0V2lkdGggfSk7XG4gICAgICBpdGVtRGltZW5zaW9ucyh7IGhlaWdodDogY3R4Lml0ZW1IZWlnaHQsIHdpZHRoOiBjdHguaXRlbVdpZHRoIH0pO1xuICAgIH1cbiAgfSwgW2N0eCwgdmlld3BvcnREaW1lbnNpb25zLCBpdGVtRGltZW5zaW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHN0eWxlOiB2aWV3cG9ydFN0eWxlKGZhbHNlKSwgcmVmOiB2aWV3cG9ydFJlZiwgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgV2luZG93Vmlld3BvcnQkMSA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgY3R4ID0gUmVhY3QudXNlQ29udGV4dChWaXJ0dW9zb0dyaWRNb2NrQ29udGV4dCk7XG4gIGNvbnN0IHdpbmRvd1ZpZXdwb3J0UmVjdCA9IHVzZVB1Ymxpc2hlciQxKFwid2luZG93Vmlld3BvcnRSZWN0XCIpO1xuICBjb25zdCBpdGVtRGltZW5zaW9ucyA9IHVzZVB1Ymxpc2hlciQxKFwiaXRlbURpbWVuc2lvbnNcIik7XG4gIGNvbnN0IGN1c3RvbVNjcm9sbFBhcmVudCA9IHVzZUVtaXR0ZXJWYWx1ZSQxKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICBjb25zdCB2aWV3cG9ydFJlZiA9IHVzZVdpbmRvd1ZpZXdwb3J0UmVjdFJlZih3aW5kb3dWaWV3cG9ydFJlY3QsIGN1c3RvbVNjcm9sbFBhcmVudCwgZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGl0ZW1EaW1lbnNpb25zKHsgaGVpZ2h0OiBjdHguaXRlbUhlaWdodCwgd2lkdGg6IGN0eC5pdGVtV2lkdGggfSk7XG4gICAgICB3aW5kb3dWaWV3cG9ydFJlY3QoeyBvZmZzZXRUb3A6IDAsIHZpc2libGVIZWlnaHQ6IGN0eC52aWV3cG9ydEhlaWdodCwgdmlzaWJsZVdpZHRoOiBjdHgudmlld3BvcnRXaWR0aCB9KTtcbiAgICB9XG4gIH0sIFtjdHgsIHdpbmRvd1ZpZXdwb3J0UmVjdCwgaXRlbURpbWVuc2lvbnNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyByZWY6IHZpZXdwb3J0UmVmLCBzdHlsZTogdmlld3BvcnRTdHlsZShmYWxzZSksIGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IEdyaWRSb290ID0gLyogQF9fUFVSRV9fICovIFJlYWN0Lm1lbW8oZnVuY3Rpb24gR3JpZFJvb3QyKHsgLi4ucHJvcHMgfSkge1xuICBjb25zdCB1c2VXaW5kb3dTY3JvbGwgPSB1c2VFbWl0dGVyVmFsdWUkMShcInVzZVdpbmRvd1Njcm9sbFwiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlJDEoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IFRoZVNjcm9sbGVyID0gY3VzdG9tU2Nyb2xsUGFyZW50IHx8IHVzZVdpbmRvd1Njcm9sbCA/IFdpbmRvd1Njcm9sbGVyJDEgOiBTY3JvbGxlciQxO1xuICBjb25zdCBUaGVWaWV3cG9ydCA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dWaWV3cG9ydCQxIDogVmlld3BvcnQkMTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVGhlU2Nyb2xsZXIsIHsgLi4ucHJvcHMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhUaGVWaWV3cG9ydCwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goSGVhZGVyLCB7fSksXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChHcmlkSXRlbXMsIHt9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KEZvb3Rlciwge30pXG4gIF0gfSkgfSk7XG59KTtcbmNvbnN0IHtcbiAgQ29tcG9uZW50OiBHcmlkLFxuICB1c2VQdWJsaXNoZXI6IHVzZVB1Ymxpc2hlciQxLFxuICB1c2VFbWl0dGVyVmFsdWU6IHVzZUVtaXR0ZXJWYWx1ZSQxLFxuICB1c2VFbWl0dGVyOiB1c2VFbWl0dGVyJDFcbn0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtVG9Db21wb25lbnQoXG4gIGNvbWJpbmVkU3lzdGVtJDEsXG4gIHtcbiAgICBvcHRpb25hbDoge1xuICAgICAgY29udGV4dDogXCJjb250ZXh0XCIsXG4gICAgICB0b3RhbENvdW50OiBcInRvdGFsQ291bnRcIixcbiAgICAgIG92ZXJzY2FuOiBcIm92ZXJzY2FuXCIsXG4gICAgICBpdGVtQ29udGVudDogXCJpdGVtQ29udGVudFwiLFxuICAgICAgY29tcG9uZW50czogXCJjb21wb25lbnRzXCIsXG4gICAgICBjb21wdXRlSXRlbUtleTogXCJjb21wdXRlSXRlbUtleVwiLFxuICAgICAgZGF0YTogXCJkYXRhXCIsXG4gICAgICBpbml0aWFsSXRlbUNvdW50OiBcImluaXRpYWxJdGVtQ291bnRcIixcbiAgICAgIHNjcm9sbFNlZWtDb25maWd1cmF0aW9uOiBcInNjcm9sbFNlZWtDb25maWd1cmF0aW9uXCIsXG4gICAgICBoZWFkZXJGb290ZXJUYWc6IFwiaGVhZGVyRm9vdGVyVGFnXCIsXG4gICAgICBsaXN0Q2xhc3NOYW1lOiBcImxpc3RDbGFzc05hbWVcIixcbiAgICAgIGl0ZW1DbGFzc05hbWU6IFwiaXRlbUNsYXNzTmFtZVwiLFxuICAgICAgdXNlV2luZG93U2Nyb2xsOiBcInVzZVdpbmRvd1Njcm9sbFwiLFxuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50OiBcImN1c3RvbVNjcm9sbFBhcmVudFwiLFxuICAgICAgc2Nyb2xsZXJSZWY6IFwic2Nyb2xsZXJSZWZcIixcbiAgICAgIGxvZ0xldmVsOiBcImxvZ0xldmVsXCIsXG4gICAgICByZXN0b3JlU3RhdGVGcm9tOiBcInJlc3RvcmVTdGF0ZUZyb21cIixcbiAgICAgIGluaXRpYWxUb3BNb3N0SXRlbUluZGV4OiBcImluaXRpYWxUb3BNb3N0SXRlbUluZGV4XCIsXG4gICAgICBpbmNyZWFzZVZpZXdwb3J0Qnk6IFwiaW5jcmVhc2VWaWV3cG9ydEJ5XCJcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHNjcm9sbFRvOiBcInNjcm9sbFRvXCIsXG4gICAgICBzY3JvbGxCeTogXCJzY3JvbGxCeVwiLFxuICAgICAgc2Nyb2xsVG9JbmRleDogXCJzY3JvbGxUb0luZGV4XCJcbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgaXNTY3JvbGxpbmc6IFwiaXNTY3JvbGxpbmdcIixcbiAgICAgIGVuZFJlYWNoZWQ6IFwiZW5kUmVhY2hlZFwiLFxuICAgICAgc3RhcnRSZWFjaGVkOiBcInN0YXJ0UmVhY2hlZFwiLFxuICAgICAgcmFuZ2VDaGFuZ2VkOiBcInJhbmdlQ2hhbmdlZFwiLFxuICAgICAgYXRCb3R0b21TdGF0ZUNoYW5nZTogXCJhdEJvdHRvbVN0YXRlQ2hhbmdlXCIsXG4gICAgICBhdFRvcFN0YXRlQ2hhbmdlOiBcImF0VG9wU3RhdGVDaGFuZ2VcIixcbiAgICAgIHN0YXRlQ2hhbmdlZDogXCJzdGF0ZUNoYW5nZWRcIixcbiAgICAgIHJlYWR5U3RhdGVDaGFuZ2VkOiBcInJlYWR5U3RhdGVDaGFuZ2VkXCJcbiAgICB9XG4gIH0sXG4gIEdyaWRSb290XG4pO1xuY29uc3QgU2Nyb2xsZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZFNjcm9sbGVyKHsgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMSwgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMSwgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQxIH0pO1xuY29uc3QgV2luZG93U2Nyb2xsZXIkMSA9IC8qIEBfX1BVUkVfXyAqLyBidWlsZFdpbmRvd1Njcm9sbGVyKHsgdXNlUHVibGlzaGVyOiB1c2VQdWJsaXNoZXIkMSwgdXNlRW1pdHRlclZhbHVlOiB1c2VFbWl0dGVyVmFsdWUkMSwgdXNlRW1pdHRlcjogdXNlRW1pdHRlciQxIH0pO1xuZnVuY3Rpb24gcmVzb2x2ZUdhcFZhbHVlKHByb3BlcnR5LCB2YWx1ZSwgbG9nKSB7XG4gIGlmICh2YWx1ZSAhPT0gXCJub3JtYWxcIiAmJiAhKHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5lbmRzV2l0aChcInB4XCIpKSkge1xuICAgIGxvZyhgJHtwcm9wZXJ0eX0gd2FzIG5vdCByZXNvbHZlZCB0byBwaXhlbCB2YWx1ZSBjb3JyZWN0bHlgLCB2YWx1ZSwgTG9nTGV2ZWwuV0FSTik7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSW50KHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IFwiMFwiLCAxMCk7XG59XG5jb25zdCBWaXJ0dW9zb0dyaWQgPSBHcmlkO1xuY29uc3QgdGFibGVDb21wb25lbnRQcm9wc1N5c3RlbSA9IC8qIEBfX1BVUkVfXyAqLyBzeXN0ZW0oKCkgPT4ge1xuICBjb25zdCBpdGVtQ29udGVudCA9IHN0YXRlZnVsU3RyZWFtKChpbmRleCkgPT4gLyogQF9fUFVSRV9fICovIGpzeHMoXCJ0ZFwiLCB7IGNoaWxkcmVuOiBbXG4gICAgXCJJdGVtICRcIixcbiAgICBpbmRleFxuICBdIH0pKTtcbiAgY29uc3QgY29udGV4dCA9IHN0YXRlZnVsU3RyZWFtKG51bGwpO1xuICBjb25zdCBmaXhlZEhlYWRlckNvbnRlbnQgPSBzdGF0ZWZ1bFN0cmVhbShudWxsKTtcbiAgY29uc3QgZml4ZWRGb290ZXJDb250ZW50ID0gc3RhdGVmdWxTdHJlYW0obnVsbCk7XG4gIGNvbnN0IGNvbXBvbmVudHMgPSBzdGF0ZWZ1bFN0cmVhbSh7fSk7XG4gIGNvbnN0IGNvbXB1dGVJdGVtS2V5ID0gc3RhdGVmdWxTdHJlYW0oaWRlbnRpdHkpO1xuICBjb25zdCBzY3JvbGxlclJlZiA9IHN0YXRlZnVsU3RyZWFtKG5vb3ApO1xuICBjb25zdCBkaXN0aW5jdFByb3AgPSAocHJvcE5hbWUsIGRlZmF1bHRWYWx1ZSA9IG51bGwpID0+IHtcbiAgICByZXR1cm4gc3RhdGVmdWxTdHJlYW1Gcm9tRW1pdHRlcihcbiAgICAgIHBpcGUoXG4gICAgICAgIGNvbXBvbmVudHMsXG4gICAgICAgIG1hcCgoY29tcG9uZW50czIpID0+IGNvbXBvbmVudHMyW3Byb3BOYW1lXSksXG4gICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICksXG4gICAgICBkZWZhdWx0VmFsdWVcbiAgICApO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQsXG4gICAgaXRlbUNvbnRlbnQsXG4gICAgZml4ZWRIZWFkZXJDb250ZW50LFxuICAgIGZpeGVkRm9vdGVyQ29udGVudCxcbiAgICBjb21wb25lbnRzLFxuICAgIGNvbXB1dGVJdGVtS2V5LFxuICAgIHNjcm9sbGVyUmVmLFxuICAgIFRhYmxlQ29tcG9uZW50OiBkaXN0aW5jdFByb3AoXCJUYWJsZVwiLCBcInRhYmxlXCIpLFxuICAgIFRhYmxlSGVhZENvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVGFibGVIZWFkXCIsIFwidGhlYWRcIiksXG4gICAgVGFibGVGb290ZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlRhYmxlRm9vdFwiLCBcInRmb290XCIpLFxuICAgIFRhYmxlQm9keUNvbXBvbmVudDogZGlzdGluY3RQcm9wKFwiVGFibGVCb2R5XCIsIFwidGJvZHlcIiksXG4gICAgVGFibGVSb3dDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlRhYmxlUm93XCIsIFwidHJcIiksXG4gICAgU2Nyb2xsZXJDb21wb25lbnQ6IGRpc3RpbmN0UHJvcChcIlNjcm9sbGVyXCIsIFwiZGl2XCIpLFxuICAgIEVtcHR5UGxhY2Vob2xkZXI6IGRpc3RpbmN0UHJvcChcIkVtcHR5UGxhY2Vob2xkZXJcIiksXG4gICAgU2Nyb2xsU2Vla1BsYWNlaG9sZGVyOiBkaXN0aW5jdFByb3AoXCJTY3JvbGxTZWVrUGxhY2Vob2xkZXJcIiksXG4gICAgRmlsbGVyUm93OiBkaXN0aW5jdFByb3AoXCJGaWxsZXJSb3dcIilcbiAgfTtcbn0pO1xuY29uc3QgY29tYmluZWRTeXN0ZW0gPSAvKiBAX19QVVJFX18gKi8gc3lzdGVtKChbbGlzdFN5c3RlbTIsIHByb3BzU3lzdGVtXSkgPT4ge1xuICByZXR1cm4geyAuLi5saXN0U3lzdGVtMiwgLi4ucHJvcHNTeXN0ZW0gfTtcbn0sIHR1cChsaXN0U3lzdGVtLCB0YWJsZUNvbXBvbmVudFByb3BzU3lzdGVtKSk7XG5jb25zdCBEZWZhdWx0U2Nyb2xsU2Vla1BsYWNlaG9sZGVyID0gKHsgaGVpZ2h0IH0pID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJ0clwiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwidGRcIiwgeyBzdHlsZTogeyBoZWlnaHQgfSB9KSB9KTtcbmNvbnN0IERlZmF1bHRGaWxsZXJSb3cgPSAoeyBoZWlnaHQgfSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcInRyXCIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJ0ZFwiLCB7IHN0eWxlOiB7IGhlaWdodCwgcGFkZGluZzogMCwgYm9yZGVyOiAwIH0gfSkgfSk7XG5jb25zdCBJVEVNX1NUWUxFID0geyBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIgfTtcbmNvbnN0IEl0ZW1zID0gLyogQF9fUFVSRV9fICovIFJlYWN0Lm1lbW8oZnVuY3Rpb24gVmlydHVvc29JdGVtczIoeyBzaG93VG9wTGlzdCA9IGZhbHNlIH0pIHtcbiAgY29uc3QgbGlzdFN0YXRlID0gdXNlRW1pdHRlclZhbHVlKFwibGlzdFN0YXRlXCIpO1xuICBjb25zdCBjb21wdXRlSXRlbUtleSA9IHVzZUVtaXR0ZXJWYWx1ZShcImNvbXB1dGVJdGVtS2V5XCIpO1xuICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHVzZUVtaXR0ZXJWYWx1ZShcImZpcnN0SXRlbUluZGV4XCIpO1xuICBjb25zdCBpc1NlZWtpbmcgPSB1c2VFbWl0dGVyVmFsdWUoXCJpc1NlZWtpbmdcIik7XG4gIGNvbnN0IFNjcm9sbFNlZWtQbGFjZWhvbGRlciA9IHVzZUVtaXR0ZXJWYWx1ZShcIlNjcm9sbFNlZWtQbGFjZWhvbGRlclwiKSB8fCBEZWZhdWx0U2Nyb2xsU2Vla1BsYWNlaG9sZGVyO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlKFwiY29udGV4dFwiKTtcbiAgY29uc3QgVGFibGVSb3dDb21wb25lbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJUYWJsZVJvd0NvbXBvbmVudFwiKTtcbiAgY29uc3QgZml4ZWRIZWFkZXJIZWlnaHQgPSB1c2VFbWl0dGVyVmFsdWUoXCJmaXhlZEhlYWRlckhlaWdodFwiKTtcbiAgY29uc3QgaXRlbUNvbnRlbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJpdGVtQ29udGVudFwiKTtcbiAgY29uc3QgdG9wSXRlbU9mZnNldHMgPSAoc2hvd1RvcExpc3QgPyBsaXN0U3RhdGUudG9wSXRlbXMgOiBbXSkucmVkdWNlKChhY2MsIGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBhY2MucHVzaChpdGVtLnNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2MucHVzaChhY2NbaW5kZXggLSAxXSArIGl0ZW0uc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgY29uc3QgaXRlbXMgPSAoc2hvd1RvcExpc3QgPyBsaXN0U3RhdGUudG9wSXRlbXMgOiBsaXN0U3RhdGUuaXRlbXMpLm1hcCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gaXRlbS5vcmlnaW5hbEluZGV4O1xuICAgIGNvbnN0IGtleSA9IGNvbXB1dGVJdGVtS2V5KGluZGV4ICsgZmlyc3RJdGVtSW5kZXgsIGl0ZW0uZGF0YSwgY29udGV4dCk7XG4gICAgY29uc3Qgb2Zmc2V0VG9wID0gc2hvd1RvcExpc3QgPyBpbmRleCA9PT0gMCA/IDAgOiB0b3BJdGVtT2Zmc2V0c1tpbmRleCAtIDFdIDogMDtcbiAgICBpZiAoaXNTZWVraW5nKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFNjcm9sbFNlZWtQbGFjZWhvbGRlcixcbiAgICAgICAge1xuICAgICAgICAgIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFNjcm9sbFNlZWtQbGFjZWhvbGRlciwgY29udGV4dCksXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGluZGV4OiBpdGVtLmluZGV4LFxuICAgICAgICAgIGhlaWdodDogaXRlbS5zaXplLFxuICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZSB8fCBcIml0ZW1cIlxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGNyZWF0ZUVsZW1lbnQoXG4gICAgICBUYWJsZVJvd0NvbXBvbmVudCxcbiAgICAgIHtcbiAgICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoVGFibGVSb3dDb21wb25lbnQsIGNvbnRleHQpLFxuICAgICAgICAuLi5pdGVtUHJvcElmTm90RG9tRWxlbWVudChUYWJsZVJvd0NvbXBvbmVudCwgaXRlbS5kYXRhKSxcbiAgICAgICAga2V5LFxuICAgICAgICBcImRhdGEtaW5kZXhcIjogaW5kZXgsXG4gICAgICAgIFwiZGF0YS1rbm93bi1zaXplXCI6IGl0ZW0uc2l6ZSxcbiAgICAgICAgXCJkYXRhLWl0ZW0taW5kZXhcIjogaXRlbS5pbmRleCxcbiAgICAgICAgc3R5bGU6IHNob3dUb3BMaXN0ID8geyBvdmVyZmxvd0FuY2hvcjogXCJub25lXCIsIHBvc2l0aW9uOiBcInN0aWNreVwiLCB6SW5kZXg6IDIsIHRvcDogZml4ZWRIZWFkZXJIZWlnaHQgKyBvZmZzZXRUb3AgfSA6IElURU1fU1RZTEVcbiAgICAgIH0sXG4gICAgICBpdGVtQ29udGVudChpdGVtLmluZGV4LCBpdGVtLmRhdGEsIGNvbnRleHQpXG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBpdGVtcyB9KTtcbn0pO1xuY29uc3QgVGFibGVCb2R5ID0gLyogQF9fUFVSRV9fICovIFJlYWN0Lm1lbW8oZnVuY3Rpb24gVGFibGVWaXJ0dW9zb0JvZHkoKSB7XG4gIGNvbnN0IGxpc3RTdGF0ZSA9IHVzZUVtaXR0ZXJWYWx1ZShcImxpc3RTdGF0ZVwiKTtcbiAgY29uc3Qgc2hvd1RvcExpc3QgPSB1c2VFbWl0dGVyVmFsdWUoXCJ0b3BJdGVtc0luZGV4ZXNcIikubGVuZ3RoID4gMDtcbiAgY29uc3Qgc2l6ZVJhbmdlcyA9IHVzZVB1Ymxpc2hlcihcInNpemVSYW5nZXNcIik7XG4gIGNvbnN0IHVzZVdpbmRvd1Njcm9sbCA9IHVzZUVtaXR0ZXJWYWx1ZShcInVzZVdpbmRvd1Njcm9sbFwiKTtcbiAgY29uc3QgY3VzdG9tU2Nyb2xsUGFyZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiY3VzdG9tU2Nyb2xsUGFyZW50XCIpO1xuICBjb25zdCB3aW5kb3dTY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyKFwid2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gIGNvbnN0IF9zY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrID0gdXNlUHVibGlzaGVyKFwic2Nyb2xsQ29udGFpbmVyU3RhdGVcIik7XG4gIGNvbnN0IHNjcm9sbENvbnRhaW5lclN0YXRlQ2FsbGJhY2sgPSBjdXN0b21TY3JvbGxQYXJlbnQgfHwgdXNlV2luZG93U2Nyb2xsID8gd2luZG93U2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayA6IF9zY3JvbGxDb250YWluZXJTdGF0ZUNhbGxiYWNrO1xuICBjb25zdCB0cmFja0l0ZW1TaXplcyA9IHVzZUVtaXR0ZXJWYWx1ZShcInRyYWNrSXRlbVNpemVzXCIpO1xuICBjb25zdCBpdGVtU2l6ZSA9IHVzZUVtaXR0ZXJWYWx1ZShcIml0ZW1TaXplXCIpO1xuICBjb25zdCBsb2cgPSB1c2VFbWl0dGVyVmFsdWUoXCJsb2dcIik7XG4gIGNvbnN0IHsgY2FsbGJhY2tSZWYsIHJlZiB9ID0gdXNlQ2hhbmdlZExpc3RDb250ZW50c1NpemVzKFxuICAgIHNpemVSYW5nZXMsXG4gICAgaXRlbVNpemUsXG4gICAgdHJhY2tJdGVtU2l6ZXMsXG4gICAgc2Nyb2xsQ29udGFpbmVyU3RhdGVDYWxsYmFjayxcbiAgICBsb2csXG4gICAgdm9pZCAwLFxuICAgIGN1c3RvbVNjcm9sbFBhcmVudCxcbiAgICBmYWxzZSxcbiAgICB1c2VFbWl0dGVyVmFsdWUoXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICk7XG4gIGNvbnN0IFtkZXZpYXRpb24sIHNldERldmlhdGlvbl0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgdXNlRW1pdHRlcihcImRldmlhdGlvblwiLCAodmFsdWUpID0+IHtcbiAgICBpZiAoZGV2aWF0aW9uICE9PSB2YWx1ZSkge1xuICAgICAgcmVmLmN1cnJlbnQuc3R5bGUubWFyZ2luVG9wID0gYCR7dmFsdWV9cHhgO1xuICAgICAgc2V0RGV2aWF0aW9uKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBFbXB0eVBsYWNlaG9sZGVyID0gdXNlRW1pdHRlclZhbHVlKFwiRW1wdHlQbGFjZWhvbGRlclwiKTtcbiAgY29uc3QgRmlsbGVyUm93ID0gdXNlRW1pdHRlclZhbHVlKFwiRmlsbGVyUm93XCIpIHx8IERlZmF1bHRGaWxsZXJSb3c7XG4gIGNvbnN0IFRhYmxlQm9keUNvbXBvbmVudCA9IHVzZUVtaXR0ZXJWYWx1ZShcIlRhYmxlQm9keUNvbXBvbmVudFwiKTtcbiAgY29uc3QgcGFkZGluZ1RvcEFkZGl0aW9uID0gdXNlRW1pdHRlclZhbHVlKFwicGFkZGluZ1RvcEFkZGl0aW9uXCIpO1xuICBjb25zdCBzdGF0ZWZ1bFRvdGFsQ291bnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJzdGF0ZWZ1bFRvdGFsQ291bnRcIik7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VFbWl0dGVyVmFsdWUoXCJjb250ZXh0XCIpO1xuICBpZiAoc3RhdGVmdWxUb3RhbENvdW50ID09PSAwICYmIEVtcHR5UGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChFbXB0eVBsYWNlaG9sZGVyLCB7IC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KEVtcHR5UGxhY2Vob2xkZXIsIGNvbnRleHQpIH0pO1xuICB9XG4gIGNvbnN0IHRvcEl0ZW1zU2l6ZSA9IChzaG93VG9wTGlzdCA/IGxpc3RTdGF0ZS50b3BJdGVtcyA6IFtdKS5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gYWNjICsgaXRlbS5zaXplLCAwKTtcbiAgY29uc3QgcGFkZGluZ1RvcCA9IGxpc3RTdGF0ZS5vZmZzZXRUb3AgKyBwYWRkaW5nVG9wQWRkaXRpb24gKyBkZXZpYXRpb24gLSB0b3BJdGVtc1NpemU7XG4gIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBsaXN0U3RhdGUub2Zmc2V0Qm90dG9tO1xuICBjb25zdCBwYWRkaW5nVG9wRWwgPSBwYWRkaW5nVG9wID4gMCA/IC8qIEBfX1BVUkVfXyAqLyBqc3goRmlsbGVyUm93LCB7IGhlaWdodDogcGFkZGluZ1RvcCwgY29udGV4dCB9LCBcInBhZGRpbmctdG9wXCIpIDogbnVsbDtcbiAgY29uc3QgcGFkZGluZ0JvdHRvbUVsID0gcGFkZGluZ0JvdHRvbSA+IDAgPyAvKiBAX19QVVJFX18gKi8ganN4KEZpbGxlclJvdywgeyBoZWlnaHQ6IHBhZGRpbmdCb3R0b20sIGNvbnRleHQgfSwgXCJwYWRkaW5nLWJvdHRvbVwiKSA6IG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhUYWJsZUJvZHlDb21wb25lbnQsIHsgcmVmOiBjYWxsYmFja1JlZiwgXCJkYXRhLXRlc3RpZFwiOiBcInZpcnR1b3NvLWl0ZW0tbGlzdFwiLCAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChUYWJsZUJvZHlDb21wb25lbnQsIGNvbnRleHQpLCBjaGlsZHJlbjogW1xuICAgIHBhZGRpbmdUb3BFbCxcbiAgICBzaG93VG9wTGlzdCAmJiAvKiBAX19QVVJFX18gKi8ganN4KEl0ZW1zLCB7IHNob3dUb3BMaXN0OiB0cnVlIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goSXRlbXMsIHt9KSxcbiAgICBwYWRkaW5nQm90dG9tRWxcbiAgXSB9KTtcbn0pO1xuY29uc3QgVmlld3BvcnQgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVmlydHVvc29Nb2NrQ29udGV4dCk7XG4gIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwidmlld3BvcnRIZWlnaHRcIik7XG4gIGNvbnN0IGZpeGVkSXRlbUhlaWdodCA9IHVzZVB1Ymxpc2hlcihcImZpeGVkSXRlbUhlaWdodFwiKTtcbiAgY29uc3Qgdmlld3BvcnRSZWYgPSB1c2VTaXplKFxuICAgIFJlYWN0LnVzZU1lbW8oKCkgPT4gY29tcG9zZSh2aWV3cG9ydEhlaWdodCwgKGVsKSA9PiBjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSwgW3ZpZXdwb3J0SGVpZ2h0XSksXG4gICAgdHJ1ZSxcbiAgICB1c2VFbWl0dGVyVmFsdWUoXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN0eCkge1xuICAgICAgdmlld3BvcnRIZWlnaHQoY3R4LnZpZXdwb3J0SGVpZ2h0KTtcbiAgICAgIGZpeGVkSXRlbUhlaWdodChjdHguaXRlbUhlaWdodCk7XG4gICAgfVxuICB9LCBbY3R4LCB2aWV3cG9ydEhlaWdodCwgZml4ZWRJdGVtSGVpZ2h0XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgc3R5bGU6IHZpZXdwb3J0U3R5bGUoZmFsc2UpLCByZWY6IHZpZXdwb3J0UmVmLCBcImRhdGEtdmlld3BvcnQtdHlwZVwiOiBcImVsZW1lbnRcIiwgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgV2luZG93Vmlld3BvcnQgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVmlydHVvc29Nb2NrQ29udGV4dCk7XG4gIGNvbnN0IHdpbmRvd1ZpZXdwb3J0UmVjdCA9IHVzZVB1Ymxpc2hlcihcIndpbmRvd1ZpZXdwb3J0UmVjdFwiKTtcbiAgY29uc3QgZml4ZWRJdGVtSGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwiZml4ZWRJdGVtSGVpZ2h0XCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IHZpZXdwb3J0UmVmID0gdXNlV2luZG93Vmlld3BvcnRSZWN0UmVmKFxuICAgIHdpbmRvd1ZpZXdwb3J0UmVjdCxcbiAgICBjdXN0b21TY3JvbGxQYXJlbnQsXG4gICAgdXNlRW1pdHRlclZhbHVlKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdHgpIHtcbiAgICAgIGZpeGVkSXRlbUhlaWdodChjdHguaXRlbUhlaWdodCk7XG4gICAgICB3aW5kb3dWaWV3cG9ydFJlY3QoeyBvZmZzZXRUb3A6IDAsIHZpc2libGVIZWlnaHQ6IGN0eC52aWV3cG9ydEhlaWdodCwgdmlzaWJsZVdpZHRoOiAxMDAgfSk7XG4gICAgfVxuICB9LCBbY3R4LCB3aW5kb3dWaWV3cG9ydFJlY3QsIGZpeGVkSXRlbUhlaWdodF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImRpdlwiLCB7IHJlZjogdmlld3BvcnRSZWYsIHN0eWxlOiB2aWV3cG9ydFN0eWxlKGZhbHNlKSwgXCJkYXRhLXZpZXdwb3J0LXR5cGVcIjogXCJ3aW5kb3dcIiwgY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgVGFibGVSb290ID0gLyogQF9fUFVSRV9fICovIFJlYWN0Lm1lbW8oZnVuY3Rpb24gVGFibGVWaXJ0dW9zb1Jvb3QocHJvcHMpIHtcbiAgY29uc3QgdXNlV2luZG93U2Nyb2xsID0gdXNlRW1pdHRlclZhbHVlKFwidXNlV2luZG93U2Nyb2xsXCIpO1xuICBjb25zdCBjdXN0b21TY3JvbGxQYXJlbnQgPSB1c2VFbWl0dGVyVmFsdWUoXCJjdXN0b21TY3JvbGxQYXJlbnRcIik7XG4gIGNvbnN0IGZpeGVkSGVhZGVySGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwiZml4ZWRIZWFkZXJIZWlnaHRcIik7XG4gIGNvbnN0IGZpeGVkRm9vdGVySGVpZ2h0ID0gdXNlUHVibGlzaGVyKFwiZml4ZWRGb290ZXJIZWlnaHRcIik7XG4gIGNvbnN0IGZpeGVkSGVhZGVyQ29udGVudCA9IHVzZUVtaXR0ZXJWYWx1ZShcImZpeGVkSGVhZGVyQ29udGVudFwiKTtcbiAgY29uc3QgZml4ZWRGb290ZXJDb250ZW50ID0gdXNlRW1pdHRlclZhbHVlKFwiZml4ZWRGb290ZXJDb250ZW50XCIpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlRW1pdHRlclZhbHVlKFwiY29udGV4dFwiKTtcbiAgY29uc3QgdGhlYWRSZWYgPSB1c2VTaXplKFxuICAgIFJlYWN0LnVzZU1lbW8oKCkgPT4gY29tcG9zZShmaXhlZEhlYWRlckhlaWdodCwgKGVsKSA9PiBjb3JyZWN0SXRlbVNpemUoZWwsIFwiaGVpZ2h0XCIpKSwgW2ZpeGVkSGVhZGVySGVpZ2h0XSksXG4gICAgdHJ1ZSxcbiAgICB1c2VFbWl0dGVyVmFsdWUoXCJza2lwQW5pbWF0aW9uRnJhbWVJblJlc2l6ZU9ic2VydmVyXCIpXG4gICk7XG4gIGNvbnN0IHRmb290UmVmID0gdXNlU2l6ZShcbiAgICBSZWFjdC51c2VNZW1vKCgpID0+IGNvbXBvc2UoZml4ZWRGb290ZXJIZWlnaHQsIChlbCkgPT4gY29ycmVjdEl0ZW1TaXplKGVsLCBcImhlaWdodFwiKSksIFtmaXhlZEZvb3RlckhlaWdodF0pLFxuICAgIHRydWUsXG4gICAgdXNlRW1pdHRlclZhbHVlKFwic2tpcEFuaW1hdGlvbkZyYW1lSW5SZXNpemVPYnNlcnZlclwiKVxuICApO1xuICBjb25zdCBUaGVTY3JvbGxlciA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dTY3JvbGxlciA6IFNjcm9sbGVyO1xuICBjb25zdCBUaGVWaWV3cG9ydCA9IGN1c3RvbVNjcm9sbFBhcmVudCB8fCB1c2VXaW5kb3dTY3JvbGwgPyBXaW5kb3dWaWV3cG9ydCA6IFZpZXdwb3J0O1xuICBjb25zdCBUaGVUYWJsZSA9IHVzZUVtaXR0ZXJWYWx1ZShcIlRhYmxlQ29tcG9uZW50XCIpO1xuICBjb25zdCBUaGVUSGVhZCA9IHVzZUVtaXR0ZXJWYWx1ZShcIlRhYmxlSGVhZENvbXBvbmVudFwiKTtcbiAgY29uc3QgVGhlVEZvb3QgPSB1c2VFbWl0dGVyVmFsdWUoXCJUYWJsZUZvb3RlckNvbXBvbmVudFwiKTtcbiAgY29uc3QgdGhlSGVhZCA9IGZpeGVkSGVhZGVyQ29udGVudCA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgVGhlVEhlYWQsXG4gICAge1xuICAgICAgc3R5bGU6IHsgekluZGV4OiAyLCBwb3NpdGlvbjogXCJzdGlja3lcIiwgdG9wOiAwIH0sXG4gICAgICByZWY6IHRoZWFkUmVmLFxuICAgICAgLi4uY29udGV4dFByb3BJZk5vdERvbUVsZW1lbnQoVGhlVEhlYWQsIGNvbnRleHQpLFxuICAgICAgY2hpbGRyZW46IGZpeGVkSGVhZGVyQ29udGVudCgpXG4gICAgfSxcbiAgICBcIlRhYmxlSGVhZFwiXG4gICkgOiBudWxsO1xuICBjb25zdCB0aGVGb290ID0gZml4ZWRGb290ZXJDb250ZW50ID8gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBUaGVURm9vdCxcbiAgICB7XG4gICAgICBzdHlsZTogeyB6SW5kZXg6IDEsIHBvc2l0aW9uOiBcInN0aWNreVwiLCBib3R0b206IDAgfSxcbiAgICAgIHJlZjogdGZvb3RSZWYsXG4gICAgICAuLi5jb250ZXh0UHJvcElmTm90RG9tRWxlbWVudChUaGVURm9vdCwgY29udGV4dCksXG4gICAgICBjaGlsZHJlbjogZml4ZWRGb290ZXJDb250ZW50KClcbiAgICB9LFxuICAgIFwiVGFibGVGb290XCJcbiAgKSA6IG51bGw7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFRoZVNjcm9sbGVyLCB7IC4uLnByb3BzLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChUaGVWaWV3cG9ydCwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoVGhlVGFibGUsIHsgc3R5bGU6IHsgYm9yZGVyU3BhY2luZzogMCwgb3ZlcmZsb3dBbmNob3I6IFwibm9uZVwiIH0sIC4uLmNvbnRleHRQcm9wSWZOb3REb21FbGVtZW50KFRoZVRhYmxlLCBjb250ZXh0KSwgY2hpbGRyZW46IFtcbiAgICB0aGVIZWFkLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVGFibGVCb2R5LCB7fSwgXCJUYWJsZUJvZHlcIiksXG4gICAgdGhlRm9vdFxuICBdIH0pIH0pIH0pO1xufSk7XG5jb25zdCB7XG4gIENvbXBvbmVudDogVGFibGUsXG4gIHVzZVB1Ymxpc2hlcixcbiAgdXNlRW1pdHRlclZhbHVlLFxuICB1c2VFbWl0dGVyXG59ID0gLyogQF9fUFVSRV9fICovIHN5c3RlbVRvQ29tcG9uZW50KFxuICBjb21iaW5lZFN5c3RlbSxcbiAge1xuICAgIHJlcXVpcmVkOiB7fSxcbiAgICBvcHRpb25hbDoge1xuICAgICAgcmVzdG9yZVN0YXRlRnJvbTogXCJyZXN0b3JlU3RhdGVGcm9tXCIsXG4gICAgICBjb250ZXh0OiBcImNvbnRleHRcIixcbiAgICAgIGZvbGxvd091dHB1dDogXCJmb2xsb3dPdXRwdXRcIixcbiAgICAgIGZpcnN0SXRlbUluZGV4OiBcImZpcnN0SXRlbUluZGV4XCIsXG4gICAgICBpdGVtQ29udGVudDogXCJpdGVtQ29udGVudFwiLFxuICAgICAgZml4ZWRIZWFkZXJDb250ZW50OiBcImZpeGVkSGVhZGVyQ29udGVudFwiLFxuICAgICAgZml4ZWRGb290ZXJDb250ZW50OiBcImZpeGVkRm9vdGVyQ29udGVudFwiLFxuICAgICAgb3ZlcnNjYW46IFwib3ZlcnNjYW5cIixcbiAgICAgIGluY3JlYXNlVmlld3BvcnRCeTogXCJpbmNyZWFzZVZpZXdwb3J0QnlcIixcbiAgICAgIHRvdGFsQ291bnQ6IFwidG90YWxDb3VudFwiLFxuICAgICAgdG9wSXRlbUNvdW50OiBcInRvcEl0ZW1Db3VudFwiLFxuICAgICAgaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXg6IFwiaW5pdGlhbFRvcE1vc3RJdGVtSW5kZXhcIixcbiAgICAgIGNvbXBvbmVudHM6IFwiY29tcG9uZW50c1wiLFxuICAgICAgZ3JvdXBDb3VudHM6IFwiZ3JvdXBDb3VudHNcIixcbiAgICAgIGF0Qm90dG9tVGhyZXNob2xkOiBcImF0Qm90dG9tVGhyZXNob2xkXCIsXG4gICAgICBhdFRvcFRocmVzaG9sZDogXCJhdFRvcFRocmVzaG9sZFwiLFxuICAgICAgY29tcHV0ZUl0ZW1LZXk6IFwiY29tcHV0ZUl0ZW1LZXlcIixcbiAgICAgIGRlZmF1bHRJdGVtSGVpZ2h0OiBcImRlZmF1bHRJdGVtSGVpZ2h0XCIsXG4gICAgICBmaXhlZEl0ZW1IZWlnaHQ6IFwiZml4ZWRJdGVtSGVpZ2h0XCIsXG4gICAgICBpdGVtU2l6ZTogXCJpdGVtU2l6ZVwiLFxuICAgICAgc2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb246IFwic2Nyb2xsU2Vla0NvbmZpZ3VyYXRpb25cIixcbiAgICAgIGRhdGE6IFwiZGF0YVwiLFxuICAgICAgaW5pdGlhbEl0ZW1Db3VudDogXCJpbml0aWFsSXRlbUNvdW50XCIsXG4gICAgICBpbml0aWFsU2Nyb2xsVG9wOiBcImluaXRpYWxTY3JvbGxUb3BcIixcbiAgICAgIGFsaWduVG9Cb3R0b206IFwiYWxpZ25Ub0JvdHRvbVwiLFxuICAgICAgdXNlV2luZG93U2Nyb2xsOiBcInVzZVdpbmRvd1Njcm9sbFwiLFxuICAgICAgY3VzdG9tU2Nyb2xsUGFyZW50OiBcImN1c3RvbVNjcm9sbFBhcmVudFwiLFxuICAgICAgc2Nyb2xsZXJSZWY6IFwic2Nyb2xsZXJSZWZcIixcbiAgICAgIGxvZ0xldmVsOiBcImxvZ0xldmVsXCJcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHNjcm9sbFRvSW5kZXg6IFwic2Nyb2xsVG9JbmRleFwiLFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6IFwic2Nyb2xsSW50b1ZpZXdcIixcbiAgICAgIHNjcm9sbFRvOiBcInNjcm9sbFRvXCIsXG4gICAgICBzY3JvbGxCeTogXCJzY3JvbGxCeVwiLFxuICAgICAgZ2V0U3RhdGU6IFwiZ2V0U3RhdGVcIlxuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICBpc1Njcm9sbGluZzogXCJpc1Njcm9sbGluZ1wiLFxuICAgICAgZW5kUmVhY2hlZDogXCJlbmRSZWFjaGVkXCIsXG4gICAgICBzdGFydFJlYWNoZWQ6IFwic3RhcnRSZWFjaGVkXCIsXG4gICAgICByYW5nZUNoYW5nZWQ6IFwicmFuZ2VDaGFuZ2VkXCIsXG4gICAgICBhdEJvdHRvbVN0YXRlQ2hhbmdlOiBcImF0Qm90dG9tU3RhdGVDaGFuZ2VcIixcbiAgICAgIGF0VG9wU3RhdGVDaGFuZ2U6IFwiYXRUb3BTdGF0ZUNoYW5nZVwiLFxuICAgICAgdG90YWxMaXN0SGVpZ2h0Q2hhbmdlZDogXCJ0b3RhbExpc3RIZWlnaHRDaGFuZ2VkXCIsXG4gICAgICBpdGVtc1JlbmRlcmVkOiBcIml0ZW1zUmVuZGVyZWRcIixcbiAgICAgIGdyb3VwSW5kaWNlczogXCJncm91cEluZGljZXNcIlxuICAgIH1cbiAgfSxcbiAgVGFibGVSb290XG4pO1xuY29uc3QgU2Nyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRTY3JvbGxlcih7IHVzZVB1Ymxpc2hlciwgdXNlRW1pdHRlclZhbHVlLCB1c2VFbWl0dGVyIH0pO1xuY29uc3QgV2luZG93U2Nyb2xsZXIgPSAvKiBAX19QVVJFX18gKi8gYnVpbGRXaW5kb3dTY3JvbGxlcih7IHVzZVB1Ymxpc2hlciwgdXNlRW1pdHRlclZhbHVlLCB1c2VFbWl0dGVyIH0pO1xuY29uc3QgVGFibGVWaXJ0dW9zbyA9IFRhYmxlO1xuZXhwb3J0IHtcbiAgR3JvdXBlZFZpcnR1b3NvLFxuICBMb2dMZXZlbCxcbiAgVGFibGVWaXJ0dW9zbyxcbiAgVmlydHVvc28sXG4gIFZpcnR1b3NvR3JpZCxcbiAgVmlydHVvc29HcmlkTW9ja0NvbnRleHQsXG4gIFZpcnR1b3NvTW9ja0NvbnRleHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-virtuoso/dist/index.mjs\n");

/***/ })

};
;